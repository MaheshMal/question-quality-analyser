1. Do some research on al-Khorezmi (also al-Khwarizmi), the man from whose name the word "algorithm" is derived. In particular, you should learn what the origins of the words "algorithm" and "algebra" have in common. 
2. Given that the official purpose of the U.S. patent system is the promotion of the "useful arts," do you think algorithms are patentable in this country? Should they be? 
3. a. Write down driving directions for going from your school to your home with the precision required from an algorithm's description. b. Write down a recipe for cooking your favorite dish with the precision required by an algorithm.
Design an algorithm to find all the common elements in two sorted lists of numbers. For example, for the lists 2, 5, 5, 5 and 2, 2, 3, 5, 5, 7, the output should be 2, 5, 5. What is the maximum number of comparisons your algorithm makes if the lengths of the two given lists are m and n, respectively?
a.  Find gcd(31415, 14142) by applying Euclid's algorithm.
b. Estimate how many times faster it will be to find gcd(31415, 14142) by Euclid's algorithm compared with the algorithm based on checking consecutive integers from min{m, n} down to gcd(m, n).
Prove the equality gcd(m, n) = gcd(n, m mod n) for every pair of positive integers m and n.
What does Euclid's algorithm do for a pair of integers in which the first is smaller than the second? What is the maximum number of times this can happen during the algorithm's execution on such an input?
What is the minimum number of  divisions  made   by   Euclid's  algorithm among all inputs 1  m, n  10?
b. What is the maximum number of divisions made by Euclid's algorithm among all inputs 1 m, n 10?
a.  Euclid's algorithm, as presented in Euclid's treatise, uses subtractions rather than integer divisions. Write pseudocode for this version of Euclid's algorithm.
b. Euclid's game (see [Bog]) starts with two unequal positive integers on the board. Two players move in turn. On each move, a player has to write on the board a positive number equal to the difference of two numbers already on the board; this number must be new, i.e., different from all the numbers already on the board. The player who cannot move loses the game. Should you choose to move first or second in this game?
The extended Euclid's algorithm determines not only the greatest common divisor d of two positive integers m and n but also integers (not necessarily positive) x and y, such that mx + ny = d. a.  Look up a description of the extended Euclid's algorithm (see, e.g., [KnuI, p. 13]) and implement it in the language of your choice.
The extended Euclid's algorithm determines not only the greatest common divisor d of two positive integers m and n but also integers (not necessarily positive) x and y, such that mx + ny = d. b. Modify your program to find integer solutions to the Diophantine equation ax + by = c with any set of integer coefficients a, b, and c.
Locker doorsThere are n lockers in a hallway, numbered sequentially from 1 to n. Initially, all the locker doors are closed. You make n passes by the lockers, each time starting with locker # On the ith pass, i = 1, 2, . . . , n, you toggle the door of every ith locker: if the door is closed, you open it; if it is open, you close it. After the last pass, which locker doors are open and which are closed? How many of them are open?
Old World puzzle A peasant finds himself on a riverbank with a wolf, a goat, and a head of cabbage. He needs to transport all three to the other side of the river in his boat. However, the boat has room for only the peasant himself and one other item (either the wolf, the goat, or the cabbage). In his absence, the wolf would eat the goat, and the goat would eat the cabbage. Solve this problem for the peasant or prove it has no solution. (Note: The peasant is a vegetarian but does not like cabbage and hence can eat neither the goat nor the cabbage to help him solve the problem. And it goes without saying that the wolf is a protected species.)
New World puzzle There are four people who want to cross a rickety bridge; they all begin on the same side. You have 17 minutes to get them all across to the other side. It is night, and they have one flashlight. A maximum of two people can cross the bridge at one time. Any party that crosses, either one or two people, must have the flashlight with them. The flashlight must be walked back and forth; it cannot be thrown, for example. Person 1 takes 1 minute to cross the bridge, person 2 takes 2 minutes, person 3 takes 5 minutes, and person 4 takes 10 minutes. A pair must walk together at the rate of the slower person's pace. (Note: According to a rumor on the Internet, interviewers at a well-known software company located near Seattle have given this problem to interviewees.)
Which of the following formulas can be considered an algorithm for computing the area of a triangle whose side lengths are given positive numbers a, b, and c?
Write pseudocode for an algorithm for finding real roots of equation ax2 + bx + c = 0 for arbitrary real coefficients a, b, and c. (You may assume the availability of the square root function sqrt (x).)
Describe the standard algorithm for finding the binary representation of a positive decimal integer a.  in English. b. in pseudocode.
Describe the algorithm used by your favorite ATM machine in dispensing cash. (You may give your description in either English or pseudocode, whichever you find more convenient.)
a.  Can the problem of computing the number be solved exactly?
Give an example of a problem other than computing the greatest common divisor for which you know more than one algorithm. Which of them is simpler? Which is more efficient?
Consider the following algorithm for finding the distance between the two closest elements in an array of numbers. <Algorithm> Make as many improvements as you can in this algorithmic solution to the problem. If you need to, you may change the algorithm altogether; if not, improve the implementation given.
One of the most influential books on problem solving, titled How To Solve It [Pol57], was written by the Hungarian-American mathematician George Po´ lya (1887­1985). Po´ lya summarized his ideas in a four-point summary. Find this summary on the Internet or, better yet, in his book, and compare it with the plan outlined in Section 2. What do they have in common? How are they different?
Consider the algorithm for the sorting problem that sorts an array by counting, for each of its elements, the number of smaller elements and then uses this information to put the element in its appropriate position in the sorted array: <Algorithm> Comparison Counting Sort. Apply this algorithm to sorting the list 60, 35, 81, 98, 14, 47.
Consider the algorithm for the sorting problem that sorts an array by counting, for each of its elements, the number of smaller elements and then uses this information to put the element in its appropriate position in the sorted array: <Algorithm> Comparison Counting Sort. Is this algorithm stable?
Consider the algorithm for the sorting problem that sorts an array by counting, for each of its elements, the number of smaller elements and then uses this information to put the element in its appropriate position in the sorted array: <Algorithm> Comparison Counting Sort. Is it in-place?
Name the algorithms for the searching problem that you already know. Give a good succinct description of each algorithm in English. If you know no such algorithms, use this opportunity to design one.
Design a simple algorithm for the string-matching problem.
Ko¨ nigsberg bridges  The Ko¨ nigsberg bridge puzzle is universally accepted as the problem that gave birth to graph theory. It was solved by the great Swiss-born mathematician Leonhard Euler (1707­1783). The problem asked whether one could, in a single stroll, cross all seven bridges of the city of Ko¨ nigsberg exactly once and return to a starting point. Following is a sketch of the river with its two islands and seven bridges: State the problem as a graph problem.
Ko¨ nigsberg bridges  The Ko¨ nigsberg bridge puzzle is universally accepted as the problem that gave birth to graph theory. It was solved by the great Swiss-born mathematician Leonhard Euler (1707­1783). The problem asked whether one could, in a single stroll, cross all seven bridges of the city of Ko¨ nigsberg exactly once and return to a starting point. Following is a sketch of the river with its two islands and seven bridges: Does this problem have a solution? If you believe it does, draw such a stroll;
Ko¨ nigsberg bridges  The Ko¨ nigsberg bridge puzzle is universally accepted as the problem that gave birth to graph theory. It was solved by the great Swiss-born mathematician Leonhard Euler (1707­1783). The problem asked whether one could, in a single stroll, cross all seven bridges of the city of Ko¨ nigsberg exactly once and return to a starting point. Following is a sketch of the river with its two islands and seven bridges: if you believe it does not, explain why and indicate the smallest number of new bridges that would be required to make such a stroll possible.
Icosian Game  A century after Euler's discovery (see Problem 4), another famous puzzle--this one invented by the renowned Irish mathematician Sir William Hamilton (1805­1865)-- was presented to the world under the name of the Icosian Game. The game's board was a circular wooden board on which the following graph was carved: Find a Hamiltonian circuit--a path that visits all the graph's vertices exactly once before returning to the starting vertex--for this graph.
Consider the following problem: Design an algorithm to determine the best route for a subway passenger to take from one designated station to another in a well-developed subway system similar to those in such cities as Washington, D.C., and London, UK. The problem's statement is somewhat vague, which is typical of real-life problems. In particular, what reasonable criterion can be used for defining the best route?
Consider the following problem: Design an algorithm to determine the best route for a subway passenger to take from one designated station to another in a well-developed subway system similar to those in such cities as Washington, D.C., and London, UK. How would you model this problem by a graph?
Rephrase the traveling-salesman problem in combinatorial object terms.
Rephrase the graph-coloring problem in combinatorial object terms.
Consider the following map: Explain how we can use the graph-coloring problem to color the map so that no two neighboring regions are colored the same.
Design an algorithm for the following problem: Given a set of n points in the Cartesian plane, determine whether all of them lie on the same circumference. Write a program that reads as its inputs the (x, y) coordinates of the endpoints of two line segments P1Q1 and P2Q2 and determines whether the segments have a common point.
Describe how one can implement each of the following operations on an array so that the time it takes does not depend on the array's size n. Delete the ith element of an array (1  i  n).
Describe how one can implement each of the following operations on an array so that the time it takes does not depend on the array's size n. Delete the ith element of a sorted array (the remaining array has to stay sorted, of course).
If you have to solve the searching problem for a list of n numbers, how can you take advantage of the fact that the list is known to be sorted? Give separate answers for a.  lists represented as arrays. b. lists represented as linked lists.
a. Show the stack after each operation of the following sequence that starts with the empty stack: push(a), push(b), pop, push(c), push(d), pop
b. Show the queue after each operation of the following sequence that starts with the empty queue: enqueue(a), enqueue(b), dequeue, enqueue(c), enqueue(d), dequeue
Let A be the adjacency matrix of an undirected graph. Explain what property of the matrix indicates that i. the graph is complete. ii. the graph has a loop, i.e., an edge connecting a vertex to itself. iii. the graph has an isolated vertex, i.e., a vertex with no edges incident to it.
Let A be the adjacency list of an undirected graph. Explain what property of the list indicates that i. the graph is complete. ii. the graph has a loop, i.e., an edge connecting a vertex to itself. iii. the graph has an isolated vertex, i.e., a vertex with no edges incident to it.
Give a detailed description of an algorithm for transforming a free tree into a tree rooted at a given vertex of the free tree.
Indicate how the ADT priority queue can be implemented as a. an (unsorted) array. b. a sorted array. c.  a binary search tree.
How would you implement a dictionary of a reasonably small size n if you knew that all its elements are distinct (e.g., names of the 50 states of the United States)? Specify an implementation of each dictionary operation.
For each of the following applications, indicate the most appropriate data structure: a. answering telephone calls in the order of their known priorities b. sending backlog orders to customers in the order they have been received c.  implementing a calculator for computing simple arithmetical expressions
Anagram checking: Design an algorithm for checking whether two given words are anagrams, i.e., whether one word can be obtained by permuting the letters of the other. For example, the words tea and eat are anagrams.
For each of the following algorithms, indicate (i) a natural size metric for its inputs, (ii) its basic operation, and (iii) whether the basic operation count can be different for inputs of the same size: a.  computing the sum of n numbers b. computing n! c.  finding the largest element in a list of n numbers d. Euclid's algorithm e.  sieve of Eratosthenes f.  pen-and-pencil algorithm for multiplying two n-digit decimal integers
a.  Consider the definition-based algorithm for adding two n × n matrices. What is its basic operation? How many times is it performed as a function of the matrix order n? As a function of the total number of elements in the input matrices?
Consider a variation of sequential search that scans a list to return the number of occurrences of a given search key in the list. Does its efficiency differ from the efficiency of classic sequential search?
a. Glove selection There are 22 gloves in a drawer: 5 pairs of red gloves, 4 pairs of yellow, and 2 pairs of green. You select the gloves in the dark and can check them only after a selection has been made. What is the smallest number of gloves you need to select to have at least one matching pair in the best case? In the worst case?
b.  Missing socks   Imagine that after washing 5 distinct pairs of socks, you discover that two socks are missing. Of course, you would like to have the largest number of complete pairs remaining. Thus, you are left with 4 complete pairs in the best-case scenario and with 3 complete pairs in the worst case. Assuming that the probability of disappearance for each of the 10 socks is the same, find the probability of the best-case scenario; the probability of the worst-case scenario; the number of pairs you should expect in the average case.
d. Explain why, within the accepted analysis framework, it does not matter whether we use binary or decimal digits in measuring n's size.
Suggest how any sorting algorithm can be augmented in a way to make the best-case count of its key comparisons equal to just n 1 (n is a list's size, of course). Do you think it would be a worthwhile addition to any sorting algorithm?
Gaussian elimination, the classic algorithm for solving systems of n linear equations   in n  unknowns,   requires  about   1  n3  multiplications,  which  is  the algorithm's basic operation. How much longer should you expect Gaussian elimination to work on a system of 1000 equations versus a system of 500 equations?
Gaussian elimination, the classic algorithm for solving systems of n linear equations   in n  unknowns,   requires  about   1  n3  multiplications,  which  is  the algorithm's basic operation. You are considering buying a computer that is 1000 times faster than the one you currently have. By what factor will the faster computer increase the sizes of systems solvable in the same amount of time as on the old computer?
For each of the following functions, indicate how much the function's value will  change   if  its  argument  is increased fourfold. a. log2  nb.  n c. n  d.  n2 e.  n3  f.  2n
For each of the following pairs of functions, indicate whether the first function of each of the following pairs has a lower, same, or higher order of growth (to within a constant multiple) than the second function. a. n(n + 1) and 2000n2  b.  100n2 and 0.01n3 c. log2 n and ln n  d.  log22 n and log2 n2 e.  2n-1 and 2n f. (n 1)! and n!
Invention of chess: According to a well-known legend, the game of chess was invented many centuries ago in northwestern India by a certain sage. When he took his invention to his king, the king liked the game so much that he offered the inventor any reward he wanted. The inventor asked for some grain to be obtained as follows: just a single grain of wheat was to be placed on the first square of the chessboard, two on the second, four on the third, eight on the fourth, and so on, until all 64 squares had been filled. If it took just 1 second to count each grain, how long would it take to count all the grain due to him?
The inventor asked for some grain to be obtained as follows: just a single grain of wheat was to be placed on the first square of the chessboard, two on the second, four on the third, eight on the fourth, and so on, until all 64 squares had been filled. If it took just 1 second to count each grain. How long would it take if instead of doubling the number of grains for each square of the chessboard, the inventor asked for adding two grains?
a.  Table 2.1 contains values of several functions that often arise in the analysis of algorithms. These values certainly suggest that the functions log n,  n,  n log2 n,n2,  n3,  2n,  n! are listed in increasing order of their order of growth. Do these values prove this fact with mathematical certainty?
List the following functions according to their order of growth from the lowest to the highest: (n 2)!,5 lg(n + 100)10,  22n,   0.001n4 + 3n3 + 1,   ln2 n,  3 n,  3n.
a.  Prove that every polynomial of degree k, p(n) = aknk + ak-1nk-1 + . . . + a0 with ak > 0, belongs to(nk).
b.  Prove that exponential functions an have different orders of growth for different values of base a > 0. Prove the following assertions by using the definitions of the notations involved, or disprove them by giving a specific counterexample.
We mentioned in this section that one can check whether all elements of an array are distinct by a two-part algorithm based on the array's presorting. If the presorting is done by an algorithm with a time efficiency in(n log n), what will be a time-efficiency class of the entire algorithm?
We mentioned in this section that one can check whether all elements of an array are distinct by a two-part algorithm based on the array's presorting. If the sorting algorithm used for presorting needs an extra array of size n, what will be the space-efficiency class of the entire algorithm?
The range of a finite nonempty set of n real numbers S is defined as the difference between the largest and smallest elements of S. For each representation of S given below, describe in English an algorithm to compute the range. Indicate the time efficiency classes of these algorithms using the most appropriate notation (O, , or  ). a.  An unsorted array b. A sorted array c.  A sorted singly linked list d. A binary search tree
Lighter or heavier? You have n > 2 identical-looking coins and a two-pan balance scale with no weights. One of the coins is a fake, but you do not know whether it is lighter or heavier than the genuine coins, which all weigh the same. Design a  (1) algorithm to determine whether the fake coin is lighter or heavier than the others.
Door in a wall  You are facing a wall that stretches infinitely in both directions. There is a door in the wall, but you know neither how far away nor in which direction. You can see the door only when you are right next to it. Design an algorithm that enables you to reach the door by walking at most O(n) steps where n is the (unknown to you) number of steps between your initial position and the door.
Compute the following sums. a.  1 + 3 + 5 + 7 + . . . + 999 b.  2 + 4 + 8 + 16 + . . . + 1024 c.  n+11  d.  n+1  ie.   n-1  i(i+ 1) i=3   i=3i=0 f.  n  3j  +1 g.  n   n ij  h.   n1/ i(i   +   1) j =1  i=1 j =1   i=1
Find the order of growth of the following sums. Use the(g(n)) notation with the simplest function g(n) possible. a.  ni =-01(i 2 +1)2  b.  n-1   lg   i2 i=2ij-=10(i + j ) n-1 c.  in=1(i + 1)2i-1   d. i=0
The sample variance of n measurements x1, . . . , xn can be computed as either in=1(xi x¯)2n  xi where x¯ = i=1 n-1   n or n xi2    (  nxi  )2/  n i=1   i=1  . n-1 Find and compare the number of divisions, multiplications, and additions/ subtractions (additions and subtractions are usually bunched together) that are required for computing the variance according to each of these formulas.
Consider the following algorithm. <Algorithm> 1 What does this algorithm compute?
Consider the following algorithm. <Algorithm> 1 What is its basic operation?
Consider the following algorithm. <Algorithm> 1 How many times is the basic operation executed?
Consider the following algorithm. <Algorithm> 1 What is the efficiency class of this algorithm?
Consider the following algorithm. <Algorithm> 1 Suggest an improvement, or a better algorithm altogether, and indicate its efficiency class.
Consider the following algorithm. <Algorithm> 2 What does this algorithm compute?
Consider the following algorithm. <Algorithm> 2 What is its basic operation?
Consider the following algorithm. <Algorithm> 2 How many times is the basic operation executed?
Consider the following algorithm. <Algorithm> 2 What is the efficiency class of this algorithm?
Consider the following algorithm. <Algorithm> 2 Suggest an improvement, or a better algorithm altogether, and indicate its efficiency class.
Consider the following version of an important algorithm that we will study later in the book. <Algorithm> Find the time efficiency class of this algorithm.
Consider the following version of an important algorithm that we will study later in the book. <Algorithm> What glaring inefficiency does this pseudocode contain and how can it be eliminated to speed the algorithm up?
von Neumann's neighborhood: Consider the algorithm that starts with a single square and on each of its n iterations adds new squares all around the outside. How many one-by-one squares are there after n iterations?
Page numbering: Find the total number of decimal digits needed for numbering pages in a book of 1000 pages. Assume that the pages are numbered consecutively starting with
Solve the following recurrence relations. a.  x(n) = x(n 1) + 5   for n > 1,x(1) = 0 b. x(n) = 3x(n 1) for n > 1,  x(1) = 4 c.  x(n) = x(n 1) + n for n > 0,  x(0) = 0 d.  x(n) = x(n/2) + n for n > 1,   x(1) = 1 (solve for n = 2k) e.  x(n) = x(n/3) + 1 for n > 1,   x(1) = 1 (solve for n = 3k)
Set up and solve a recurrence relation for the number of calls made by F (n), the recursive algorithm for computing n!.
Consider the following recursive algorithm for computing the sum of the first n cubes: S(n) = 13 + 23 + . . . + n3. <Algorithm> Set up and solve a recurrence relation for the number of times the algorithm's basic operation is executed.
Consider the following recursive algorithm for computing the sum of the first n cubes: S(n) = 13 + 23 + . . . + n3. <Algorithm> How does this algorithm compare with the straightforward nonrecursive algorithm for computing this sum?
Consider the following recursive algorithm. <Algorithm> Set up a recurrence relation for this function's values and solve it to determine what this algorithm computes.
Consider the following recursive algorithm. <Algorithm> Set up a recurrence relation for the number of multiplications made by this algorithm and solve it.
Consider the following recursive algorithm. <Algorithm> Set up a recurrence relation for the number of additions/subtractions made by this algorithm and solve it.
Tower of Hanoi: In the original version of the Tower of Hanoi puzzle, as it was published in the 1890s by E´ douard Lucas, a French mathematician, the world will end after 64 disks have been moved from a mystical Tower of Brahma. Estimate the number of years it will take if monks could move one disk per minute. (Assume that monks do not eat, sleep, or die.)
Tower of Hanoi: In the original version of the Tower of Hanoi puzzle, as it was published in the 1890s by E´ douard Lucas, a French mathematician, the world will end after 64 disks have been moved from a mystical Tower of Brahma. How many moves are made by the ith largest disk (1  i  n) in this algorithm?
Find a nonrecursive algorithm for the Tower of Hanoi puzzle and implement it in the language of your choice.
Restricted Tower of Hanoi: Consider the version of the Tower of Hanoi puzzle in which n disks have to be moved from peg A to peg C using peg B so that any move should either place a disk on peg B or move a disk from that peg. (Of course, the prohibition of placing a larger disk on top of a smaller one remains in place, too.) Design a recursive algorithm for this problem and find the number of moves made by it.
Prove that the exact number of additions made by the recursive algorithm BinRec(n) for an arbitrary positive decimal integer n is log2 n .
Consider the following recursive algorithm. <Algorithm> What does this algorithm compute?
Consider the following recursive algorithm. <Algorithm> Set up a recurrence relation for the algorithm's basic operation count and solve it.
Consider the following algorithm to check whether a graph defined by its adjacency matrix is complete. <Algorithm> What is the algorithm's efficiency class in the worst case?
The determinant of an n × n matrix a0 0   ...  a0 n-1    A =  a.. 0...  a1 n... -1, an-1 0...  an-1 n-1 denoted det A, can be defined as a00 for n = 1 and, for n > 1, by the recursive formula n-1 det A = sj a0 j det Aj , j =0 where sj is +1 if j is even and -1 if j is odd, a0 j is the element in row 0 and column j , and Aj is the (n 1) × (n 1) matrix obtained from matrix A by deleting its row 0 and column j. Set up a recurrence relation for the number of multiplications made by the algorithm implementing this recursive definition.
The determinant of an n × n matrix a0 0   ...  a0 n-1    A =  a.. 0...  a1 n... -1, an-1 0...  an-1 n-1 denoted det A, can be defined as a00 for n = 1 and, for n > 1, by the recursive formula n-1 det A = sj a0 j det Aj , j =0 where sj is +1 if j is even and -1 if j is odd, a0 j is the element in row 0 and column j , and Aj is the (n 1) × (n 1) matrix obtained from matrix A by deleting its row 0 and column j. What can you say about the solution's order of growth as compared to n!?
von Neumann's neighborhood revisited: Find the number of cells in the von Neumann neighborhood of range n (Problem 12 in Exercises 2.3) by setting up and solving a recurrence relation.
Frying hamburgers: There are n hamburgers to be fried on a small grill that can hold only two hamburgers at a time. Each hamburger has to be fried on both sides; frying one side of a hamburger takes 1 minute, regardless of whether one or two hamburgers are fried at the same time. Consider the following recursive algorithm for executing this task in the minimum amount of time. If n  2, fry the hamburger or the two hamburgers together on each side. If n > 2, fry any two hamburgers together on each side and then apply the same procedure recursively to the remaining n 2 hamburgers. Set up and solve the recurrence for the amount of time this algorithm needs to fry n hamburgers.
Frying hamburgers: There are n hamburgers to be fried on a small grill that can hold only two hamburgers at a time. Each hamburger has to be fried on both sides; frying one side of a hamburger takes 1 minute, regardless of whether one or two hamburgers are fried at the same time. Consider the following recursive algorithm for executing this task in the minimum amount of time. If n  2, fry the hamburger or the two hamburgers together on each side. If n > 2, fry any two hamburgers together on each side and then apply the same procedure recursively to the remaining n 2 hamburgers. Explain why this algorithm does not fry the hamburgers in the minimum amount of time for all n > 0.
Frying hamburgers: There are n hamburgers to be fried on a small grill that can hold only two hamburgers at a time. Each hamburger has to be fried on both sides; frying one side of a hamburger takes 1 minute, regardless of whether one or two hamburgers are fried at the same time. Consider the following recursive algorithm for executing this task in the minimum amount of time. If n  2, fry the hamburger or the two hamburgers together on each side. If n > 2, fry any two hamburgers together on each side and then apply the same procedure recursively to the remaining n 2 hamburgers. Give a correct recursive algorithm that executes the task in the minimum amount of time.
Celebrity problem: A celebrity among a group of n people is a person who knows nobody but is known by everybody else. The task is to identify a celebrity by only asking questions to people of the form - Do you know him/her? Design an efficient algorithm to identify a celebrity or determine that the group has no such person.
Celebrity problem: A celebrity among a group of n people is a person who knows nobody but is known by everybody else. The task is to identify a celebrity by only asking questions to people of the form - Do you know him/her? How many questions do you need to ask in the worst case?
Find a Web site dedicated to applications of the Fibonacci numbers and study it.
Fibonacci's rabbits problem:  A man put a pair of rabbits in a place surrounded by a wall. How many pairs of rabbits will be there in a year if the initial pair of rabbits (male and female) are newborn and all rabbit pairs are not fertile during their first month of life but thereafter give birth to one new male/female pair at the end of every month?
Climbing stairs: Find the number of different ways to climb an n-stair staircase if each step is either one or two stairs. For example, a 3-stair staircase can be climbed three ways: 1-1-1, 1-2, and 2
How many even numbers are there among the first n Fibonacci numbers, i.e., among the numbers F (0), F (1), . . . , F (n 1)?
Give a closed-form formula to find the nth Fibonacci number valid for every n > 0.
The maximum values of the Java primitive types int and long are 231 1 and 263 1, respectively. Find the smallest n for which the nth Fibonacci number is not going to fit in a memory allocated for a. the type int.   b.  the type long.
Consider the recursive definition-based algorithm for computing the nth Fibonacci number F (n). Let C(n) and Z(n) be the number of times F (1) and F (0) are computed, respectively. Prove that a. C(n) = F (n).   b. Z(n) = F (n 1).
Improve algorithm F ib of the text so that it requires only  (1) space.
Prove the equality F (n 1) F (n) 0  1  n F (n)  F (n + 1)  =  1  1 for n
How many modulo divisions are made by Euclid's algorithm on two consecutive Fibonacci numbers F (n) and F (n 1) as the algorithm's input?
Dissecting a Fibonacci rectangle: Given a rectangle whose sides are two consecutive Fibonacci numbers, design an algorithm to dissect it into squares with no more than two squares being the same size.
What is the time efficiency class of your algorithm?
In the language of your choice, implement two algorithms for computing the last five digits of the nth Fibonacci number that are based on (a) the recursive definition-based algorithm F(n); (b) the iterative definition-based algorithm Fib(n).
Perform an experiment to find the largest value of n for which your programs run under 1 minute on your computer.
Consider the following well-known sorting algorithm, which is studied later in the book, with a counter inserted to count the number of key comparisons. <Algorithm> Is the comparison counter inserted in the right place?
Consider the following well-known sorting algorithm, which is studied later in the book, with a counter inserted to count the number of key comparisons. <Algorithm> If you believe that the comparison counter is inserted in the right place, prove it; if you believe it is not, make an appropriate correction.
Hypothesize a likely efficiency class of an algorithm based on the following empirical observations of its basic operation's count: size  10002000 3000   4000   5000 60007000  8000  9000 10000 count 11,966  24,303  39,992  53,010  67,272  78,692   91,274113,063  129,799  140,538
What scale transformation will make a logarithmic scatterplot look like a linear one?
How can one distinguish a scatterplot for an algorithm in   (lg lg n) from a scatterplot for an algorithm in(lg n)?
Find empirically the largest number of divisions made by Euclid's algorithm for computing gcd(m, n) for 1 n  m  100.
For each positive integer k, find empirically the smallest pair of integers 1 n  m  100 for which Euclid's algorithm needs to make k divisions in order to find gcd(m, n).
The average-case efficiency of Euclid's algorithm on inputs of size n can be measured by the average number of divisions Davg(n) made by the algorithm in computing gcd(n, 1), gcd(n, 2), . . . , gcd(n, n). For example, Davg(5) =  1 (1  +  2  +  3  +  2  +  1)  =  8. Produce a scatterplot of Davg(n) and indicate the algorithm's likely averagecase efficiency class.
Run an experiment to ascertain the efficiency class of the sieve of Eratosthenes (see Section 1).
Run a timing experiment for the three algorithms for computing gcd(m, n) presented in Section a.
Give an example of an algorithm that should not be considered an application of the brute-force approach.
Give an example of a problem that cannot be solved by a brute-force algorithm.
What is the time efficiency of the brute-force algorithm for computing an as a function of n? As a function of the number of bits in the binary representation of n?
If you are to compute an mod m where a > 1 and n is a large positive integer, how would you circumvent the problem of a very large magnitude of an?
For each of the algorithms in Problems 4, 5, and 6 of Exercises 2.3, tell whether or not the algorithm is based on the brute-force approach.
Design a brute-force algorithm for computing the value of a polynomial p(x) = anxn + an-1xn-1 + . . . + a1x + a0 at a given point x0 and determine its worst-case efficiency class.
A network topology specifies how computers, printers, and other devices are connected over a network. The figure below illustrates three common topologies of networks: the ring, the star, and the fully connected mesh. ring star  fully connected mesh You are given a boolean matrix A[0..n 1, 0..n 1], where n > 3, which is supposed to be the adjacency matrix of a graph modeling a network with one of these topologies. Your task is to determine which of these three topologies, if any, the matrix represents. Design a brute-force algorithm for this task and indicate its time efficiency class.
Tetromino tilings: Tetrominoes are tiles made of four 1 × 1 squares. There are five types of tetrominoes shown below: straight tetromino square tetromino  L-tetromino   T-tetromino  Z-tetromino. Is it possible to tile--i.e., cover exactly without overlaps--an 8 × 8 chessboard with a. straight tetrominoes?  b. square tetrominoes? c. L-tetrominoes? d. T-tetrominoes? e. Z-tetrominoes?
A stack of fake coins: There are n stacks of n identical-looking coins. All of the coins in one of these stacks are counterfeit, while all the coins in the other stacks are genuine. Every genuine coin weighs 10 grams; every fake weighs 11 grams. You have an analytical scale that can determine the exact weight of any number of coins. Devise a brute-force algorithm to identify the stack with the fake coins and determine its worst-case efficiency class
A stack of fake coins: There are n stacks of n identical-looking coins. All of the coins in one of these stacks are counterfeit, while all the coins in the other stacks are genuine. Every genuine coin weighs 10 grams; every fake weighs 11 grams. You have an analytical scale that can determine the exact weight of any number of coins. What is the minimum number of weighings needed to identify the stack with the fake coins?
Sort the list E, X, A, M, P , L, E in alphabetical order by selection sort.
Is selection sort stable? (The definition of a stable sorting algorithm was given in Section 3.)
Is it possible to implement selection sort for linked lists with the same  (n2) efficiency as the array version?
Sort the list E, X, A, M, P , L, E in alphabetical order by bubble sort.
Prove that if bubble sort makes no exchanges on its pass through a list, the list is sorted and the algorithm can be stopped.
If bubble sort makes no exchanges on its pass through a list, the list is sorted and the algorithm can be stopped. Write pseudocode of the method that incorporates this improvement.
If bubble sort makes no exchanges on its pass through a list, the list is sorted and the algorithm can be stopped. Prove that the worst-case efficiency of the improved version is quadratic.
Is bubble sort stable?
Alternating disks:  You have a row of 2n disks of two colors, n dark and n light. They alternate: dark, light, dark, light, and so on. You want to get all the dark disks to the right-hand end, and all the light disks to the left-hand end. The only moves you are allowed to make are those that interchange the positions of two neighboring disks. Design an algorithm for solving this puzzle and determine the number of moves it takes.
Find the number of comparisons made by the sentinel version of sequential search a.  in the worst case. b. in the average case if the probability of a successful search is p (0  p  1)
As shown in Section 2.1, the average number of key comparisons made by sequential search (without a sentinel, under standard assumptions about its inputs) is given by the formula Cavg(n)  =  p(n +  1)  +  n(1   p), 2 where p is the probability of a successful search. Determine, for a fixed n, the values of p (0  p  1) for which this formula yields the maximum value of Cavg(n) and the minimum value of Cavg(n).
Gadget testing: A firm wants to determine the highest floor of its n-story headquarters from which a gadget can fall without breaking. The firm has two identical gadgets to experiment with. If one of them gets broken, it cannot be repaired, and the experiment will have to be completed with the remaining gadget. Design an algorithm in the best efficiency class you can to solve this problem.
Determine the number of character comparisons made by the brute-force algorithm in searching for the pattern GANDHI in the text THERE_IS_MORE_TO_LIFE_THAN_INCREASING_ITS_SPEED Assume that the length of the text--it is 47 characters long--is known before the search starts.
How many comparisons (both successful and unsuccessful) will be made by the brute-force algorithm in searching for each of the following patterns in the binary text of one thousand zeros? a. 00001b. 10000  c. 01010
Give an example of a text of length n and a pattern of length m that constitutes a worst-case input for the brute-force string-matching algorithm.
Exactly how many character comparisons will be made for worst case input for brute-force string matching algorithm?
In solving the string-matching problem, would there be any advantage in comparing pattern and text characters right-to-left instead of left-to-right?
Consider the problem of counting, in a given text, the number of substrings that start with an A and end with a B. For example, there are four such substrings in CABAAXBYA. Design a brute-force  algorithm  for this problem and determine its efficiency class.
Write a visualization program for the brute-force string-matching algorithm.
Word Find: A popular diversion in the United States, word find (or word search) puzzles ask the player to find each of a given set of words in a square table filled with single letters. A word can read horizontally (left or right), vertically (up or down), or along a 45 degree diagonal (in any of the four directions) formed by consecutively adjacent cells of the table; it may wrap around the table's boundaries, but it must read in the same direction with no zigzagging. The same cell of the table may be used in different words, but, in a given word, the same cell may be used no more than once. Write a computer program for solving this puzzle.
Battleship game: Write a program based on a version of brute-force pattern matching for playing the game Battleship on the computer. The rules of the game are as follows. There are two opponents in the game (in this case, a human player and the computer). The game is played on two identical boards (10 × 10 tables of squares) on which each opponent places his or her ships, not seen by the opponent. Each player has five ships, each of which occupies a certain number of squares on the board: a destroyer (two squares), a submarine (three squares), a cruiser (three squares), a battleship (four squares), and an aircraft carrier (five squares). Each ship is placed either horizontally or vertically, with no two ships touching each other. The game is played by the opponents taking turns shooting at each other's ships. The result of every shot is displayed as either a hit or a miss. In case of a hit, the player gets to go again and keeps playing until missing. The goal is to sink all the opponent's ships before the opponent succeeds in doing it first. To sink a ship, all squares occupied by the ship must be hit.
Assuming that sqrt takes about 10 times longer than each of the other operations in the innermost loop of Brute Force Closest Points, which are assumed to take the same amount of time, estimate how much faster the algorithm will run after the improvement discussed in Section 3.3.
Can you design a more efficient algorithm than the one based on the brute-force strategy to solve the closest-pair problem for n points x1, x2, . . . , xn on the real line?
Let x1 < x2 < . . . < xn be real numbers representing coordinates of n villages located along a straight road. A post office needs to be built in one of these villages. Design an efficient algorithm to find the post-office location minimizing the average distance between the villages and the post office. For the sake of simplicity, we assume here that no three points of a given set lie on the same line.
Let x1 < x2 < . . . < xn be real numbers representing coordinates of n villages located along a straight road. A post office needs to be built in one of these villages. Design an efficient algorithm to find the post-office location minimizing the maximum distance from a village to the post office. For the sake of simplicity, we assume here that no three points of a given set lie on the same line.
There are several alternative ways to define a distance between two points p1(x1, y1) and p2(x2, y2) in the Cartesian plane. In particular, the Manhattan distance is defined as dM(p1, p2) = |x1 x2| + |y1 y2|. Prove that dM satisfies the following axioms, which every distance function must satisfy: i.dM(p1, p2)  0 for any two points p1 and p2, and dM(p1, p2) = 0 if and only if p1 = p2 ii.   dM(p1, p2) = dM(p2, p1) iii.  dM(p1, p2)  dM(p1, p3) + dM(p3, p2) for any p1, p2, and p3 b.  Sketch all the points in the Cartesian plane whose Manhattan distance to the origin (0, 0) is equal to  Do the same for the Euclidean distance.
True or false: A solution to the closest-pair problem does not depend on which of the two metrics--dE (Euclidean) or dM (Manhattan)--is used?
The Hamming distance between two strings of equal length is defined as the number of positions at which the corresponding symbols are different. It is named after Richard Hamming, a prominent American scientist and engineer, who introduced it in his seminal paper on error-detecting and error-correcting codes. Does the Hamming distance satisfy the three axioms of a distance metric listed in Problem 4? b.  What is the time efficiency class of the brute-force algorithm for the closest pair problem if the points in question are strings of m symbols long and the distance between two of them is measured by the Hamming distance?
Odd pie fight: There are n  3 people positioned on a field (Euclidean plane) so that each has a unique nearest neighbor. Each person has a cream pie. At a signal, everybody hurls his or her pie at the nearest neighbor. Assuming that n is odd and that nobody can miss his or her target, true or false: There always remains at least one person not hit by a pie.
The closest-pair problem can be posed in the k-dimensional space, in which the Euclidean distance between two points p (x1, . . . , xk) and p (x1 , . . . , xk ) is defined as d(p , p ) =  k    )2. s=1(xs xs What is the time-efficiency class of the brute-force algorithm for the k dimensional closest-pair problem?
Find the convex hulls of the following sets and identify their extreme points (if they have any): a.  a line segment b. a square c.  the boundary of a square d. a straight line
Design a linear-time algorithm to determine two extreme points of the convex hull of a given set of n > 1 points in the plane.
What modification needs to be made in the brute-force algorithm for the convex-hull problem to handle more than two points on the same straight line?
Write a program implementing the brute-force algorithm for the convex-hull problem.
Consider the following small instance of the linear programming problem: maximize3x + 5y subject to   x+  y4 x + 3y  6 x  0, y  0. a.  Sketch, in the Cartesian plane, the problem's feasible region, defined as the set of points satisfying all the problem's constraints. b.  Identify the region's extreme points.
Consider the following small instance of the linear programming problem: maximize3x + 5y subject to   x+  y4 x + 3y  6 x  0, y  0. Solve this optimization problem by using the following theorem: A linear programming problem with a nonempty bounded feasible region always has a solution, which can be found at one of the extreme points of its feasible region.
Assuming that each tour can be generated in constant time, what will be the efficiency class of the exhaustive-search algorithm outlined in the text for the traveling salesman problem?
Assuming that each tour can be generated in constant time, If the exhaustive-search algorithm outlined in the text for the traveling salesman problem is programmed on a computer that makes ten billion additions per second, estimate the maximum number of cities for which the problem can be solved in i. 1 hour. ii. 24 hours.   iii. 1 year. iv. 1 century.
Outline an exhaustive-search algorithm for the Hamiltonian circuit problem.
Outline an algorithm to determine whether a connected graph represented by its adjacency matrix has an Eulerian circuit.
What is the efficiency class of your algorithm?
Complete the application of exhaustive search to the instance of the assignment problem started in the text.
Give an example of the assignment problem whose optimal solution does not include the smallest element of its cost matrix.
Consider the partition problem: given n positive integers, partition them into two disjoint subsets with the same sum of their elements. (Of course, the problem does not always have a solution.)
Design an exhaustive-search algorithm for this problem. Try to minimize the number of subsets the algorithm needs to generate.
Consider the clique problem: given a graph G and a positive integer k, determine whether the graph contains a clique of size k, i.e., a complete subgraph of k vertices.
Design an exhaustive-search algorithm for this problem.
Explain how exhaustive search can be applied to the sorting problem and determine the efficiency class of such an algorithm.
Eight-queens problem: Consider the classic puzzle of placing eight queens on an 8 × 8 chessboard so that no two queens are in the same row or in the same column or on the same diagonal. How many different positions are there so that a.  no two queens are on the same square? b. no two queens are in the same row? c.  no two queens are in the same row or in the same column?
Eight-queens problem: Consider the classic puzzle of placing eight queens on an 8 × 8 chessboard so that no two queens are in the same row or in the same column or on the same diagonal. Estimate how long it would take to find all the solutions to the problem by exhaustive search based on each of these approaches on a computer capable of checking 10 billion positions per second.
Magic squares: A magic square of order n is an arrangement of the integers from 1 to n2 in an n × n matrix, with each number occurring exactly once, so that each row, each column, and each main diagonal has the same sum. Prove that if a magic square of order n exists, the sum in question must be equal to n(n2 + 1)/2.
Magic squares: A magic square of order n is an arrangement of the integers from 1 to n2 in an n × n matrix, with each number occurring exactly once, so that each row, each column, and each main diagonal has the same sum. Design an exhaustive-search algorithm for generating all magic squares of order n.
Consider the following graph. f bcg d   a e a. Write down the adjacency matrix and adjacency lists specifying this graph. (Assume that the matrix rows and columns and vertices in the adjacency lists follow in the alphabetical order of the vertex labels.)
Consider the following graph. f bcg d   a e a. Starting at vertex a and resolving ties by the vertex alphabetical order, traverse the graph by depth-first search and construct the corresponding depth-first search tree.
Consider the following graph. f bcg d   a e a.  Give the order in which the vertices were reached for the first time (pushed onto the traversal stack) and the order in which the vertices became dead ends (popped off the stack) on using depth-first search.
If we define sparse graphs as graphs for which |E|  O(|V |), which implementation of DFS will have a better time efficiency for such graphs, the one that uses the adjacency matrix or the one that uses the adjacency lists?
Let G be a graph with n vertices and m edges. True or false: All its DFS forests (for traversals starting at different vertices) will have the same number of trees?
Let G be a graph with n vertices and m edges. True or false: All its DFS forests will have the same number of tree edges and the same number of back edges?
Traverse the graph of Problem 1 by breadth-first search and construct the corresponding breadth-first search tree. Start the traversal at vertex a and resolve ties by the vertex alphabetical order.
Prove that a cross edge in a BFS tree of an undirected graph can connect vertices only on either the same level or on two adjacent levels of a BFS tree.
Explain how one can check a graph's acyclicity by using breadth-first search.
Does either of the two traversals--DFS or BFS--always find a cycle in a graph faster than the other? If you answer yes, indicate which of them is better and explain why it is the case; if you answer no, give two examples supporting your answer.
Explain how one can identify connected components of a graph by using a. a depth-first search. b. a breadth-first search.
A graph is said to be bipartite if all its vertices can be partitioned into two disjoint subsets X and Y so that every edge connects a vertex in X with a vertex in Y. (One can also say that a graph is bipartite if its vertices can be colored in two colors so that every edge has its vertices colored in different colors; such graphs are also called 2-colorable.) Design a DFS-based algorithm for checking whether a graph is bipartite.
A graph is said to be bipartite if all its vertices can be partitioned into two disjoint subsets X and Y so that every edge connects a vertex in X with a vertex in Y. (One can also say that a graph is bipartite if its vertices can be colored in two colors so that every edge has its vertices colored in different colors; such graphs are also called 2-colorable.) Design a BFS-based algorithm for checking whether a graph is bipartite.
Write a program that, for a given graph, outputs: a.  vertices of each connected component b. its cycle or a message that the graph is acyclic
One can model a maze by having a vertex for a starting point, a finishing point, dead ends, and all the points in the maze where more than one path can be taken, and then connecting the vertices according to the paths in the maze. Construct such a graph for the following maze.
One can model a maze by having a vertex for a starting point, a finishing point, dead ends, and all the points in the maze where more than one path can be taken, and then connecting the vertices according to the paths in the maze. Which traversal--DFS or BFS--would you use if you found yourself in a maze and why?
Three Jugs: Sime´ on Denis Poisson, a famous French mathematician and physicist, is said to have become interested in mathematics after encountering some version of the following old puzzle. Given an 8-pint jug full of water and two empty jugs of 5and 3-pint capacity, get exactly 4 pints of water in one of the jugs by completely filling up and/or emptying jugs into others. Solve this puzzle by using breadth-first search.
Ferrying soldiers: A detachment of n soldiers must cross a wide and deep river with no bridge in sight. They notice two 12-year-old boys playing in a rowboat by the shore. The boat is so tiny, however, that it can only hold two boys or one soldier. How can the soldiers get across the river and leave the boys in joint possession of the boat? How many times need the boat pass from shore to shore?
Alternating glasses: There are 2n glasses standing next to each other in a row, the first n of them filled with a soda drink and the remaining n glasses empty. Make the glasses alternate in a filled-empty-filled-empty pattern in the minimum number of glass moves.
Alternating glasses: There are 2n glasses standing next to each other in a row. Make the glasses alternate in a filled-empty-filled-empty pattern in the minimum number of glass moves. Solve if the glasses are initially in a random order.
Marking cells: Design an algorithm for the following task. For any even n, mark n cells on an infinite sheet of graph paper so that each marked cell has an odd number of marked neighbors. Two cells are considered neighbors if they are next to each other either horizontally or vertically but not diagonally. The marked cells must form a contiguous region, i.e., a region in which there is a path between any pair of marked cells that goes through a sequence of marked neighbors.
Design a decrease-by-one algorithm for generating the power set of a set of n elements. (The power set of a set S is the set of all the subsets of S, including the empty set and S itself.)
Consider the following algorithm to check connectivity of a graph defined by its adjacency matrix. <Algorithm> Does this algorithm work correctly for every undirected graph with n > 0 vertices? If you answer yes, indicate the algorithm's efficiency class in the worst case; if you answer no, explain why.
Team ordering: You have the results of a completed round-robin tournament in which n teams played each other once. Each game ended either with a victory for one of the teams or with a tie. Design an algorithm that lists the teams in a sequence so that every team did not lose the game with the team listed immediately after it.
Apply insertion sort to sort the list E, X, A, M, P , L, E in alphabetical order.
What sentinel should be put before the first element of an array being sorted in order to avoid checking the in-bound condition j  0 on each iteration of the inner loop of insertion sort?
Is the sentinel version in the same efficiency class as the original version in the context of insertion sort?
Is it possible to implement insertion sort for sorting linked lists?
Will insertion sort for linked lists have the same O(n2) time efficiency as the array version?
Compare the text's implementation of insertion sort with the following version. <Algorithm> What is the time efficiency of this algorithm?
Let A[0..n 1] be an array of n sortable elements. (For simplicity, you may assume that all the elements are distinct.) A pair (A[i], A[j]) is called an inversion if i < j and A[i] > A[j]. What arrays of size n have the largest number of inversions and what is this number?
Let A[0..n 1] be an array of n sortable elements. (For simplicity, you may assume that all the elements are distinct.) A pair (A[i], A[j]) is called an inversion if i < j and A[i] > A[j ]. What arrays of size n have the smallest number of inversions and what is this number?
Show that the average-case number of key comparisons in insertion sort is given by the formula Cavg(n)n2.
Shellsort (more accurately Shell's sort) is an important sorting algorithm that works by applying insertion sort to each of several interleaving sublists of a given list. On each pass through the list, the sublists in question are formed by stepping through the list with an increment hi taken from some predefined decreasing sequence of step sizes, h1 > . . . > hi > . . . > 1, which must end with. Apply shellsort to the list S, H, E, L, L, S, O, R, T , I, S, U, S, E, F, U, L
Shellsort (more accurately Shell's sort) is an important sorting algorithm that works by applying insertion sort to each of several interleaving sublists of a given list. On each pass through the list, the sublists in question are formed by stepping through the list with an increment hi taken from some predefined decreasing sequence of step sizes, h1 > . . . > hi > . . . > 1, which must end with. Is shellsort a stable sorting algorithm?
Shellsort (more accurately Shell's sort) is an important sorting algorithm that works by applying insertion sort to each of several interleaving sublists of a given list. On each pass through the list, the sublists in question are formed by stepping through the list with an increment hi taken from some predefined decreasing sequence of step sizes, h1 > . . . > hi > . . . > 1, which must end with. Implement shellsort, straight insertion sort, selection sort, and bubble sort in the language of your choice
Compare the performance of shellsort, straight insertion sort, selection sort, and bubble sort on random arrays of sizes 10n for n = 2, 3, 4, 5, and 6 as well as on increasing and decreasing arrays of these sizes.
Apply the DFS-based algorithm to solve the topological sorting problem for the following digraphs
Prove that the topological sorting problem has a solution if and only if it is a dag.
For a digraph with n vertices, what is the largest number of distinct solutions the topological sorting problem can have?
What is the  time efficiency of  the DFS-based  algorithm   for  topological sorting?
How can one modify the DFS-based algorithm to avoid reversing the vertex ordering generated by DFS?
Can one use the order in which vertices are pushed onto the DFS stack (instead of the order they are popped off it) to solve the topological sorting problem?
Apply the source-removal algorithm to the digraphs of Problem 1 above.
Prove that a nonempty dag must have at least one source.
How would you find a source (or determine that such a vertex does not exist) in a digraph represented by its adjacency matrix?
What is the time efficiency of finding the source in a digraph represented by its adjacency matrix?
How would you find a source (or determine that such a vertex does not exist) in a digraph represented by its adjacency lists?
What is the time efficiency of finding the source in a digraph represented by its adjacency list?
Can you implement the source-removal algorithm for a digraph represented by its adjacency lists so that its running time is in O(|V | + |E|)?
Implement the two topological sorting algorithms in the language of your choice.
Run an experiment to compare the running times of the two topological sorting algorithms.
A digraph is called strongly connected if for any pair of two distinct vertices u and v there exists a directed path from u to v and a directed path from v to u. In general, a digraph's vertices can be partitioned into disjoint maximal subsets of vertices that are mutually accessible via directed paths; these subsets are called strongly connected components of the digraph. There are two DFS based algorithms for identifying strongly connected components. Here is the simpler one of the two: Step 1  Perform a DFS traversal of the digraph given and number its vertices in the order they become dead ends. Step 2  Reverse the directions of all the edges of the digraph. Step 3  Perform a DFS traversal of the new digraph by starting (and, if necessary, restarting) the traversal at the highest numbered vertex among still unvisited vertices. The strongly connected components are exactly the vertices of the DFS trees obtained during the last traversal. Apply this  algorithm to  the following  digraph  to  determine its strongly connected components: a  b c de f  g h b.
A digraph is called strongly connected if for any pair of two distinct vertices u and v there exists a directed path from u to v and a directed path from v to u. In general, a digraph's vertices can be partitioned into disjoint maximal subsets of vertices that are mutually accessible via directed paths; these subsets are called strongly connected components of the digraph. There are two DFS based algorithms for identifying strongly connected components. Here is the simpler one of the two: Step 1  Perform a DFS traversal of the digraph given and number its vertices in the order they become dead ends. Step 2  Reverse the directions of all the edges of the digraph. Step 3  Perform a DFS traversal of the new digraph by starting (and, if necessary, restarting) the traversal at the highest numbered vertex among still unvisited vertices. The strongly connected components are exactly the vertices of the DFS trees obtained during the last traversal. What is the time efficiency class of this algorithm?
How many strongly connected components does a dag have?
Spider's web: A spider sits at the bottom (point S) of its web, and a fly sits at the top (F). How many different ways can the spider reach the fly by moving along the web's lines in the directions indicated by the arrows?
Is it realistic to implement an algorithm that requires generating all permutations of a 25-element set on your computer?
Is it realistic to implement an algorithm that requires generating all the subsets of such a set?
Generate all permutations of {1, 2, 3, 4} by a.  the bottom-up minimal-change algorithm. b. the Johnson-Trotter algorithm. c.  the lexicographic-order algorithm.
Apply LexicographicPermute to multiset {1, 2, 2, 3}. Does it generate correctly all the permutations in lexicographic order?
Consider the following implementation of the algorithm for generating permutations discovered by B. Heap. <Algorithm> Trace the algorithm by hand for n = 2, 3, and 4.
Consider the following implementation of the algorithm for generating permutations discovered by B. Heap. <Algorithm> Prove the correctness of Heap's algorithm.
Consider the following implementation of the algorithm for generating permutations discovered by B. Heap. <Algorithm> What is the time efficiency of HeapPermute?
Generate all the subsets of a four-element set A = {a1, a2, a3, a4} by each of the two algorithms outlined in this section.
What simple trick would make the bit string­ based algorithm generate subsets in squashed order?
Write pseudocode for a recursive algorithm for generating all 2n bit strings of length n.
Write a nonrecursive algorithm for generating 2n bit strings of length n that implements bit strings as arrays and does not use binary additions.
Generate the binary reflexive Gray code of order 4.
Trace the following nonrecursive algorithm to generate the binary reflexive Gray code of order 4. Start with the n-bit string of all 0's. For i = 1, 2, . . . , 2n-1, generate the ith bit string by flipping bit b in the previous bit string, where b is the position of the least significant 1 in the binary representation of i.
Design a decrease-and-conquer algorithm for generating all combinations of k items chosen from n, i.e., all k-element subsets of a given n-element set.
Gray code and the Tower of Hanoi: Show that the disk moves made in the classic recursive algorithm for the Tower of Hanoi puzzle can be used for generating the binary reflected Gray code.
Gray code and the Tower of Hanoi: Show how the binary reflected Gray code can be used for solving the Tower of Hanoi puzzle.
Fair attraction: In olden days, one could encounter the following attraction at a fair. A light bulb was connected to several switches in such a way that it lighted up only when all the switches were closed. Each switch was controlled by a push button; pressing the button toggled the switch, but there was no way to know the state of the switch. The object was to turn the light bulb on. Design an algorithm to turn on the light bulb with the minimum number of button pushes needed in the worst case for n switches.
Cutting a stick: A stick n inches long needs to be cut into n 1-inch pieces. Outline an algorithm that performs this task with the minimum number of cuts if several pieces of the stick can be cut at the same time.
Design a decrease-by-half algorithm for computing log2 n  and determine its time efficiency.
What is the largest number of key comparisons made by binary search in searching for a key in the following array? 3  14   27  31  39  42  55  70   74  81  85  93  98
List all the keys of this array that will require the largest number of key comparisons when searched for by binary search.
Find the average number of key comparisons made by binary search in a successful search in this array. Assume that each key is searched for with the same probability.
Find the average number of key comparisons made by binary search in an unsuccessful search in this array. Assume that searches for keys in each of the 14 intervals formed by the array's elements are equally likely.
Estimate how many times faster an average successful search will be in a sorted array of one million elements if it is done by binary search versus sequential search.
The time efficiency of sequential search does not depend on whether a list is implemented as an array or as a linked list. Is it also true for searching a sorted list by binary search?
Design a version of binary search that uses only two-way comparisons such as  and =.
Implement your algorithm in the language of your choice and carefully debug it: such programs are notorious for being prone to bugs.
Analyze the time efficiency of the two-way comparison version designed in part a.
Picture guessing: A version of the popular problem-solving task involves presenting people with an array of 42 pictures--seven rows of six pictures each-and asking them to identify the target picture by asking questions that can be answered yes or no. Further, people are then required to identify the picture with as few questions as possible. Suggest the most efficient algorithm for this problem and indicate the largest number of questions that may be necessary.
Consider ternary search--the following algorithm for searching in a sorted array A[0..n 1]. If n = 1, simply compare the search key K with the single element of the array; otherwise, search recursively by comparing K with A[ n/3 ], and if K is larger, compare it with A[ 2n/3 ] to determine in which third of the array to continue the search. What design technique is this algorithm based on?
Consider ternary search--the following algorithm for searching in a sorted array A[0..n 1]. If n = 1, simply compare the search key K with the single element of the array; otherwise, search recursively by comparing K with A[ n/3 ], and if K is larger, compare it with A[ 2n/3 ] to determine in which third of the array to continue the search. Set up a recurrence for the number of key comparisons in the worst case. You may assume that n = 3k.
Consider ternary search--the following algorithm for searching in a sorted array A[0..n 1]. If n = 1, simply compare the search key K with the single element of the array; otherwise, search recursively by comparing K with A[ n/3 ], and if K is larger, compare it with A[ 2n/3 ] to determine in which third of the array to continue the search. Solve the recurrence for n = 3k.
Consider ternary search--the following algorithm for searching in a sorted array A[0..n 1]. If n = 1, simply compare the search key K with the single element of the array; otherwise, search recursively by comparing K with A[ n/3 ], and if K is larger, compare it with A[ 2n/3 ] to determine in which third of the array to continue the search. Compare this algorithm's efficiency with that of binary search.
An array A[0..n 2] contains n 1 integers from 1 to n in increasing order. (Thus one integer in this range is missing.) Design the most efficient algorithm you can to find the missing integer and indicate its time efficiency.
Write pseudocode for the divide-into-three algorithm for the fake-coin problem. Make sure that your algorithm handles properly all values of n, not only those that are multiples of 3.
Set up a recurrence relation for the number of weighings in the divide into three algorithm for the fake-coin problem and solve it for n = 3k.
For large values of n, about how many times faster is this algorithm than the one based on dividing coins into two piles? Your answer should not depend on n.
Apply the Russian peasant algorithm to compute 26 . 47.
From the standpoint of time efficiency, does it matter whether we multiply n by m or m by n by the Russian peasant algorithm?
Write pseudocode for the Russian peasant multiplication algorithm.
What is the time efficiency class of Russian peasant multiplication?
Find J (40)--the solution to the Josephus problem for n = 40.
Prove that the solution to the Josephus problem is 1 for every n that is a power of 2.
For the Josephus problem, compute J (n) for n = 1, 2, . . . , 15.
For the Josephus problem, discern a pattern in the solutions for the first fifteen values of n and prove its general validity.
For the Josephus problem, prove the validity of getting J (n) by a 1-bit cyclic shift left of the binary representation of n.
If we measure an instance size of computing the greatest common divisor of m and n by the size of the second number n, by how much can the size decrease after one iteration of Euclid's algorithm?
Prove that an instance size will always decrease at least by a factor of two after two successive iterations of Euclid's algorithm.
Apply quickselect to find the median of the list of numbers 9, 12, 5, 17, 20, 30,
Write pseudocode for a nonrecursive implementation of quickselect.
Derive the formula underlying interpolation search.
Give an example of the worst-case input for interpolation search and show that the algorithm is linear in the worst case.
Find the smallest value of n for which log2 log2 n + 1 is greater than 6
Determine which, if any, of the following assertions are true: i. log log n  o(log n)  ii. log log n(log n)  iii. log log n   (log n)
Outline an algorithm for finding the largest key in a binary search tree.
Would you classify your algorithm for finding the largest key in a binary search tree as a variable-size-decrease algorithm?
What is the time efficiency class of your algorithm for finding the largest key in a binary search tree in the worst case?
Outline an algorithm for deleting a key from a binary search tree.
Would you classify this algorithm as a variable-size-decrease algorithm?
What is the time efficiency class of your algorithm in the worst case?
Outline a variable-size-decrease algorithm for constructing an Eulerian circuit in a connected graph with all vertices of even degrees.
Mise`re one-pile Nim  Consider the so-called mise`re version of the one-pile Nim, in which the player taking the last chip loses the game. All the other conditions of the game remain the same, i.e., the pile contains n chips and on each move a player takes at least one but no more than m chips. Identify the winning and losing positions (for the player to move next) in this game.
Moldy chocolate: Two players take turns by breaking an m × n chocolate bar, which has one spoiled 1 × 1 square. Each break must be a single straight line cutting all the way across the bar along the boundaries between the squares. After each break, the player who broke the bar last eats the piece that does not contain the spoiled square.The player left with the spoiled square loses the game. Is it better to go first or second in this game?
Moldy chocolate: Two players take turns by breaking an m × n chocolate bar, which has one spoiled 1 × 1 square. Each break must be a single straight line cutting all the way across the bar along the boundaries between the squares. After each break, the player who broke the bar last eats the piece that does not contain the spoiled square.The player left with the spoiled square loses the game. Write an interactive program to play this game with the computer. Your program should make a winning move in a winning position and a random legitimate move in a losing position.
Flipping pancakes: There are n pancakes all of different sizes that are stacked on top of each other. You are allowed to slip a flipper under one of the pancakes and flip over the whole stack above the flipper. The purpose is to arrange pancakes according to their size with the biggest at the bottom. Design an algorithm for solving this puzzle.
You need to search for a given number in an n × n matrix in which every row and every column is sorted in increasing order. Can you design a O(n) algorithm for this problem?
Write pseudocode for a divide-and-conquer algorithm for finding the position of the largest element in an array of n numbers.
What will be your algorithm's output for arrays with several elements of the largest value?
Set up and solve a recurrence relation for the number of key comparisons made by your algorithm.
How does this algorithm compare with the brute-force algorithm for this problem?
Write pseudocode for a divide-and-conquer algorithm for finding values of both the largest and smallest elements in an array of n numbers.
Set up and solve (for n = 2k) a recurrence relation for the number of key comparisons made by your algorithm.
How does this algorithm compare with the brute-force algorithm for this problem?
Write pseudocode for a divide-and-conquer algorithm for the exponentiation problem of computing an where n is a positive integer.
Set up and solve a recurrence relation for the number of multiplications made by this algorithm.
Find the order of growth for solutions of the following recurrences. a.  T (n) = 4T (n/2) + n, T (1) = 1 b.  T (n) = 4T (n/2) + n2, T (1) = 1 c.  T (n) = 4T (n/2) + n3, T (1) = 1
Apply mergesort to sort the list E, X, A, M, P, L, E in alphabetical order.
Is mergesort a stable sorting algorithm?
Solve the recurrence relation for the number of key comparisons made by mergesort in the worst case. You may assume that n = 2k.
Set up a recurrence relation for the number of key comparisons made by mergesort on best-case inputs and solve it for n = 2k.
Set up a recurrence relation for the number of key moves made by the version of mergesort given in Section 5.
Does taking the number of key moves into account change the algorithm's efficiency class?
Let A[0..n 1] be an array of n real numbers. A pair (A[i], A[j ]) is said to be an inversion if these numbers are out of order, i.e., i < j but A[i] > A[j ]. Design an O(n log n) algorithm for counting the number of inversions.
Implement the bottom-up version of mergesort in the language of your choice.
Tromino puzzle  A tromino (more accurately, a right tromino) is an L-shaped tile formed by three 1 × 1 squares. The problem is to cover any 2n × 2n chessboard with a missing square with trominoes. Trominoes can be oriented in an arbitrary way, but they should cover all the squares of the board except the missing one exactly and with no overlaps. Design a divide-and-conquer algorithm for this problem.
Apply quicksort to sort the list E, X, A, M, P , L, E in alphabetical order.
Draw the tree of the recursive calls made during quicksort.
For the partitioning procedure outlined in this section: Prove that if the scanning indices stop while pointing to the same element, i.e., i = j, the value they are pointing to must be equal to p.
For the partitioning procedure outlined in this section: Prove that when the scanning indices stop, j cannot point to an element more than one position to the left of the one pointed to by i.
Give an example showing that quicksort is not a stable sorting algorithm.
Give an example of an array of n elements for which the sentinel mentioned in the text is actually needed. What should be its value?
Explain why a single sentinel suffices for any input.
For the version of quicksort given in this section: Are arrays made up of all equal elements the worst-case input, the bestcase input, or neither?
For the version of quicksort given in this section: Are strictly decreasing arrays the worst-case input, the best-case input, or neither?
For quicksort with the median-of-three pivot selection, are strictly increasing arrays the worst-case input, the best-case input, or neither? For quicksort with the median-of-three pivot selection, are strictly decreasing arrays the worst-case input, the best-case input, or neither?
Estimate how many times faster quicksort will sort an array of one million random numbers than insertion sort
True or false: For every n > 1, there are n-element arrays that are sorted faster by insertion sort than by quicksort?
Design an algorithm to rearrange elements of a given array of n real numbers so that all its negative elements precede all its positive elements.  Your algorithm should be both time efficient and space efficient.
The Dutch national flag problem is to rearrange an array of characters R, W, and B (red, white, and blue are the colors of the Dutch national flag) so that all the R's come first, the W's come next, and the B's come last. Design a linear in-place algorithm for this problem.
The Dutch national flag problem is to rearrange an array of characters R, W, and B (red, white, and blue are the colors of the Dutch national flag) so that all the R's come first, the W's come next, and the B's come last. Explain how a solution to the Dutch national flag problem can be used in quicksort.
Implement quicksort in the language of your choice.
Run your program on a sample of inputs to verify the theoretical assertions about the algorithm's efficiency.
Nuts and bolts: You are given a collection of n bolts of different widths and n corresponding nuts. You are allowed to try a nut and bolt together, from which you can determine whether the nut is larger than the bolt, smaller than the bolt, or matches the bolt exactly. However, there is no way to compare two nuts together or two bolts together.  The problem is to match each bolt to its nut. Design an algorithm for this problem with average-case efficiency in  (n log n).
Design a divide-and-conquer algorithm for computing the number of levels in a binary tree. (In particular, the algorithm must return 0 and 1 for the empty and single-node trees, respectively.)
What is the time efficiency class of your algorithm?
The following algorithm seeks to compute the number of leaves in a binary tree. <Algorithm> Is this algorithm correct? If it is, prove it; if it is not, make an appropriate correction.
Can you compute the height of a binary tree with the same asymptotic efficiency as the section's divide-and-conquer algorithm but without using a stack explicitly or implicitly?
Prove equality (5.2) by mathematical induction.
Traverse the following binary tree a.  in preorder. b. in inorder. c.  in postorder.
Write pseudocode for one of the classic traversal algorithms (preorder, inorder, and postorder) for binary trees.
Assuming that your algorithm is recursive, find the number of recursive calls made.
Which of the three classic traversal algorithms yields a sorted list if applied to a binary search tree?
Draw a binary tree with 10 nodes labeled 0, 1, . . . , 9 in such a way that the inorder and postorder traversals of the tree yield the following lists: 9, 3, 1, 0, 4, 2, 7, 6, 8, 5 (inorder) and 9, 1, 4, 0, 3, 6, 7, 5, 8, 2 (postorder).
Give an example of two permutations of the same n labels 0, 1, . . . , n 1 that cannot be inorder and postorder traversal lists of the same binary tree.
Design an algorithm that constructs a binary tree for which two given lists of n labels 0, 1, . . . , n 1 are generated by the inorder and postorder traversals of the tree. Your algorithm should also identify inputs for which the problem has no solution.
The internal path length I of an extended binary tree is defined as the sum of the lengths of the paths--taken over all internal nodes--from the root to each internal node. Similarly, the external path length E of an extended binary tree is defined as the sum of the lengths of the paths--taken over all external nodes--from the root to each external node. Prove that E = I + 2n where n is the number of internal nodes in the tree.
Write a program for computing the internal path length of an extended binary tree.
Chocolate bar puzzle: Given an n × m chocolate bar, you need to break it into nm 1 × 1 pieces. You can break a bar only in a straight line, and only one bar can be broken at a time. Design an algorithm that solves the problem with the minimum number of bar breaks.
What are the smallest and largest numbers of digits the product of two decimal n-digit integers can have?
Compute 2101  1130 by applying the divide-and-conquer algorithm outlined in the text.
Prove the equality alogb c = clogb a, which was used in Section 5.4
Why is nlog2 3 better than 3log2 n as a closed-form formula for M(n)?
Why did we not include multiplications by 10n in the multiplication count M(n) of the large-integer multiplication algorithm?
In addition to assuming that n is a power of 2, we made, for the sake of simplicity, another, more subtle, assumption in setting up the recurrences for M(n) and A(n), which is not always true (it does not change the final answers, however). What is this assumption?
How many one-digit additions are made by the pen-and-pencil algorithm in multiplying two n-digit integers? You may disregard potential carries.
Verify the formulas underlying Strassen's algorithm for multiplying 2 × 2 matrices.
Apply Strassen's algorithm to compute exiting the recursion when n = 2, i.e., computing the products of 2 × 2 matrices by the brute-force algorithm.
Solve the recurrence for the number of additions required by Strassen's algorithm. Assume that n is a power of 2.
V. Pan has discovered a divide-and-conquer matrix multiplication algorithm that is based on multiplying two 70 × 70 matrices using 143,640 multiplications. Find the asymptotic efficiency of Pan's algorithm (you may ignore additions) and compare it with that of Strassen's algorithm.
Practical implementations of Strassen's algorithm usually switch to the bruteforce method after matrix sizes become smaller than some crossover point. Run an experiment to determine such a crossover point on your computer system.
For the one-dimensional version of the closest-pair problem, i.e., for the problem of finding two closest numbers among a given set of n real numbers, design an algorithm that is directly based on the divide-and-conquer technique and determine its efficiency class.
Implement the divide-and-conquer closest-pair algorithm, outlined in this section, in the language of your choice.
Find on the Web a visualization of an algorithm for the closest-pair problem.
The Voronoi polygon for a point p of a set S of points in the plane is defined to be the perimeter of the set of all points in the plane closer to p than to any other point in S. The union of all the Voronoi polygons of the points in S is called the Voronoi diagram of S.  What is the Voronoi diagram for a set of three points?
The Voronoi polygon for a point p of a set S of points in the plane is defined to be the perimeter of the set of all points in the plane closer to p than to any other point in S. The union of all the Voronoi polygons of the points in S is called the Voronoi diagram of S. Find a visualization of an algorithm for generating the Voronoi diagram on the Web and study a few examples of such diagrams.
What is the best-case efficiency of quickhull?
Give a specific example of inputs that make quickhull run in quadratic time.
Implement quickhull in the language of your choice.
Creating decagons: There are 1000 points in the plane, no three of them on the same line. Devise an algorithm to construct 100 decagons with their vertices at these points. The decagons need not be convex, but each of them has to be simple, i.e., its boundary should not cross itself, and no two decagons may have a common point.
Shortest path around: There is a fenced area in the two-dimensional Euclidean  plane  in  the  shape  of  a  convex   polygon  with  vertices  at  points p1(x1, y1), p2(x2, y2), . . . , pn(xn, yn). There are two more points, a(xa, ya) and b(xb, yb) such that xa < min{x1, x2, . . . , xn} and xb > max{x1, x2, . . . , xn}. Design a reasonably efficient algorithm for computing the length of the shortest path between a and b.
Consider the problem of finding the distance between the two closest numbers in an array of n numbers. (The distance between two numbers x and y is computed as |x y|.) Design a presorting-based algorithm for solving this problem and determine its efficiency class.
Compare the efficiency of this algorithm with that of the brute-force algorithm
Let A = {a1, . . . , an} and B = {b1, . . . , bm} be two sets of numbers. Consider the problem of finding their intersection, i.e., the set C of all the numbers that are in both A and B. Design a brute-force algorithm for solving this problem and determine its efficiency class.
Let A = {a1, . . . , an} and B = {b1, . . . , bm} be two sets of numbers. Consider the problem of finding their intersection, i.e., the set C of all the numbers that are in both A and B. Design a presorting-based algorithm for solving this problem and determine its efficiency class.
Consider the problem of finding the smallest and largest elements in an array of n numbers. Design a presorting-based algorithm for solving this problem and determine its efficiency class.
Consider the problem of finding the smallest and largest elements in an array of n numbers.
Design a reasonably efficient algorithm for solving each of the following problems and determine its efficiency class. You are given n telephone bills and m checks sent to pay the bills (n  m). Assuming that telephone numbers are written on the checks, find out who failed to pay. (For simplicity, you may also assume that only one check is written for a particular bill and that it covers the bill in full)
Design a reasonably efficient algorithm for solving each of the following problems and determine its efficiency class. You have a file of n student records indicating each student's   number, name, home address, and date of birth. Find out the number of students from each of the 50 U.S. states.
Given a set of n  3 points in the Cartesian plane, connect them in a simple polygon, i.e., a closed path through all the points so that its line segments (the polygon's edges) do not intersect (except for neighboring edges at their common vertex). For example, Does the problem always have a solution?
Given a set of n  3 points in the Cartesian plane, connect them in a simple polygon, i.e., a closed path through all the points so that its line segments (the polygon's edges) do not intersect (except for neighboring edges at their common vertex). For example, Does it always have a unique solution?
Design a reasonably efficient algorithm for solving this problem and indicate its efficiency class.
You have an array of n real numbers and another integer s. Find out whether the array contains two elements whose sum is s. (For example, for the array 5, 9, 1, 3 and s = 6, the answer is yes, but for the same array and s = 7, the answer is no.) Design an algorithm for this problem with a better than quadratic time efficiency.
You have a list of n open intervals (a1, b1), (a2, b2), . . . , (an, bn) on the real line. (An open interval (a, b) comprises all the points strictly between its endpoints a and b, i.e., (a, b) = {x| a < x < b}.) Find the maximum number of these intervals that have a common point. For example, for the intervals (1, 4), (0, 3), (-5, 2), (3.6, 5), this maximum number is 3. Design an algorithm for this problem with a better than quadratic time efficiency.
Number placement: Given a list of n distinct integers and a sequence of n boxes with pre-set inequality signs inserted between them, design an algorithm that places the numbers into the boxes to satisfy those inequalities. For example, the numbers 4, 6, 3, 1, 8 can be placed in the five boxes as shown
Maxima search: a.  A point (xi, yi) in the Cartesian plane is said to be dominated by point (xj , yj ) if xi  xj and yi  yj with at least one of the two inequalities being strict. Given a set of n points, one of them is said to be a maximum of the set if it is not dominated by any other point in the set. Design an efficient algorithm for finding all the maximum points of a given set of n points in the Cartesian plane.
What is the time efficiency class of your algorithm?
Give a few real-world applications of this algorithm.
Anagram detection: Design an efficient algorithm for finding all sets of anagrams in a large file such as a dictionary of English words. For example, eat, ate, and tea belong to one such set.
Write a program implementing the algorithm.
Solve the following system by Gaussian elimination: x1 + x2 + x3 = 2
2x1 + x2 + x3 = 3 x1 x2 + 3x3 = 8. Solve the system of the previous question by the LU decomposition method.
From the standpoint of general algorithm design techniques, how would you classify the LU decomposition method?
Solve the system of Problem 1 by computing the inverse of its coefficient matrix and then multiplying it by the vector on the right-hand side.
Write pseudocode for the back-substitution stage of Gaussian elimination and show that its running time is in(n2).
Assuming that division of two numbers takes three times longer than their multiplication, estimate how much faster Better Forward Elimination is than Forward Elimination.
Give an example of a system of two linear equations in two unknowns that has a unique solution and solve it by Gaussian elimination.
Give an example of a system of two linear equations in two unknowns that has no solution and apply Gaussian elimination to it.
Give an example of a system of two linear equations in two unknowns that has infinitely many solutions and apply Gaussian elimination to it.
The Gauss-Jordan elimination method differs from Gaussian elimination in that the elements above the main diagonal of the coefficient matrix are made zero at the same time and by the same use of a pivot row as the elements below the main diagonal. Apply the Gauss-Jordan method to the system of Problem 1 of these exercises.
The Gauss-Jordan elimination method differs from Gaussian elimination in that the elements above the main diagonal of the coefficient matrix are made zero at the same time and by the same use of a pivot row as the elements below the main diagonal. What general design strategy is this algorithm based on?
The Gauss-Jordan elimination method differs from Gaussian elimination in that the elements above the main diagonal of the coefficient matrix are made zero at the same time and by the same use of a pivot row as the elements below the main diagonal. In general, how many multiplications are made by this method in solving a system of n equations in n unknowns?
A system Ax = b of n linear equations in n unknowns has a unique solution if and only if det A = 0. Is it a good idea to check this condition before applying Gaussian elimination to the system?
Apply Cramer's rule to solve the system of Problem 1 of these exercises.
Estimate how many times longer it will take to solve a system of n linear equations in n unknowns by Cramer's rule than by Gaussian elimination. Assume that all the determinants in Cramer's rule formulas are computed independently by Gaussian elimination.
Lights out: This one-person game is played on an n × n board composed of 1 × 1 light panels. Each panel has a switch that can be turned on and off, thereby toggling the on/off state of this and four vertically and horizontally adjacent panels. (Of course, toggling a corner square affects a total of three panels, and toggling a noncorner panel on the board's border affects a total of four squares.) Given an initial subset of lighted squares, the goal is to turn all the lights off. Show that an answer can be found by solving a system of linear equations with 0/1 coefficients and right-hand sides using the modulo 2 arithmetic.
Use Gaussian elimination to solve the 2 × 2 all-ones instance of this problem, where all the panels of the 2 × 2 board are initially lit.
Use Gaussian elimination to solve the 3 × 3 all-ones instance of this problem, where all the panels of the 3 × 3 board are initially lit.
Which of the following binary trees are AVL trees?
For n = 1, 2, 3, 4, and 5, draw all the binary trees with n nodes that satisfy the balance requirement of AVL trees.
Draw a binary tree of height 4 that can be an AVL tree and has the smallest number of nodes among all such trees.
Draw diagrams of the single L-rotation and of the double RL-rotation in their general form.
For each of the following lists, construct an AVL tree by inserting their elements successively, starting with the empty tree. a. 1, 2, 3, 4, 5, 6 b. 6, 5, 4, 3, 2, 1 c. 3, 6, 5, 1, 2, 4
For an AVL tree containing real numbers, design an algorithm for computing the range (i.e., the difference between the largest and smallest numbers in the tree) and determine its worst-case efficiency.
True or false: The smallest and the largest keys in an AVL tree can always be found on either the last level or the next-to-last level?
Write a program for constructing an AVL tree for a given list of n distinct integers.
Construct a 2-3 tree for the list C, O, M, P, U, T, I, N, G. Use the alphabetical order of the letters and insert them successively starting with the empty tree.
Assuming that the probabilities of searching for each of the keys (i.e., the letters) are the same, find the largest number and the average number of key comparisons for successful searches in this tree.
Let TB and T2-3 be, respectively, a classical binary search tree and a 2-3 tree constructed for the same list of keys inserted in the corresponding trees in the same order. True or false: Searching for the same key in T2-3 always takes fewer or the same number of key comparisons as searching in TB?
For a 2-3 tree containing real numbers, design an algorithm for computing the range (i.e., the difference between the largest and smallest numbers in the tree) and determine its worst-case efficiency.
Write a program for constructing a 2-3 tree for a given list of n integers.
Construct a heap for the list 1, 8, 6, 5, 3, 7, 4 by the bottom-up algorithm.
Construct a heap for the list 1, 8, 6, 5, 3, 7, 4 by successive key insertions (top-down algorithm).
Is it always true that the bottom-up and top-down algorithms yield the same heap for the same input?
Outline an algorithm for checking whether an array H [.n] is a heap and determine its time efficiency.
Find the smallest and the largest number of keys that a heap of height h can contain.
Prove that the height of a heap with n nodes is equal to log2 n
Prove the following equality used in Section 6.4: h-1 2(h i)2i = 2(n log2(n + 1)), where n = 2h+1 i=0
Design an efficient algorithm for finding and deleting an element of the smallest value in a heap and determine its time efficiency.
Design an efficient algorithm for finding and deleting an element of a given value v in a heap H and determine its time efficiency.
Indicate the time efficiency classes of the three main operations of the priority queue implemented as a. an unsorted array. b. a sorted array. c. a binary search tree. d. an AVL tree. e. a heap.
Sort the following lists by heapsort by using the array representation of heaps. a. 1, 2, 3, 4, 5 (in increasing order) b. 5, 4, 3, 2, 1 (in increasing order) c. S, O, R, T, I, N, G (in alphabetical order)
Is heapsort a stable sorting algorithm?
What variety of the transform-and-conquer technique does heapsort represent?
Which sorting algorithm other than heapsort uses a priority queue?
Implement three advanced sorting algorithms--mergesort, quicksort, and heapsort--in the language of your choice and investigate their performance on arrays of sizes n = 103, 104, 105, and 106.
For each of these sizes consider a. randomly generated files of integers in the range [.n]. b. increasing files of integers 1, 2, . . . , n. c. decreasing files of integers n, n 1, . . . ,
Spaghetti sort: Imagine a handful of uncooked spaghetti, individual rods whose lengths represent numbers that need to be sorted. Outline a spaghetti sort--a sorting algorithm that takes advantage of this unorthodox representation.
Spaghetti sort: Imagine a handful of uncooked spaghetti, individual rods whose lengths represent numbers that need to be sorted. What does this example of computer science folklore have to do with the topic of this chapter in general and heapsort in particular?
Consider the following brute-force algorithm for evaluating a polynomial. <Algorithm> Brute Force Polynomial Evaluation Find the total number of multiplications and the total number of additions made by this algorithm.
Write pseudocode for the brute-force polynomial evaluation that stems from substituting a given value of the variable into the polynomial's formula and evaluating it from the lowest term to the highest one.
Determine the number of multiplications and the number of additions made by this algorithm.
Estimate how much faster Horner's rule is compared to the lowest to highest term brute-force algorithm of Problem 2 if the time of one multiplication is significantly larger than the time of one addition
Estimate how much faster Horner's rule is compared to the lowest to highest term brute-force algorithm of Problem 2 if the time of one multiplication is about the same as the time of one addition.
Is Horner's rule more time efficient at the expense of being less space efficient than the brute-force algorithm?
Apply Horner's rule to evaluate the polynomial p(x) = 3x4 x3 + 2x + 5at x = -2.
Use the results of the above application of Horner's rule to find the quotient and remainder of the division of p(x) by x + 2.
Apply Horner's rule to convert 110100101 from binary to decimal.
Compare the number of multiplications and additions/subtractions needed by the long division of a polynomial p(x) = anxn + an-1xn-1 + . . . + a0 by x c, where c is some constant, with the number of these operations in the synthetic division.
Apply the left-to-right binary exponentiation algorithm to compute a17
Is it possible to extend the left-to-right binary exponentiation algorithm to work for every nonnegative integer exponent?
Apply the right-to-left binary exponentiation algorithm to compute a17.
Design a nonrecursive algorithm for computing an that mimics the right-to-left binary exponentiation but does not explicitly use the binary representation of n.
Is it a good idea to use a general-purpose polynomial-evaluation algorithm such as Horner's rule to evaluate the polynomial p(x) = xn + xn-1 + . . . + x + 1?
Polynomial interpolation: Given a set of n data points (xi, yi) where no two xi are the same, find a polynomial p(x) of degree at most n 1 such that p(xi) = yi for every i = 1, 2, . . . , n.
Prove the equality lcm(m, n) = m.n gcd(m, n) that underlies the algorithm for computing lcm(m, n).
Euclid's algorithm is known to be in O(log n). If it is the algorithm that is used for computing gcd(m, n), what is the efficiency of the algorithm for computing lcm(m, n)?
You are given a list of numbers for which you need to construct a min-heap. (A min-heap is a complete binary tree in which every key is less than or equal to the keys in its children.) How would you use an algorithm for constructing a max-heap (a heap as defined in Section 6.4) to construct a min-heap?
Prove that the number of different paths of length k > 0 from the ith vertex to the j th vertex in a graph (undirected or directed) equals the (i, j )th element of Ak where A is the adjacency matrix of the graph.
Design an algorithm with a time efficiency better than cubic for checking whether a graph with n vertices contains a cycle of length 3
Consider the following algorithm. Starting at an arbitrary vertex, traverse the graph by depth-first search and check whether its depth-first search forest has a vertex with a back edge leading to its grandparent. If it does, the graph contains a triangle; if it does not, the graph does not contain a triangle as its subgraph. Is this algorithm correct?
Given n > 3 points P1 = (x1, y1), . . . , Pn = (xn, yn) in the coordinate plane, design an algorithm to check whether all the points lie within a triangle with its vertices at three of the points given. (You can either design an algorithm from scratch or reduce the problem to another one with a known algorithm.)
Consider the problem of finding, for a given positive integer n, the pair of integers whose sum is n and whose product is as large as possible. Design an efficient algorithm for this problem and indicate its efficiency class.
The assignment problem introduced in Section 3.4 can be stated as follows: There are n people who need to be assigned to execute n jobs, one person per job. (That is, each person is assigned to exactly one job and each job is assigned to exactly one person.) The cost that would accrue if the ith person is assigned to the j th job is a known quantity C[i, j ] for each pair i, j = 1, . . . , n. The problem is to assign the people to the jobs to minimize the total cost of the assignment. Express the assignment problem as a 0-1 linear programming problem.
Solve the instance of the linear programming problem given in Section 6.6: maximize 0.10x + 0.07y + 0.03z subject to x + y + z = 100 x1 y 3 z 0.25(x + y) x 0, y 0, z 0.
The graph-coloring problem is usually stated as the vertex-coloring problem: Assign the smallest number of colors to vertices of a given graph so that no two adjacent vertices are the same color. Consider the edge-coloring problem: Assign the smallest number of colors possible to edges of a given graph so that no two edges with the same endpoint are the same color.
Explain how the edge-coloring problem can be reduced to a vertex-coloring problem.
Consider the two-dimensional post office location problem: given n points (x1, y1), . . . , (xn, yn) in the Cartesian plane, find a location for a post office (x, y) 1 ni=1(|xi x| + |yi y|), that minimizes the average Manhattan distance from the post office to these points.
Jealous husbands: There are n 2 married couples who need to cross a river. They have a boat that can hold no more than two people at a time. To complicate matters, all the husbands are jealous and will not agree on any crossing procedure that would put a wife on the same bank of the river with another woman's husband without the wife's husband being there too, even if there are other people on the same bank. Can they cross the river under such constraints?
Jealous husbands: There are n 2 married couples who need to cross a river. They have a boat that can hold no more than two people at a time. To complicate matters, all the husbands are jealous and will not agree on any crossing procedure that would put a wife on the same bank of the river with another woman's husband without the wife's husband being there too, even if there are other people on the same bank. Solve the problem for n = 2, n = 3, which is the classical version of this problem.
Jealous husbands: There are n 2 married couples who need to cross a river. They have a boat that can hold no more than two people at a time. To complicate matters, all the husbands are jealous and will not agree on any crossing procedure that would put a wife on the same bank of the river with another woman's husband without the wife's husband being there too, even if there are other people on the same bank. Does the problem have a solution for n 4? If it does, indicate how many river crossings it will take; if it does not, explain why.
Double-n dominoes: Dominoes are small rectangular tiles with dots called spots or pips embossed at both halves of the tiles. A standard double-six domino set has 28 tiles: one for each unordered pair of integers from (0, 0) to (6, 6). In general, a double-n domino set would consist of domino tiles for each unordered pair of integers from (0, 0) to (n, n). Determine all values of n for which one constructs a ring made up of all the tiles in a double-n domino set.
Is it possible to exchange numeric values of two variables, say, u and v, without using any extra storage?
Will the comparison-counting algorithm work correctly for arrays with equal values?
Assuming that the set of possible list values is {a, b, c, d}, sort the following list in alphabetical order by the distribution-counting algorithm: b, c, d, c, b, a, a, b.
Is the distribution-counting algorithm stable?
Design a one-line algorithm for sorting any array of size n whose values are n distinct integers from 1 to n.
The ancestry problem asks to determine whether a vertex u is an ancestor of vertex v in a given binary (or, more generally, rooted ordered) tree of n vertices. Design a O(n) input-enhancement algorithm that provides sufficient information to solve this problem for any pair of the tree's vertices in constant time.
The following technique, known as virtual initialization, provides a time efficient way to initialize just some elements of a given array A[0..n 1] so that for each of its elements, we can say in constant time whether it has been initialized and, if it has been, with which value. This is done by utilizing a variable counter for the number of initialized elements in A and two auxiliary arrays of the same size, say B[0..n 1] and C[0..n 1], defined as follows. B[0], . . . , B[counter 1] contain the indices of the elements of A that were initialized: B[0] contains the index of the element initialized first, B[1] contains the index of the element initialized second, etc. Furthermore, if A[i] was the kth element (0 k counter 1) to be initialized, C[i] contains k. Sketch the state of arrays A[0..7], B[0..7], and C[0..7] after the three assignments A[3] x; A[7] z;A[1] y.
The following technique, known as virtual initialization, provides a time efficient way to initialize just some elements of a given array A[0..n 1] so that for each of its elements, we can say in constant time whether it has been initialized and, if it has been, with which value. This is done by utilizing a variable counter for the number of initialized elements in A and two auxiliary arrays of the same size, say B[0..n 1] and C[0..n 1], defined as follows. B[0], . . . , B[counter 1] contain the indices of the elements of A that were initialized: B[0] contains the index of the element initialized first, B[1] contains the index of the element initialized second, etc. Furthermore, if A[i] was the kth element (0 k counter 1) to be initialized, C[i] contains k. In general, how can we check with this scheme whether A[i] has been initialized and, if it has been, with which value?
Least distance sorting: There are 10 Egyptian stone statues standing in a row in an art gallery hall. A new curator wants to move them so that the statues are ordered by their height. How should this be done to minimize the total distance that the statues are moved? You may assume for simplicity that all the statues have different heights.
Write a program for multiplying two sparse matrices, a p × q matrix A and a q × r matrix B.
Write a program for multiplying two sparse polynomials p(x) and q(x) of degrees m and n, respectively.
Is it a good idea to write a program that plays the classic game of tic-tac-toe with the human user by storing all possible positions on the game's 3 × 3 board along with the best move for each of them?
Apply Horspool's algorithm to search for the pattern BAOBAB in the text BESS KNEW ABOUT BAOBABS
Consider the problem of searching for genes in DNA sequences using Horspool's algorithm. A DNA sequence is represented by a text on the alphabet {A, C, G, T}, and the gene or gene segment is the pattern. Construct the shift table for the following gene segment of your chromosome 10: TCCTATTCTT
Apply Horspool's algorithm to locate the above pattern in the following DNA sequence: TTATAGATCTCGTATTCTTTTATAGATCTCCTATTCTT
How many character comparisons will be made by Horspool's algorithm in searching for each of the following patterns in the binary text of 1000 zeros? a. 00001 b. 10000 c. 01010 For searching in a text of length n for a pattern of length m (n m) with Horspool's algorithm, give an example of a. worst-case input. b. best-case input.
Is it possible for Horspool's algorithm to make more character comparisons than the brute-force algorithm would make in searching for the same pattern in the same text?
If Horspool's algorithm discovers a matching substring, how large a shift should it make to search for a next possible match?
How many character comparisons will the Boyer-Moore algorithm make in searching for each of the following patterns in the binary text of 1000 zeros? a. 00001 b. 10000 c. 01010
Would the Boyer-Moore algorithm work correctly with just the bad-symbol table to guide pattern shifts?
Would the Boyer-Moore algorithm work correctly with just the good-suffix table to guide pattern shifts?
If the last characters of a pattern and its counterpart in the text do match, does Horspool's algorithm have to check other characters right to left, or can it check them left to right too?
If the last characters of a pattern and its counterpart in the text do match, does the Boyer-Moore algorithm have to check other characters right to left, or can it check them left to right too?.
Implement Horspool's algorithm, the Boyer-Moore algorithm, and the brute force algorithm of Section 3.2 in the language of your choice and run an experiment to compare their efficiencies
You are given two strings S and T , each n characters long. You have to establish whether one of them is a right cyclic shift of the other. For example, PLEA is a right cyclic shift of LEAP, and vice versa. (Formally, T is a right cyclic shift of S if T can be obtained by concatenating the (n i)-character suffix of S and the i-character prefix of S for some 1 i n.) Design a space-efficient algorithm for the task. Indicate the space and time efficiencies of your algorithm.
You are given two strings S and T , each n characters long. You have to establish whether one of them is a right cyclic shift of the other. For example, PLEA is a right cyclic shift of LEAP, and vice versa. (Formally, T is a right cyclic shift of S if T can be obtained by concatenating the (n i)-character suffix of S and the i-character prefix of S for some 1 i n.) Design a time-efficient algorithm for the task. Indicate the time and space efficiencies of your algorithm.
For the input 30, 20, 56, 75, 31, 19 and hash function h(K) = K mod 11, construct the open hash table.
For the input 30, 20, 56, 75, 31, 19 and hash function h(K) = K mod 11, find the largest number of key comparisons in a successful search in this table.
For the input 30, 20, 56, 75, 31, 19 and hash function h(K) = K mod 11, find the average number of key comparisons in a successful search in this table.
For the input 30, 20, 56, 75, 31, 19 and hash function h(K) = K mod 11, construct the closed hash table.
For the input 30, 20, 56, 75, 31, 19 and hash function h(K) = K mod 11, find the largest number of key comparisons in a successful search in this table.
For the input 30, 20, 56, 75, 31, 19 and hash function h(K) = K mod 11, find the average number of key comparisons in a successful search in this table.
Why is it not a good idea for a hash function to depend on just one letter (say, the first one) of a natural-language word?
Find the probability of all n keys being hashed to the same cell of a hash table of size m if the hash function distributes keys evenly among all the cells of the table.
Birthday paradox: The birthday paradox asks how many people should be in a room so that the chances are better than even that two of them will have the same birthday (month and day). Find the quite unexpected answer to this problem.
Birthday paradox: The birthday paradox asks how many people should be in a room so that the chances are better than even that two of them will have the same birthday (month and day). What implication for hashing does this result have?
For the separate-chaining version of hashing, where would you insert keys if you knew that all the keys in the dictionary are distinct?
Which dictionary operations, if any, would benefit from this modification?
For the separate-chaining version of hashing, We could keep keys of the same linked list sorted. Which of the dictionary operations would benefit from this modification?
Explain how to use hashing to check whether all elements of a list are distinct.
What is the time efficiency of this application?
Compare its efficiency with that of the brute-force algorithm (Section 2.3) and of the presorting-based algorithm (Section 6.1).
Fill in the following table with the average-case (as the first entry) and worst case (as the second entry) efficiency classes for the five implementations of the ADT dictionary: unordered ordered binary balanced array array search tree search tree hashing search insertion deletion
We have discussed hashing in the context of techniques based on space­time trade-offs. But it also takes advantage of another general strategy. Which one?
Write a computer program that uses hashing for the following problem: Given a natural-language text, generate a list of distinct words with the number of occurrences of each word in the text.
Give examples of using an index in real-life applications that do not involve computers.
Find the minimum order of the B-tree that guarantees that the number of disk accesses in searching in a file of 100 million records does not exceed 3. Assume that the root's page is stored in main memory.
Draw the B-tree obtained after inserting 30 and then 31 in the B-tree in Figure 7.8. Assume that a leaf cannot contain more than three items.
Outline an algorithm for finding the largest key in a B-tree.
A top-down 2-3-4 tree is a B-tree of order 4 with the following modification of the insert operation: Whenever a search for a leaf for a new key encounters a full node (i.e., a node with three keys), the node is split into two nodes by sending its middle key to the node's parent, or, if the full node happens to be the root, the new root for the middle key is created. Construct a top-down 2-3-4 tree by inserting the following list of keys in the initially empty tree: 10, 6, 15, 31, 20, 27, 50, 44, 18.
What is the principal advantage of this insertion procedure compared with the one used for 2-3 trees?
What is its disadvantage compared with the one used for 2-3 trees?
Write a program implementing a key insertion algorithm in a B-tree.
Write a program for visualization of a key insertion algorithm in a B-tree.
What does dynamic programming have in common with divide-and-conquer?
What is a principal difference between dynamic programming and divide-and-conquer?
Solve the instance 5, 1, 2, 10, 6 of the coin-row problem.
Show that the time efficiency of solving the coin-row problem by straightforward application of recurrence (8.3) is exponential.
Show that the time efficiency of solving the coin-row problem by exhaustive search is at least exponential.
Apply the dynamic programming algorithm to find all the solutions to the change-making problem for the denominations 1, 3, 5 and the amount n = 9.
How would you modify the dynamic programming algorithm for the coin collecting problem if some cells on the board are inaccessible for the robot?
Apply your algorithm to the board below, where the inaccessible cells are shown by X's.
How many optimal paths are there for this board?
Rod-cutting problem: Design a dynamic programming algorithm for the following problem. Find the maximum total sale price that can be obtained by cutting a rod of n units long into integer-length pieces if the sale price of a piece i units long is pi for i = 1, 2, . . . , n.
What are the time and space efficiencies of your algorithm?
Shortest-path counting: A chess rook can move horizontally or vertically to any square in the same row or in the same column of a chessboard. Find the number of shortest paths by which a rook can move from one corner of a chessboard to the diagonally opposite corner. The length of a path is measured by the number of squares it passes through, including the first and the last squares. Solve the problem a. by a dynamic programming algorithm. b. by using elementary combinatorics.
Minimum-sum descent: Some positive integers are arranged in an equilateral triangle with n numbers in its base like the one shown in the figure below for n = 4. The problem is to find the smallest sum in a descent from the triangle apex to its base through a sequence of adjacent numbers (shown in the figure by the circles). Design a dynamic programming algorithm for this problem and indicate its time efficiency.
Binomial coefficient: Design an efficient algorithm for computing the binomial coefficient C(n, k) that uses no multiplications.
Longest path in a dag: Design an efficient algorithm for finding the length of the longest path in a dag.
Show how to reduce the coin-row problem discussed in this section to the problem of finding a longest path in a dag.
Maximum square submatrix: Given an m × n boolean matrix B, find its largest square submatrix whose elements are all zeros. Design a dynamic programming algorithm and indicate its time efficiency.
World Series odds Consider two teams, A and B, playing a series of games until one of the teams wins n games. Assume that the probability of A winning a game is the same for each game and equal to p, and the probability of A losing a game is q = 1 p. (Hence, there are no ties.) Let P (i, j ) be the probability of A winning the series if A needs i more games to win the series and B needs j more games to win the series. Set up a recurrence relation for P (i, j ) that can be used by a dynamic programming algorithm.
World Series odds Consider two teams, A and B, playing a series of games until one of the teams wins n games. Assume that the probability of A winning a game is the same for each game and equal to p, and the probability of A losing a game is q = 1 p. (Hence, there are no ties.) Let P (i, j ) be the probability of A winning the series if A needs i more games to win the series and B needs j more games to win the series. Find the probability of team A winning a seven-game series if the probability of it winning a game is 0.4.
Write pseudocode of the dynamic programming algorithm for solving this problem and determine its time and space efficiencies.
Apply the bottom-up dynamic programming algorithm to the following instance of the knapsack problem: item weight value Capacity W=6
How many different optimal subsets does the instance of part (a) have?
In general, how can we use the table generated by the dynamic programming algorithm to tell whether there is more than one optimal subset for the knapsack problem's instance?
Write pseudocode of the bottom-up dynamic programming algorithm for the knapsack problem.
Write pseudocode of the algorithm that finds the composition of an optimal subset from the table generated by the bottom-up dynamic programming algorithm for the knapsack problem.
For the bottom-up dynamic programming algorithm for the knapsack problem, prove that its time efficiency is (nW ), its space efficiency is (nW ) and the time needed to find the composition of an optimal subset from a filled dynamic programming table is O(n).
True or false: A sequence of values in a row of the dynamic programming table for the knapsack problem is always nondecreasing?
True or false: A sequence of values in a column of the dynamic programming table for the knapsack problem is always nondecreasing?
Design a dynamic programming algorithm for the version of the knapsack problem in which there are unlimited quantities of copies for each of the n item kinds given.
Write a research report on one of the following well-known applications of dynamic programming: a. finding the longest common subsequence in two sequences b. optimal string editing c. minimal triangulation of a polygon
Finish the computations started in the section's example of constructing an optimal binary search tree.
Why is the time efficiency of algorithm OptimalBST cubic?
Why is the space efficiency of algorithm OptimalBST quadratic?
Write pseudocode for a linear-time algorithm that generates the optimal binary search tree from the root table.
Devise a way to compute the sums jps , which are used in the dynamic s=i programming algorithm for constructing an optimal binary search tree, in constant time (per sum).
True or false: The root of an optimal binary search tree always contains the key with the highest search probability?
How would you construct an optimal binary search tree for a set of n keys if all the keys are equally likely to be searched for?
What will be the average number of comparisons in a successful search in such a tree if n = 2k?
Show that the number of distinct binary search trees b(n) that can be constructed for a set of n orderable keys satisfies the recurrence relation n-1 b(n) = b(k)b(n 1 k) for n > 0, b(0) = k=0
It is known that the solution to this recurrence is given by the Catalan numbers. Verify this assertion for n = 1, 2, . . . , 5.
Design a (n2) algorithm for finding an optimal binary search tree.
Generalize the optimal binary search algorithm by taking into account unsuccessful searches.
Write pseudocode of a memory function for the optimal binary search tree problem. You may limit your function to finding the smallest number of key comparisons in a successful search.
Matrix chain multiplication: Consider the problem of minimizing the total number of multiplications made in computing the product of n matrices A1 . A2 . . . . . An whose dimensions are d0 × d1, d1 × d2, . . . , dn-1 × dn, respectively. Assume that all intermediate products of two matrices are computed by the brute force (definition-based) algorithm. Give an example of three matrices for which the number of multiplications in (A1 . A2) . A3 and A1 . (A2 . A3) differ at least by a factor of 1000.
Matrix chain multiplication: Consider the problem of minimizing the total number of multiplications made in computing the product of n matrices A1 . A2 . . . . . An whose dimensions are d0 × d1, d1 × d2, . . . , dn-1 × dn, respectively. Assume that all intermediate products of two matrices are computed by the brute force (definition-based) algorithm. How many different ways are there to compute the product of n matrices?
Matrix chain multiplication: Consider the problem of minimizing the total number of multiplications made in computing the product of n matrices A1 . A2 . . . . . An whose dimensions are d0 × d1, d1 × d2, . . . , dn-1 × dn, respectively. Assume that all intermediate products of two matrices are computed by the brute force (definition-based) algorithm. Design a dynamic programming algorithm for finding an optimal order of multiplying n matrices.
Apply Warshall's algorithm to find the transitive closure of the digraph defined by the following adjacency matrix:
Prove that the time efficiency of Warshall's algorithm is cubic.
Explain why the time efficiency class of Warshall's algorithm is inferior to that of the traversal-based algorithm for sparse graphs represented by their adjacency lists.
Explain how to implement Warshall's algorithm without using extra memory for storing elements of the algorithm's intermediate matrices.
Explain how to restructure the innermost loop of the algorithm Warshall to make it run faster at least on some inputs.
Rewrite pseudocode of Warshall's algorithm assuming that the matrix rows are represented by bit strings on which the bitwise or operation can be performed.
Explain how Warshall's algorithm can be used to determine whether a given digraph is a dag (directed acyclic graph).
Is it a good idea to apply Warshall's algorithm to find the transitive closure of an undirected graph?
Solve the all-pairs shortest-path problem for the digraph with the following weight matrix:
Prove that the next matrix in sequence (8.12) of Floyd's algorithm can be written over its predecessor.
Give an example of a graph or a digraph with negative weights for which Floyd's algorithm does not yield the correct result.
Enhance Floyd's algorithm so that shortest paths themselves, not just their lengths, can be found.
Jack Straws: In the game of Jack Straws, a number of plastic or wooden straws are dumped on the table and players try to remove them one by one without disturbing the other straws. Here, we are only concerned with whether various pairs of straws are connected by a path of touching straws. Given a list of the endpoints for n > 1 straws (as if they were dumped on a large piece of graph paper), determine all the pairs of straws that are connected. Note that touching is connecting, but also that two straws can be connected indirectly via other connected straws.
Write pseudocode of the greedy algorithm for the change-making problem, with an amount n and coin denominations d1 > d2 > . . . > dm as its input.
Design a greedy algorithm for the assignment problem (see Section 3.4).
Does your greedy algorithm always yield an optimal solution?
Job scheduling: Consider the problem of scheduling n jobs of known durations t1, t2, . . . , tn for execution by a single processor. The jobs can be executed in any order, one job at a time. You want to find a schedule that minimizes the total time spent by all the jobs in the system. (The time spent by one job in the system is the sum of the time spent by this job in waiting plus the time spent on its execution.) Design a greedy algorithm for this problem.
Does the greedy algorithm always yield an optimal solution?
Compatible intervals: Given n open intervals (a1, b1), (a2, b2), . . . , (an, bn) on the real line, each representing start and end times of some activity requiring the same resource, the task is to find the largest number of these intervals so that no two of them overlap.
Investigate the three greedy algorithms based on a. earliest start first. b. shortest duration first. c. earliest finish first. For each of the three algorithms, either prove that the algorithm always yields an optimal solution or give a counterexample showing this not to be the case.
Bridge crossing revisited: Consider the generalization of the bridge crossing puzzle (Problem 2 in Exercises 2) in which we have n > 1 people whose bridge crossing times are t1, t2, . . . , tn. All the other conditions of the problem remain the same: at most two people at a time can cross the bridge (and they move with the speed of the slower of the two) and they must carry with them the only flashlight the group has. Design a greedy algorithm for this problem and find how long it will take to cross the bridge by using this algorithm.
Averaging down There are n > 1 identical vessels, one of them with W pints of water and the others empty. You are allowed to perform the following operation: take two of the vessels and split the total amount of water in them equally between them. The object is to achieve a minimum amount of water in the vessel containing all the water in the initial set up by a sequence of such operations. What is the best way to do this?
Rumor spreading: There are n people, each in possession of a different rumor. They want to share all the rumors with each other by sending electronic messages. Assume that a sender includes all the rumors he or she knows at the time the message is sent and that a message may only have one addressee. Design a greedy algorithm that always yields the minimum number of messages they need to send to guarantee that every one of them gets all the rumors.
Bachet's problem of weights: Find an optimal set of n weights {w1, w2, . . . , wn} so that it would be possible to weigh on a balance scale any integer load in the largest possible range from 1 to W , provided a. weights can be put only on the free cup of the scale. b. weights can be put on both cups of the scale.
Apply Prim's algorithm to the following graph. Include in the priority queue all the vertices not already in the tree.
Apply Prim's algorithm to the following graph. Include in the priority queue only the fringe vertices (the vertices not in the current tree which are adjacent to at least one tree vertex).
The notion of a minimum spanning tree is applicable to a connected weighted graph. Do we have to check a graph's connectivity before applying Prim's algorithm, or can the algorithm do it by itself?
Does Prim's algorithm always work correctly on graphs with negative edge weights?
Let T be a minimum spanning tree of graph G obtained by Prim's algorithm. Let Gnew be a graph obtained by adding to G a new vertex and some edges, with weights, connecting the new vertex to some vertices in G. Can we construct a minimum spanning tree of Gnew by adding one of the new edges to T ? If you answer yes, explain how; if you answer no, explain why not.
How can one use Prim's algorithm to find a spanning tree of a connected graph with no weights on its edges?
Is Prim's algorithm good for the problem of finding a spanning tree of a connected graph with no weights on its edges?
Prove that any weighted connected graph with distinct weights has exactly one minimum spanning tree.
Outline an efficient algorithm for changing an element's value in a min-heap. What is the time efficiency of your algorithm? Apply Kruskal's algorithm to find a minimum spanning tree of the following graphs.
True or false: If e is a minimum-weight edge in a connected weighted graph, it must be among edges of at least one minimum spanning tree of the graph.
True or false: If e is a minimum-weight edge in a connected weighted graph, it must be among edges of each minimum spanning tree of the graph.
True or false: If edge weights of a connected weighted graph are all distinct, the graph must have exactly one minimum spanning tree.
True or false: If edge weights of a connected weighted graph are not all distinct, the graph must have more than one minimum spanning tree.
What changes, if any, need to be made in algorithm Kruskal to make it find a minimum spanning forest for an arbitrary graph? (A minimum spanning forest is a forest whose trees are minimum spanning trees of the graph's connected components.)
Does Kruskal's algorithm work correctly on graphs that have negative edge weights?
Design an algorithm for finding a maximum spanning tree--a spanning tree with the largest possible edge weight--of a weighted connected graph.
Rewrite pseudocode of Kruskal's algorithm in terms of the operations of the disjoint subsets' ADT.
Prove the correctness of Kruskal's algorithm.
Prove that the time efficiency of find(x) is in O(log n) for the union-by-size version of quick union.
Design and conduct an experiment to empirically compare the efficiencies of Prim's and Kruskal's algorithms on random graphs of different sizes and densities.
Steiner tree: Four villages are located at the vertices of a unit square in the Euclidean plane. You are asked to connect them by the shortest network of roads so that there is a path between every pair of the villages along those roads. Find such a network. Write a program generating a random maze based on a. Prim's algorithm. b. Kruskal's algorithm.
Explain what adjustments if any need to be made in Dijkstra's algorithm and/or in an underlying graph to solve the following problems. a. Solve the single-source shortest-paths problem for directed weighted graphs. b. Find a shortest path between two given vertices of a weighted graph or digraph. (This variation is called the single-pair shortest-path problem.) c. Find the shortest paths to a given vertex from each other vertex of a weighted graph or digraph. (This variation is called the single-destination shortest-paths problem.) d. Solve the single-source shortest-paths problem in a graph with nonnegative numbers assigned to its vertices (and the length of a path defined as the sum of the vertex numbers on the path).
Solve the following instances of the single-source shortest-paths problem with vertex a as the source:
Give a counterexample that shows that Dijkstra's algorithm may not work for a weighted connected graph with negative weights.
Let T be a tree constructed by Dijkstra's algorithm in the process of solving the single-source shortest-paths problem for a weighted connected graph G. True or false: T is a spanning tree of G?
Let T be a tree constructed by Dijkstra's algorithm in the process of solving the single-source shortest-paths problem for a weighted connected graph G. True or false: T is a minimum spanning tree of G?
Write pseudocode for a simpler version of Dijkstra's algorithm that finds only the distances (i.e., the lengths of shortest paths but not shortest paths themselves) from a given vertex to all other vertices of a graph represented by its weight matrix.
Prove the correctness of Dijkstra's algorithm for graphs with positive weights.
Design a linear-time algorithm for solving the single-source shortest-paths problem for dags (directed acyclic graphs) represented by their adjacency lists.
Explain how the minimum-sum descent problem (Problem 8 in Exercises 8.1) can be solved by Dijkstra's algorithm.
Shortest-path modeling: Assume you have a model of a weighted connected graph made of balls (representing the vertices) connected by strings of appropriate lengths (representing the edges). a. Describe how you can solve the single-pair shortest-path problem with this model. b. Describe how you can solve the single-source shortest-paths problem with this model.
Revisit the exercise from Section 3 about determining the best route for a subway passenger to take from one designated station to another in a well developed subway system like those in Washington, DC, or London, UK. Write a program for this task.
Construct a Huffman code for the following data: symbol A BCD _ frequency0.40.1 0.2 0.15 0.15
Encode ABACABAD using Huffman code.
Decode 100010111001010 using Huffman code.
For data transmission purposes, it is often desirable to have a code with a minimum variance of the codeword lengths (among codes of the same average length). Compute the average and variance of the codeword length in two Huffman codes that result from a different tie breaking during a Huffman code construction for the following data: symbolA B CD E probability 0.1 0.10.2 0.2 0.4
Indicate whether each of the following properties is true for every Huffman code. a. The codewords of the two least frequent symbols have the same length. b. The codeword's length of a more frequent symbol is always smaller than or equal to the codeword's length of a less frequent one.
What is the maximal length of a codeword possible in a Huffman encoding of an alphabet of n symbols?
Write pseudocode of the Huffman-tree construction algorithm.
What is the time efficiency class of the algorithm for constructing a Huffman tree as a function of the alphabet size?
Show that a Huffman tree can be constructed in linear time if the alphabet symbols are given in a sorted order of their frequencies.
Given a Huffman coding tree, which algorithm would you use to get the codewords for all the symbols?
What is its time-efficiency class as a function of the alphabet size?
Explain how one can generate a Huffman code without an explicit generation of a Huffman coding tree.
Write a program that constructs a Huffman code for a given English text and encode it.
Write a program for decoding of an English text which has been encoded with a Huffman code.
Experiment with your encoding program to find a range of typical compression ratios for Huffman's encoding of English texts of, say, 1000 words.
Experiment with your encoding program to find out how sensitive the compression ratios are to using standard estimates of frequencies instead of actual frequencies of symbol occurrences in English texts.
Card guessing: Design a strategy that minimizes the expected number of questions asked in the following game. You have a deck of cards that consists of one ace of spades, two deuces of spades, three threes, and on up to nine nines, making 45 cards in all. Someone draws a card from the shuffled deck, which you have to identify by asking questions answerable with yes or no.
Consider the following version of the post office location problem (Problem 3 in Exercises 3.3): Given n integers x1, x2, . . . , xn representing coordinates of n villages located along a straight road, find a location for a post office that minimizes the average distance between the villages. The post office may be, but is not required to be, located at one of the villages. Devise an iterative improvement algorithm for this problem.
Solve the following linear programming problems geometrically. a. maximize 3x + y subject to -x + y 1 2x + y 4 x 0, y 0 b. maximize x + 2y subject to 4x y y 3+x x 0, y 0
Consider the linear programming problem minimize c1x + c2y subject to x+ y4 x+ 3y 6 x 0, y 0 where c1 and c2 are some real numbers not both equal to zero. Give an example of the coefficient values c1 and c2 for which the problem has a unique optimal solution.
Consider the linear programming problem minimize c1x + c2y subject to x+ y4 x+ 3y 6 x 0, y 0 where c1 and c2 are some real numbers not both equal to zero. Give an example of the coefficient values c1 and c2 for which the problem has infinitely many optimal solutions.
Consider the linear programming problem minimize c1x + c2y subject to x+ y4 x+ 3y 6 x 0, y 0 where c1 and c2 are some real numbers not both equal to zero. Give an example of the coefficient values c1 and c2 for which the problem does not have an optimal solution.
Trace the simplex method on a. the problem of Exercise 2a
Can we apply the simplex method to solve the knapsack problem (see Example 2 in Section 6.6)? If you answer yes, indicate whether it is a good algorithm for the problem in question; if you answer no, explain why not.
Prove that no linear programming problem can have exactly k 1 optimal solutions unless k =
Since maximum-flow algorithms require processing edges in both directions, it is convenient to modify the adjacency matrix representation of a network as follows. If there is a directed edge from vertex i to vertex j of capacity uij , then the element in the ith row and the j th column is set to uij , and the element in the j th row and the ith column is set to -uij ; if there is no edge between vertices i and j , both these elements are set to zero. Outline a simple algorithm for identifying a source and a sink in a network presented by such a matrix and indicate its time efficiency.
Apply the shortest-augmenting path algorithm to find a maximum flow and a minimum cut in the following networks.
Does the maximum-flow problem always have a unique solution?
Explain how the maximum-flow problem for a network with several sources and sinks can be transformed into the same problem for a network with a single source and a single sink.
Some networks have capacity constraints on the flow amounts that can flow through their intermediate vertices. Explain how the maximum-flow problem for such a network can be transformed to the maximum-flow problem for a network with edge capacity constraints only.
Consider a network that is a rooted tree, with the root as its source, the leaves as its sinks, and all the edges directed along the paths from the root to the leaves. Design an efficient algorithm for finding a maximum flow in such a network.
Prove that for any flow in a network and any cut in it, the value of the flow is equal to the flow across the cut.
Explain the relationship between this property and equality.
Express the maximum-flow problem for the network in Figure 10.4 as a linear programming problem.
Solve this linear programming problem by the simplex method.
As an alternative to the shortest-augmenting-path algorithm, Edmonds and Karp suggested the maximum-capacity-augmenting-path algorithm, in which a flow is augmented along the path that increases the flow by the largest amount. Implement both these algorithms in the language of your choice and perform an empirical investigation of their relative efficiency.
Dining problem: Several families go out to dinner together. To increase their social interaction, they would like to sit at tables so that no two members of the same family are at the same table. Show how to find a seating arrangement that meets this objective (or prove that no such arrangement exists) by using a maximum-flow problem. Assume that the dinner contingent has p families and that the ith family has ai members. Also assume that q tables are available and the j th table has a seating capacity of bj. For each matching shown below in bold, find an augmentation or explain why no augmentation exists.
Apply the maximum-matching algorithm to the following bipartite graph:
What is the largest and what is the smallest possible cardinality of a matching in a bipartite graph G = V, U, E with n vertices in each vertex set V and U and at least n edges?
What is the largest and what is the smallest number of distinct solutions the maximum-cardinality-matching problem can have for a bipartite graph G= V, U, E with n vertices in each vertex set V and U and at least n edges?
Hall's Marriage Theorem asserts that a bipartite graph G = V, U, E has a matching that matches all vertices of the set V if and only if for each subset S V , |R(S)| |S| where R(S) is the set of all vertices adjacent to a vertex in S. Check this property for the following graph with (i) V = {1, 2, 3, 4} and (ii) V = {5, 6, 7}.
You have to devise an algorithm that returns yes if there is a matching in a bipartite graph G = V, U, E that matches all vertices in V and returns no otherwise. Would you base your algorithm on checking the condition of Hall's Marriage Theorem?
Suppose there are five committees A, B, C, D, and E composed of six persons a, b, c, d, e, and f as follows: committee A's members are b and e; committee B's members are b, d, and e; committee C's members are a, c, d, e, and f ; committee D's members are b, d, and e; committee E's members are b and e. Is there a system of distinct representatives, i.e., is it possible to select a representative from each committee so that all the selected persons are distinct?
Show how the maximum-cardinality-matching problem for a bipartite graph can be reduced to the maximum-flow problem discussed in Section 10.2
Consider the following greedy algorithm for finding a maximum matching in a bipartite graph G= V , U, E . Sort all the vertices in nondecreasing order of their degrees. Scan this sorted list to add to the current matching (initially empty) the edge from the list's free vertex to an adjacent free vertex of the lowest degree. If the list's vertex is matched or if there are no adjacent free vertices for it, the vertex is simply skipped. Does this algorithm always produce a maximum matching in a bipartite graph?
Design a linear-time algorithm for finding a maximum matching in a tree.
Implement the maximum-matching algorithm of this section in the language of your choice.
Experiment with its performance on bipartite graphs with n vertices in each of the vertex sets and randomly generated edges (in both dense and sparse modes) to compare the observed running time with the algorithm's theoretical efficiency.
Domino puzzle: A domino is a 2 × 1 tile that can be oriented either horizontally or vertically. A tiling of a given board composed of 1 × 1 squares is covering it with dominoes exactly and without overlap. Is it possible to tile with dominoes an 8 × 8 board without two unit squares at its diagonally opposite corners?
Consider an instance of the stable marriage problem given by the following ranking matrix: AB C For each of its marriage matchings, indicate whether it is stable or not. For the unstable matchings, specify a blocking pair and for the stable matchings, indicate whether they are man-optimal, woman-optimal, or neither.
Design a simple algorithm for checking whether a given marriage matching is stable and determine its time efficiency class.
Find a stable marriage matching for the instance given in Problem 1 by applying the stable marriage algorithm a. in its men-proposing version. b. in its women-proposing version.
Find a stable marriage matching for the instance defined by the following ranking matrix:
Determine the time-efficiency class of the stable marriage algorithm a. in the worst case. b. in the best case.
Prove that a man-optimal stable marriage set is always unique.
Prove that in the man-optimal stable matching, each woman has the worst partner that she can have in any stable marriage matching.
Implement the stable-marriage algorithm given in Section 10.4 so that its running time is in O(n2).
Consider the problem of the roommates, which is related to but more difficult than the stable marriage problem: An even number of boys wish to divide up into pairs of roommates. A set of pairings is called stable if under it there are no two boys who are not roommates and who prefer each other to their actual roommates. Give an instance of this problem that does not have a stable pairing.
Prove that any algorithm solving the alternating-disk puzzle (Problem 14 in Exercises 3.1) must make at least n(n + 1)/2 moves to solve it.
Prove that the classic recursive algorithm for the Tower of Hanoi puzzle (Section 2.4) makes the minimum number of disk moves needed to solve the problem.
Find a trivial lower-bound class for each of the following problems and indicate, if you can, whether this bound is tight: a. finding the largest element in an array b. checking completeness of a graph represented by its adjacency matrix c. generating all the subsets of an n-element set d. determining whether n given real numbers are all distinct
Consider the problem of identifying a lighter fake coin among n identical looking coins with the help of a balance scale. Can we use the same information-theoretic argument as the one in the text for the number of questions in the guessing game to conclude that any algorithm for identifying the fake will need at least log2 n weighings in the worst case?
Prove that any comparison-based algorithm for finding the largest element of an n-element set of real numbers must make n 1 comparisons in the worst case.
Give an adversary-argument proof that the time efficiency of any algorithm that checks connectivity of a graph with n vertices is in(n2), provided the only operation allowed for an algorithm is to inquire about the presence of an edge between two vertices of the graph.
What is the minimum number of comparisons needed for a comparison-based sorting algorithm to merge any two sorted lists of sizes n and n + 1 elements, respectively?
Find the product of matrices A and B through a transformation to a product of two symmetric matrices if A= 1 -1 and B= 0 1 .2 3-1 2
Can one use this section's formulas that indicate the complexity equivalence of multiplication and squaring of integers to show the complexity equivalence of multiplication and squaring of square matrices?
Show that multiplication of two matrices of order n can be reduced to squaring a matrix of order 2n.
Find a tight lower-bound class for the problem of finding two closest numbers among n real numbers x1, x2, . . . , xn.
Find a tight lower-bound class for the number placement problem (Problem 9 in Exercises 6.1).
Prove by mathematical induction that a. h log2 l for any binary tree with height h and the number of leaves l. b. h log3 l for any ternary tree with height h and the number of leaves l.
Consider the problem of finding the median of a three-element set {a, b, c} of orderable items. a. What is the information-theoretic lower bound for comparison-based algorithms solving this problem?
Consider the problem of finding the median of a three-element set {a, b, c} of orderable items. Draw a decision tree for an algorithm solving this problem.
Consider the problem of finding the median of a three-element set {a, b, c} of orderable items. If the worst-case number of comparisons in your algorithm is greater than the information-theoretic lower bound, do you think an algorithm matching the lower bound exists? (Either find such an algorithm or prove its impossibility.)
Draw a decision tree and find the number of key comparisons in the worst and average cases for a. the three-element basic bubble sort. b. the three-element enhanced bubble sort (which stops if no swaps have been made on its last pass).
Design a comparison-based algorithm for sorting a four-element array with the smallest number of element comparisons possible.
Design a comparison-based algorithm for sorting a five-element array with seven comparisons in the worst case.
Draw a binary decision tree for searching a four-element sorted list by sequential search.
What is the information-theoretic lower bound for finding the maximum of n numbers by comparison-based algorithms?
A tournament tree is a complete binary tree reflecting results of a knockout tournament: its leaves represent n players entering the tournament, and each internal node represents a winner of a match played by the players represented by the node's children. Hence, the winner of the tournament is represented by the root of the tree. What is the total number of games played in such a tournament? How many rounds are there in such a tournament?
A tournament tree is a complete binary tree reflecting results of a knockout tournament: its leaves represent n players entering the tournament, and each internal node represents a winner of a match played by the players represented by the node's children. Hence, the winner of the tournament is represented by the root of the tree. Design an efficient algorithm to determine the second-best player using the information produced by the tournament.
How many extra games does your algorithm require?
Advanced fake-coin problem: There are n 3 coins identical in appearance; either all are genuine or exactly one of them is fake. It is unknown whether the fake coin is lighter or heavier than the genuine one. You have a balance scale with which you can compare any two sets of coins. That is, by tipping to the left, to the right, or staying even, the balance scale will tell whether the sets weigh the same or which of the sets is heavier than the other, but not by how much. The problem is to find whether all the coins are genuine and, if not, to find the fake coin and establish whether it is lighter or heavier than the genuine ones.
Prove that any algorithm for this problem must make at least log3(2n + 1) weighings in the worst case.
Draw a decision tree for an algorithm that solves the problem for n = 3 coins in two weighings.
Prove that there exists no algorithm that solves the problem for n = 4 coins in two weighings.
Draw a decision tree for an algorithm that solves the problem for n = 4 coins in two weighings by using an extra coin known to be genuine.
Draw a decision tree for an algorithm that solves the classic version of the problem--that for n = 12 coins in three weighings (with no extra coins being used).
Jigsaw puzzle: A jigsaw puzzle contains n pieces. A section of the puzzle is a set of one or more pieces that have been connected to each other. A move consists of connecting two sections. What algorithm will minimize the number of moves required to complete the puzzle?
A game of chess can be posed as the following decision problem: given a legal positioning of chess pieces and information about which side is to move, determine whether that side can win. Is this decision problem decidable?
Give examples of the following graphs or explain why such examples cannot exist. a. graph with a Hamiltonian circuit but without an Eulerian circuit b. graph with an Eulerian circuit but without a Hamiltonian circuit c. graph with both a Hamiltonian circuit and an Eulerian circuit d. graph with a cycle that includes all the vertices but with neither a Hamiltonian circuit nor an Eulerian circuit
In 2000, The Clay Mathematics Institute (CMI) of Cambridge, Massachusetts, designated a $1 million prize for the solution to this problem. For each of the following graphs, find its chromatic number.
Design a polynomial-time algorithm for the graph 2-coloring problem: determine whether vertices of a given graph can be colored in no more than two colors so that no two adjacent vertices are colored the same color.
Consider the following brute-force algorithm for solving the composite number problem: Check successive integers from 2 ton/2 as possible divisors of n. If one of them divides n evenly, return yes (i.e., the number is composite); if none of them does, return no. Why does this algorithm not put the problem in class P ?
State the decision version for each of the following problems and outline a polynomial-time algorithm that verifies whether or not a proposed solution solves the problem. (You may assume that a proposed solution represents a legitimate input to your verification algorithm.) a. knapsack problem b. bin packing problem
Show that the partition problem is polynomially reducible to the decision version of the knapsack problem.
Show that the following three problems are polynomially reducible to each other. (i) Determine, for a given graph G = V, E and a positive integer m |V |, whether G contains a clique of size m or more. (A clique of size k in a graph is its complete subgraph of k vertices.) (ii) Determine, for a given graph G =V, E and a positive integer m |V |, whether there is a vertex cover of size m or less for G. (A vertex cover of size k for a graph G = V, E is a subset VV such that |V | = k and, for each edge (u, v) E, at least one of u and v belongs to V .) (iii) Determine, for a given graph G = V, E and a positive integer m |V |, whether G contains an independent set of size m or more. (An independent set of size k for a graph G = V, E is a subset V V such that |V | = k and for all u, v V , vertices u and v are not adjacent in G.)
Determine whether the following problem is NP-complete. Given several sequences of uppercase and lowercase letters, is it possible to select a letter from each sequence without selecting both the upper and lowercase versions of any letter? For example, if the sequences are Abc, BC, aB, and ac, it is possible to choose A from the first sequence, B from the second and third, and c from the fourth. An example where there is no way to make the required selections is given by the four sequences AB, Ab, aB, and ab.
Which of the following diagrams do not contradict the current state of our knowledge about the complexity classes P, NP, and NPC (NP-complete problems)? a. b. P = NP P = NP = NPC NPC c.NP d. NP P NPC P NPC e.NP P NPC
King Arthur expects 150 knights for an annual dinner at Camelot. Unfortunately, some of the knights quarrel with each other, and Arthur knows who quarrels with whom. Arthur wants to seat his guests around a table so that no two quarreling knights sit next to each other. Which standard problem can be used to model King Arthur's task?
King Arthur expects 150 knights for an annual dinner at Camelot. Unfortunately, some of the knights quarrel with each other, and Arthur knows who quarrels with whom. Arthur wants to seat his guests around a table so that no two quarreling knights sit next to each other. As a research project, find a proof that Arthur's problem has a solution if each knight does not quarrel with at least 75 other knights.
Some textbooks define the number of significant digits in the approximation of number by number as the largest nonnegative integer k for which | | < 5 . 10-k. || According to this definition, how many significant digits are there in the approximation of by a. 3.1415? b. 3.1417?
If = 5 is known to approximate some number with the absolute error not exceeding 10-2, find a. the range of possible values of . b. the range of the relative errors of these approximations.
Find the approximate value of e = 648721 . . . obtained by the fifth-degree Taylor's polynomial about 0 and compute the truncation error of this approximation.
Derive formula (17) of the composite trapezoidal rule.
Use the composite trapezoidal rule with n = 4 to approximate the following definite integrals.
Find the truncation error of each approximation and compare it with the one given by formula (19). a.1 x2d x b.3 x-1d x
Solve the two systems of linear equations and indicate whether they are ill conditioned. a.2x + 5y = 7b. 2x + 5y = 7 2x + 5.000001y = 7.0000012x + 4.999999y = 7.000002
Write a computer program to solve the equation ax2 + bx + c = 0.
Prove that for any nonnegative number D, the sequence of Newton's method for computing D is strictly decreasing and converges to D for any value of the initial approximation x0 >D.
Prove that if 0.25 D < 1 and x0 = (1 + D)/2, no more than four iterations of Newton's method are needed to guarantee that |xn D| 4 . 10-15. <
Apply four iterations of Newton's method to compute 3 and estimate the absolute and relative errors of this approximation.
Continue the backtracking search for a solution to the four-queens problem, which was started in this section, to find the second solution to the problem.
Explain how the board's symmetry can be used to find the second solution to the four-queens problem.
Which is the last solution to the five-queens problem found by the backtracking algorithm?
Use the board's symmetry to find at least four other solutions to the problem.
Implement the backtracking algorithm for the n-queens problem in the language of your choice.
Run your program for a sample of n values to get the numbers of nodes in the algorithm's state-space trees. Compare these numbers with the numbers of candidate solutions generated by the exhaustive search algorithm for this problem (see Problem 9 in Exercises 3.4).
For each value of n for which you run your program in part (a), estimate the size of the state-space tree by the method described in Section 12.1 and compare the estimate with the actual number of nodes you obtained.
Design a linear-time algorithm that finds a solution to the n-queens problem for any n 4.
Apply backtracking to the problem of finding a Hamiltonian circuit in the following graph. a b cd e f g
Apply backtracking to solve the 3-coloring problem for the graph in Figure 12.3a
Generate all permutations of {1, 2, 3, 4} by backtracking.
Apply backtracking to solve the following instance of the subset sum problem: A = {1, 3, 4, 5} and d = 1
Will the backtracking algorithm work correctly if we use just one of the two inequalities to terminate a node as non promising?
The general template for backtracking algorithms, which is given in the section, works correctly only if no solution is a prefix to another solution to the problem. Change the template's pseudocode to work correctly without this restriction.
Write a program implementing a backtracking algorithm for a. the Hamiltonian circuit problem. b. the m-coloring problem.
Puzzle pegs: This puzzle-like game is played on a board with 15 small holes arranged in an equilateral triangle. In an initial position, all but one of the holes are occupied by pegs, as in the example shown below. A legal move is a jump of a peg over its immediate neighbor into an empty square opposite; the jump removes the jumped-over neighbor from the board. Design and implement a backtracking algorithm for solving the following version of this puzzle - Starting with a given location of the empty hole, find a shortest sequence of moves that eliminates 14 pegs with no limitations on the final position of the remaining peg.
Puzzle pegs: This puzzle-like game is played on a board with 15 small holes arranged in an equilateral triangle. In an initial position, all but one of the holes are occupied by pegs, as in the example shown below. A legal move is a jump of a peg over its immediate neighbor into an empty square opposite; the jump removes the jumped-over neighbor from the board. Design and implement a backtracking algorithm for solving the following versions of this puzzle - Starting with a given location of the empty hole, find a shortest sequence of moves that eliminates 14 pegs with the remaining peg at the empty hole of the initial board.
What data structure would you use to keep track of live nodes in a best-first branch-and-bound algorithm?
Solve the same instance of the assignment problem as the one solved in the section by the best-first branch-and-bound algorithm with the bounding function based on matrix columns rather than rows.
Give an example of the best-case input for the branch-and-bound algorithm for the assignment problem.
In the best case, how many nodes will be in the state-space tree of the branch-and-bound algorithm for the assignment problem?
Write a program for solving the assignment problem by the branch-and-bound algorithm.
Solve the following instance of the knapsack problem by the branch and bound algorithm: item weight value
Suggest a more sophisticated bounding function for solving the knapsack problem than the one used in the section.
Write a program to solve the knapsack problem with the branch-and-bound algorithm.
Prove the validity of the lower bound given by formula (12.2) for instances of the traveling salesman problem with symmetric matrices of integer intercity distances.
How would you modify lower bound (12.2) for non symmetric distance matrices?
Apply the branch-and-bound algorithm to solve the traveling salesman problem for the following graph: a 2 b (We solved this problem by exhaustive search in Section 3.4.)
Apply the nearest-neighbor algorithm to the instance defined by the intercity distance matrix below. Start the algorithm at the first city, assuming that the cities are numbered from 1 to 5.
Write pseudocode for the nearest-neighbor algorithm. Assume that its input is given by an n × n intercity distance matrix.
What is the time efficiency of the nearest-neighbor algorithm?
Apply the twice-around-the-tree algorithm to the graph in Figure 12.11a with a walk around the minimum spanning tree that starts at the same vertex a but differs from the walk in Figure 12.11b
What is the time efficiency class of the greedy algorithm for the knapsack problem?
Prove that the performance ratio RA of the enhanced greedy algorithm for the knapsack problem is equal to 2.
Consider the greedy algorithm for the bin-packing problem, which is called the first-fit (FF) algorithm: place each of the items in the order given into the first bin the item fits in; when there are no such bins, place the item in a new bin and add this bin to the end of the bin list.
Apply FF to the instance s1 = 0.4, s2 = 0.7,s3 = 0.2, s4 = 0.1, s5 = 0.5 and determine whether the solution obtained is optimal.
Determine the worst-case time efficiency of FF.
Prove that FF is a 2-approximation algorithm.
The first-fit decreasing (FFD) approximation algorithm for the bin-packing problem starts by sorting the items in non increasing order of their sizes and then acts as the first-fit algorithm. Apply FFD to the instance s1 = 0.4, s2 = 0.7,s3 = 0.2, s4 = 0.1, s5 = 0.5 and determine whether the solution obtained is optimal.
The first-fit decreasing (FFD) approximation algorithm for the bin-packing problem starts by sorting the items in non increasing order of their sizes and then acts as the first-fit algorithm. Does FFD always yield an optimal solution? Justify your answer.
The first-fit decreasing (FFD) approximation algorithm for the bin-packing problem starts by sorting the items in non increasing order of their sizes and then acts as the first-fit algorithm. Prove that FFD is a 5-approximation algorithm.
Run an experiment to determine which of the two algorithms--FFor FFD--yields more accurate approximations on a random sample of the problem's instances.
Design a simple 2-approximation algorithm for finding a minimum vertex cover (a vertex cover with the smallest number of vertices) in a given graph.
Consider the following approximation algorithm for finding a maximum independent set (an independent set with the largest number of vertices) in a given graph. Apply the 2-approximation algorithm of part (a) and output all the vertices that are not in the obtained vertex cover.
Design a polynomial-time greedy algorithm for the graph-coloring problem.