 j si c a. s si i i yo a de i c eofitfaller cqde hardware ! si z figure . device functionality progression implementation must be thoroughly debugged to avoid data corruption and system crashes. the highest performance may be obtained by a specialized implementation in hardware either in the device or in the controller. the disadvantages of a hardware implementation include the difficulty and expense of making further improvements or of fixing bugs the increased development time months rather than days and the decreased flexibility. for instance a hardware raid controller may not provide any means for the kernel to influence the order or location of individual block reads and writes even if the kernel has special information about the workload that would enable the kernel to improve the i o performance. . summary the basic hardware elements involved in i o are buses device controllers and the devices themselves. the work of moving data between devices and main memory is performed by the cpu as programmed i o or is offloaded to a dma controller. the kernel module that controls a device is a device driver. the system call interface provided to applications is designed to handle several basic categories of hardware including block devices character devices memory mapped files network sockets and programmed interval timers. the system calls usually block the process that issues them but nonblocking and asynchronous calls are used by the kernel itself and by applications that must not sleep while waiting for an t o operation to complete. the kernel's i o subsystem provides numerous services. among these are i o scheduling buffering caching spooling device reservation and error handling. another service name translation makes the connection between hardware devices and the symbolic file names used by applications. it involves several levels of mapping that translate from character string names to specific chapter i o systems device drivers and device addresses and then to physical addresses of l oports or bus controllers. this mapping may occur within the file system name space. as it does in unix or in a separate device name space as it does in ms dos. streams is an implementation and methodology for making drivers reusable and easy to use. through them drivers can be stacked with data passed through them sequentially and bidirectionally for processing. i o system calls are costly in terms of cpu consumption because of the many layers of software between a physical device and the application. these layers imply the overheads of context switching to cross the kernel's protection boundary of signal and interrupt handling to service the i o devices and of the load on the cpu and memory system to copy data between kernel buffers and application space. exercises . when multiple interrupts from different devices appear at about the same time a priority scheme could be used to determine the order in which the interrupts would be serviced. discuss what issues need to be considered in assigning priorities to different interrupts. . what are the advantages and disadvantages of supporting memorymapped i o to device control registers? . consider the following i o scenarios on a single user pc a. a mouse used with a graphical user interface b. a tape drive on a multitasking operating system with no device preallocation available c. a disk drive containing user files d. a graphics card with direct bus connection accessible through memory mapped i o for each of these scenarios would you design the operating system to use buffering spooling caching or a combination? would you use polled i o or interrupt driven i o? give reasons for your choices. . in most multiprogrammed systems user programs access memory through virtual addresses while the operating system uses raw physical addresses to access memory. what are the implications of this design on the initiation of i o operations by the user program and their execution by the operating system? . what are the various kinds of performance overheads associated with servicing an interrupt? . describe three circumstances under which blocking i o should be used. describe three circumstances under which nonblocking i o should be used. why not just implement nonblocking i o and have processes busv wait until their device is readv? bibliographical notes . typically at the completion of a device i o a single interrupt is raised and appropriately handled by the host processor. in certain settings however the code that is to be executed at the completion of the i o can be broken into two separate pieces one of which executes immediately after the i o completes and schedules a second interrupt for the remaining piece of code to be executed at a later time. what is the purpose of using this strategy in the design of interrupt handlers? . some dma controllers support direct virtual memory access where the targets of i o operations are specified as virtual addresses and a translation from virtual to physical address is performed during the dma. how does this design complicate the design of the dma controller? what are the advantages of providing such a functionality? . unix coordinates the activities of the kernel i o components by manipulating shared in kernel data structures whereas windows nt uses object oriented message passing between kernel i o components. discuss three pros and three cons of each approach. . write in pseudocode an implementation of virtual clocks including the queueing and management of timer requests for the kernel and applications. assume that the hardware provides three timer channels. . discuss the advantages and disadvantages of guaranteeing reliable transfer of data between modules in the streams abstraction. bibliographical notes vahalia provides a good overview of i o and networking in unix. leffler et al. detail the i o structures and methods employed in bsd unix. milenkovic discusses the complexity of i o methods and implementation. the use and programming of the various interprocesscommunication and network protocols in unix are explored in stevens . brain documents the windows t application interface. the i o implementation in the sample mln x operating system is described in tanenbaum and woodhull . custer includes detailed information on the nt message passing implementation of i o. for details of hardware level i o handling and memory mapping functionality processor reference manuals motorola and intel are among the best sources. hennessy and patterson describe multiprocessor systems and cache consistency issues. tanenbaum describes hardware i o design at a low level and sargent and shoemaker provide a programmer's guide to low level pc hardware and software. the ibm pc device i o address map is given in ibm . the march issue of ieee computer is devoted to advanced i o hardware and software. rago provides a good discussion of streams. part five