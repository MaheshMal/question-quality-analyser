 the xds system was constructed from a modified xds q. the modifications were typical of the changes made to a basic computer to allow an operating system to be written properly. a user monitor mode was added. certain instructions such as i o and halt were defined to be privileged. an attempt to execute a privileged instruction in user mode would trap to the operating system. a system call instruction was added to the user mode instruction set. this instruction was used to create new resources such as files allowing the operating system to manage the physical resources. files for example were allocated in word blocks on the drum. a bit map was used to manage free drum blocks. each file had an index block with pointers to the actual data blocks. index blocks were chained together. the xds system also provided system calls to allow processes to create start suspend and destroy subprocesses. a programmer could construct a system of processes. separate processes could share memory for communication and synchronization. process creation defined a tree structure where a process is the root and its subprocesses are nodes below it in the tree. each of the subprocesses could in turn create more subprocesses. . the the the operating system dijkstra mckeag and wilson was designed at the technische hogeschool at eindhoven in the netherlands. it was a batch system running on a dutch computer the el x with kb of bit words. the system was mainly noted for its clean design particularly its layer structure and its use of a set of concurrent processes employing semaphores for synchronization. unlike the xds system however the set of processes in the the system was static. the operating system itself was designed as a set of cooperating processes. in addition five user processes were created that served as the active agents to compile execute and print user programs. when one job was finished the process would return to the input queue to select another job. a priority cpu scheduling algorithm was used. the priorities were recomputed every seconds and were inversely proportional to the amount of cpu time used recently in the last to seconds . this scheme gave higher priority to o bound processes and to new processes. memory management was limited by the lack of hardware support. however since the system was limited and user programs could be written only in algol a software paging scheme was used. the algol compiler automatically generated calls to system routines wrhich made sure the requested information was in memory swapping if necessary. the backing store was a kb word drum. a word page was used with an l.ru page replacement strategy. another major concern of the the system was deadlock control. the banker's algorithm was used to provide deadlock avoidance. closely related to the the system is the venus system liskov . the venus system was also a layer structured design using semaphores to synchronize processes. the lower levels of the design were implemented in microcode however providing a much faster system. the memory management was chapter influential operating systems changed to a paged segmented memory. the system was also designed as a time sharing system rather than a batch system. . rc the rc system like the the system was notable primarily for its design concepts. it was designed for the danish computer by regnecentralen particularly by brinch hansen brinch hansen brindvhansen . the objective was not to design a batch system or a time sharing system or any other specific system. rather the goal was to create an operating system nucleus or kernel on which a complete operating system could be built. thus the system structure was layered and only the lower levels comprising the kernel were provided. the kernel supported a collection of concurrent processes. a round robin cpu scheduler was used. although processes could share memory the primary communication and synchronization mechanism was the message system provided by the kernel. processes could communicate with each other by exchanging fixed sized messages of eight words in length. all messages were stored in buffers from a common buffer pool. when a message buffer was no longer required it was returned to the common pool. a message queue was associated with each process. it contained all the messages that had been sent to that process but had not yet been received. messages were removed from the queue in fifo order. the system supported four primitive operations which were executed atomically send message in receiver in message out buffer wait message out sender out message out buffer send answer out result in message in buffer wait answer out result out message in buffer the last two operations allowed processes to exchange several messages at a time. these primitives required that a process service its message queue in fifo order and that it block itself while other processes were handling its messages. to remove these restrictions the developers provided two additional communication primitives that allowed a process to wait for the arrival of the next message or to answer and service its queue in any order wait event in previous buffer out next buffer out result get event out buffer i o devices were also treated as processes. the device drivers were code that converted the device interrupts and registers into messages. thus a process would write to a terminal by sending that terminal a message. the device driver would receive the message and output the character to the terminal. an input character would interrupt the system and transfer to