 site figure . augmented local wait for graph in site g of figure . . pcx pk pk ... pxu p it sends a deadlock detection message to another site only if id pku otherwise site s continues its normal execution leaving the burden of initiating the deadlock detection algorithm to some other site. to illustrate this scheme we consider again the wait for graphs maintained at sites si and s of figure . . suppose that id p id p let both sites discover these local cycles at about the same time. the cycle in site si is of the form pi p since site si does not send a deadlock detection message to site s . the cycle in site s is of the form since id p id p r site sj does send a deadlock detection message to site si which on receiving the message updates its local wait for graph. site si then searches for a cycle in the graph and discovers that the system is in a deadlocked state. . election algorithms as we pointed out in section . many distributed algorithms employ a coordinator process that performs functions needed by the other processes in the system. these functions include enforcing mutual exclusion maintaining a global wait for graph for deadlock detection replacing a lost token and controlling an input or output device in the system. if the coordinator process fails due to the failure of the site at which it resides the system can continue chapter distributed coordination execution only by restarting a new copy of the coordinator on some other site. the algorithms that determine where a new copy of the coordinator should be restarted are called election algorithms. election algorithms assume that a unique priority number is associated with each active process in the system. for ease of notation we assume that the priority number of process p is . to simplify our discussion we assume a one to one correspondence between processes and sites and thus refer to both as processes. the coordinator is always the process with the largest priority number. hence when a coordinator fails the algorithm must elect that active process with the largest priority number. this number must be sent to each active process in the system. in addition the algorithm must provide a mechanism for a recovered process to identify the current coordinator. in this section we present examples of election algorithms for two different configurations of distributed systems. the first algorithm applies to systems where every process can send a message to every other process in the system. the second algorithm applies to systems organized as a ring logically or physically . both algorithms require n messages for an election where n is the number of processes in the system. we assume that a process that has failed knows on recovery that it has indeed failed and thus takes appropriate actions to rejoin the set of active processes. . . the bully algorithm suppose that process p sends a request that is not answered by the coordinator within a time interval t. in this situation it is assumed that the coordinator has failed and p tries to elect itself as the new coordinator. this task is completed through the following algorithm process p sends an election message to every process with a higher priority number. process p then waits for a time interval t for an answer from any one of these processes. if no response is received within time t p assumes that all processes with numbers greater than have failed and elects itself the new coordinator. process p restarts a new copy of the coordinator and sends a message to inform all active processes with priority numbers less than that p is the new coordinator. however if an answer is received p begins a time interval t waiting to receive a message informing it that a process with a higher priority number has been elected. that is some other process is electing itself coordinator and should report the results within time t. if no message is sent within t then the process with a higher number is assumed to have failed and process p should restart the algorithm. if pi is not the coordinator then at any time during execution p may receive one of the following two messages from process p . pj is the new coordinator j . process p in turn records this information. . pj has started an election j i . process p sends a response to pj and begins its own election algorithm provided that p has not already initiated such an election. the process that completes its algorithm has the highest number and is elected as the coordinator. it has sent its number to all active processes with smaller . election algorithms numbers. after a failed process recovers it immediately begins execution of the same algorithm. if there are no active processes with higher numbers the recovered process forces all processes with lower numbers to let it become the coordinator process even if there is a currently active coordinator with a lower number. for this reason the algorithm is termed the bully algorithm. we can demonstrate the operation of the algorithm with a simple example of a system consisting of processes pi through pj. the operations are as follows . all processes are active p is the coordinator process. . pt and p fail. p determines that p has failed by sending a request that is not answered within time t. p then begins its election algorithm by sending a request to p . . p receives the request responds to p and begins its own algorithm by sending an election request to p . . pi receives pa's response and begins waiting for an interval t'. . pi does not respond within an interval t so p elects itself the new coordinator and sends the number to p and pi. pi does not receive the number since it has failed. . later when p recovers it sends an election request to p? p and p . . p and p respond to pi and begin their own election algorithms. p will again be elected through the same events as before. . finally p recovers and notifies pi pj and p that it is the current coordinator. p sends no election requests since it is the process with the highest number in the system. . . the ring algorithm the ring algorithm assumes that the links are unidirectional and that each process sends its messages to the neighbor on the right. the main data structure used by the algorithm is the active list a list that contains the priority numbers of all active processes in the system when the algorithm ends each process maintains its own active list. the algorithm works as follows . if process p detects a coordinator failure it creates a new active list that is initially empty. it then sends a message elect i to its right neighbor and adds the number to its active list. . if pj receives a message electij from the process on the left it must respond in one of three ways a. if this is the first elect message it has seen or sent p creates a new active list with the numbers i and . it then sends the message ekct i followed by the message elect j . b. if i that is the message received does not contain p.'s number then pj adds to its active list and forwards the message to its right neighbor. chapter distributed coordination c. if that is pi receives the message eled i then the active list for p now contains the numbers of all the active processes in the system. process p can now determine the largest number in the active list to identify the new coordinator process. this algorithm does not specify how a recovering process determines the number of the current coordinator process. one solution requires a recovering process to send an inquiry message. this message is forwarded around the ring to the current coordinator which in turn sends a reply containing its number