 files store information. when it is used this information must be accessed and read into computer memory. the information in the file can be accessed in several ways. some systems provide only one access method for files. other systems such as those of ibm support many access methods and choosing the right one for a particular application is a major design problem. . . sequential access the simplest access method is sequential access. information in the file is processed in order one record after the other. this mode of access is by far the . access methods beginning current position end rewind read or write s figure . sequential access file. most common for example editors and compilers usually access files in this fashion. reads and writes make up the bulk of the operations on a file. a read operation read next reads the next portion of the file and automatically advances a file pointer which tracks the i o location. similarly the write operation write next appends to the end of the file and advances to the end of the newly written material the new end of file . such a file can be reset to the beginning and on some systems a program .may be able to skip forward or backward n records for some integer n perhaps only for n . sequential access which is depicted in figure . is based on a tape model of a file and works as well on sequential access devices as it does on random access ones. . . direct access another method is direct access or relative access . a file is made up of fixedlength logical records that allow programs to read and write records rapidly in no particular order. the direct access method is based on a disk model of a file since disks allow random access to any file block. for direct access the file is viewed as a numbered sequence of blocks or records. thus we may read block then read block and then write block . there are no restrictions on the order of reading or writing for a direct access file. direct access files are of great use for immediate access to large amounts of information. databases are often of this type. when a query concerning a particular subject arrives we compute which block contains the answer and then read that block directly to provide the desired information. as a simple example on an airline reservation system we might store all the information about a particular flight for example flight in the block identified by the flight number. thus the number of available seats for flight is stored in block of the reservation file. to store information about a larger set such as people we might compute a hash function on the people's names or search a small in memory index to determine a block to read and search. for the direct access method the file operations must be modified to include the block number as a parameter. thus we have read n where n is the block number rather than read next and write n rather than write next. an alternative approach is to retain read next and write next as with sequential access and to add an operation position file to n where n is the block number. then to effect a read n we would position to n and then read next. the block number provided by the user to the operating system is normally a relative block number. a relative block number is an index relative to the chapter file system interface equgfrtia aecess i i a impternantatloa loi d reset a . a limt l readnexl a n a h re ad cp'f x f i ' t ... . . . . . . .t jl. . x j . . ' a i i a n figure . simulation of sequential access on a direct accsss file. beginning of the file. thvis the first relative block of the file is the next is and so on even though the actual absolute disk address of the block may be for the first block and for the second. the use of relative block numbers allows the operating system to decide where the file should be placed called the allocation problem as discussed in chapter and helps to prevent the user from accessing portions of the file system that may not be part of her file. some systems start their relative block numbers at others start at . how then does the system satisfy a request for record n in a file? assuming we have a logical record length l the request for record a is turned into an i o request for l bytes starting at location l n within the file assuming the first record is n . since logical records are of a fixed size it is also easy to read write or delete a record. not all operating systems support both sequential and direct access for files. some systems allow only sequential file access others allow only direct access. some systems require that a file be defined as sequential or direct when it is created such a file can be accessed only in a manner consistent with its declaration. we can easily simulate sequential access on a direct access file by simply keeping a variable cp that defines our current position as shown in figure . . simulating a direct access file on a sequential access file however is extremely inefficient and clumsy. . . other access methods other access methods can be built on top of a direct access method. these methods generally involve the construction of an index for the file. the index like an index in the back of a book contains pointers to the various blocks. to find a record in the file we first search the index and then use the pointer to access the file directly and to find the desired record. for example a retail price file might list the universal product codes upcs for items with the associated prices. each record consists of a digit upc and a digit price for a byte record if our disk has bytes per block we can store records per block. a file of records would occupy about blocks million bytes . by keeping the file sorted by upc we can define an index consisting of the first upc in each block. this index would have entries of digits each or bytes and thus could be kept in memory to find the price of a particular item we can make a binary search of the index. from this search we learn exactly which block contains the desired record and access that block. this structure allows us to search a large file doing little i o