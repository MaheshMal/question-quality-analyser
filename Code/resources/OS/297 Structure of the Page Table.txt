 .! ig . . . ' i m page table forp ed process p. ed ed ed data page table for p data process p bata page table for p process p figure . sharing of code in a paging environment. of interprocess communication. some operating systems implement shared memory using shared pages. organizing memory according to pages provides numerous benefits in addition to allowing several processes to share the same physical pages. we will cover several other benefits in chapter . structure of the page table in this section we explore some of the most common techniques for structuring the page table. . . hierarchical paging most modern computer systems support a large logical address space to . in such an environment the page table itself becomes excessively large. for example consider a system with a bit logical address space. if the page size in such a system is kb then a page table may consist of up to million entries j . assuming that each entry consists of bytes each process may need up to mb of physical address space for the page table alone. clearly we would not want to allocate the page table contiguously in main memory. one simple solution to this problem is to divide the page table into smaller pieces. we can accomplish this division in several ways. one way is to use a two level paging algorithm in which the page table itself is also paged figure . . remember our example of a bit machine chapter s main memory page table memory figure . a two level page table scheme. with a page size of kb. a logical address is divided into a page number consisting of bits and a page offset consisting of bits. because we page the page table the page number is further divided into a bit page number and a bit page offset. thus a logical address is as follows page number page offset where p is an index into the outer page table and p is the displacement within the page of the outer page table. the address translation method for this architecture is shown in figure . . because address translation works from the outer page table inward this scheme is also known as a forward mapped page table. the vax architecture also supports a variation of two level paging. the vax is a bit machine with a page size of bytes. the logical address space of a process is divided into four equal sections each of which consists of ' bytes. each section represents a different part of the logical address space of a process. the first high order bits of the logical address designate the appropriate section. the next bits represent the logical page number of that section and the final bits represent an offset in the desired page. by partitioning the page . structure of the page table logical address c. jliuulj ! . . . . . . outer page i i table page of page table figure . address translation for a two level bit paging architecture. table in this manner the operating system can leave partitions unused until a process needs them. an address on the vax architecture is as follows section page offset where s designates the section number p is an index into the page table and d is the displacement within the page. even when this scheme is used the size of a one level page table for a vax process using one section is bits bytes per entry mb. so that main memory use is reduced further the vax pages the user process page tables. for a system with a bit logical address space a two level paging scheme is no longer appropriate. to illustrate this point let us suppose that the page size in such a system is kb . in this case the page table consists of up to entries. if we use a two level paging scheme then the inner page tables can conveniently be one page long or contain byte entries. the addresses look like this outer page inner page offset the outer page table consists of entries or bytes. the obvious way to avoid such a large table is to divide the outer page table into smaller pieces. this approach is also used on some bit processors for added flexibility and efficiency. we can divide the outer page table in various ways. we can page the outer page table giving us a three level paging scheme. suppose that the outer page table is made up of standard size pages k! entries or ! bytes a bit address space is still daunting nd outer page outer page inner page offset the outer page table is still bytes in size. chapter main memory the next step would be a four level paging scheme where the secondlevel outer page table itself is also paged. the sparc architecture with bit addressing supports a three level paging scheme whereas the bit motorola architecture supports a four level paging scheme. for bit architectures hierarchical page tables are generally considered inappropriate. for example the bit ultrasparc would require seven levels of paging a prohibitive number of memory accesses to translate each logical address. . . hashed page tables a common approach for handling address spaces larger than bits is to use a hashed page table with the hash value being the virtual page number. each entry in the hash table contains a linked list of elements that hash to the same location to handle collisions . each element consists of three fields the virtual page number the value of the mapped page frame and a pointer to the next element in the linked list. the algorithm works as follows the virtual page number in the virtual address is hashed into the hash table. the virtual page number is compared with field in the first element in the linked list. if there is a match the corresponding page frame field is used to form the desired physical address. if there is no match subsequent entries in the linked list are searched for a matching virtual page number. this scheme is shown in figure . . a variation of this scheme that is favorable for bit address spaces has been proposed. this variation uses clustered page tables which are similar to hashed page tables except that each entry in the hash table refers to several pages such as rather than a single page. therefore a single page table entry can store the mappings for multiple physical page frames. clustered page tables are particularly useful for sparse address spaces where memory references are noncontiguous and scattered throughout the address space. logical address physical memory hash table figure . hashed page table. structure of the page table logical physical address address gpu physical d p d memon search page table figure . inverted page table. . . inverted page tables usually each process has an associated page table. the page table has one entry for each page that the process is using or one slot for each virtual address regardless of the latter's validity . this table representation is a natural one since processes reference pages through the pages' virtual addresses. the operating system must then translate this reference into a physical memory address. since the table is sorted by virtual address the operating system is able to calculate where in the table the associated physical address entry is and to use that value directly. one of the drawbacks of this method is that each page table may consist of millions of entries. these tables may consume large amounts of physical memory just to keep track of how other physical memory is being used. to solve this problem we can. use an inverted page table. an inverted page table has one entry for each real page or frame of memory. each entry consists of the virtual address of the page stored in that real memory location with information about the process that owns that page. thus only one page table is in the system and it has only one entry for each page of physical memory. figure . shows the operation of an inverted page table. compare it with figure . which depicts a standard page table in operation. inverted page tables often require that an address space identifier section . . be stored in each entry of the page table since the table usually contains several different address spaces mapping physical memory. storing the address space identifier ensures that a logical page for a particular process is mapped to the corresponding physical page frame. examples of systems using inverted page tables include the bit ultrasparc and powerpc. to illustrate this method we describe a simplified version of the inverted page table used in the ibm rt. each virtual address in the system consists of a triple process id page number offset . chapter s main memoryeach inverted page table entry is a pair process id page number where the process id assumes the role of the address space identifier. when a memory reference occurs part of the virtual address consisting of process id pagenumber is presented to the memory subsystem. the inverted page table is then searched for a match. if a match is found say at entry then the physical address i or'fset is generated. if no match is found then an illegal address access has been attempted. although this scheme decreases the amount of memory needed to store each page table it increases the amount of time needed to search the table when a page reference occurs. because the inverted page table is sorted by physical address but lookups occur on virtual addresses the whole table might need to be searched for a match. this search would take far too long. to alleviate this problem we use a hash table as described in section . . to limit the search to one or at most a few page table entries. of course each access to the hash table adds a memory reference to the procedure so one virtual memoryreference requires at least two real memory reads one for the hash table entry and one for the page table. to improve performance recall that the tlb is searched first before the hash table is consulted. systems that use inverted page tables have difficulty implementing shared memory. shared memory is usually implemented as multiple virtual addresses one for each process sharing the memory that are mapped to one physical address. this standard method cannot be used with inverted page tables because there is only one virtual page entry for every physical page one physical page cannot have two or more shared virtual addresses. a simple technique for addressing this issue is to allow the page table to contain only one mapping of a virtual address to the shared physical address. this means that references to virtual addresses that are not mapped result in page faults