 into one process. all of these approaches contribute to a dramatic reduction in system boot time. of course system boot time is less important than it once was because of the sleep and hibernation capabilities of windows xp which allow users to power down their computers and then quickly resume where they left off. . environmental subsystems environmental subsystems are user mode processes layered over the native windows xp executive services to enable windows xp to run programs developed for other operating systems including bit windows ms dos and posix. each environmental subsystem provides a single application environment. windows xp uses the win api subsystem as the main operating environment and thus this subsystem starts all processes. when an application is executed the win api subsystem calls the vm manager to load the application's executable code. the memory manager returns a status to win indicating the type of executable. if it is not a native win api executable the win api environment checks whether the appropriate environmental subsystem is running if the subsystem is not running it is started as a user mode process. the subsystem then takes control over the application startup. the environmental subsystems use the lpc facility to provide operatingsystem services to client processes. the windows xp subsystem architecture keeps applications from mixing api routines from different environments. for instance a win api application cannot make a posix system call because only one environmental subsystem can be associated with each process. since each subsystem is run as a separate user mode process a crash in one has no effect on other processes. the exception is win api which provides all keyboard mouse and graphical display capabilities. if it fails the system is effectively disabled and requires a reboot. the win api environment categorizes applications as either graphical or character based where a character based application is one that thinks interactive output goes to a character based command window. win api transforms the output of a character based application to a graphical representation in the command window. this transformation is easy whenever an output routine is called the environmental subsystem calls a win routine to display the text. since the win api environment performs this function for all characterbased windows it can transfer screen text between windows via the clipboard. this transformation works for ms dos applications as well as for posix command line applications. . . ms dos environment the ms dos environment does not have the complexity of the other windows xp environmental subsystems. it is provided by a win api application called the virtual dos machine vdm . since the vdm is a user mode process it is paged and dispatched like any other windows xp application. the vdm has an instruction execution unit to execute or emulate intel instructions. the vdm also provides routines to emulate the ms dos rom bios and chapter windows xp int software interrupt services and has virtual device drivers for the screen keyboard and communication ports. the vdm is based on ms dos . source code it allocates at least kb of memory to the application. the windows xp command shell is a program that creates a window that looks like an ms dos environment. it can run both bit and bit executables. when an ms dos application is run the command shell starts a vdm process to execute the program. if windows xp is running on a ia compatible processor ms dos graphical applications run in full screen mode and character applications can run full screen or in a window. not all ms dos applications run under the vdm. for example some ms dos applications access the disk hardware directly so they fail to run on windows xp because disk access is restricted to protect the file system. in general ms dos applications that directly access hardware will fail to operate under windows xp. since ms dos is not a multitasking environment some applications have been written in such a way as to hog the cpu. for instance the use of busy loops can cause time delays or pauses in execution. the scheduler in the kernel dispatcher detects such delays and automatically throttles the cpu usage but this may cause the offending application to operate incorrectly. . . bit windows environment the winl execution environment is provided by a vdm that incorporates additional software called windows on windows wow for bit applications this software provides the windows . kernel routines and stub routines for window manager and graphical device interface gdi functions. the stub routines call the appropriate win api subroutines converting or thunking bit addresses into bit addresses. applications that rely on the internal structure of the bit window manager or gdi may not work because the underlying win api implementation is of course different from true bit windows. wow can multitask with other processes on windows xp but it resembles windows . in many ways. only one winl application can run at a time all applications are single threaded and reside in the same address space and all share the same input queue. these features imply that an application that stops receiving input will block all the other winl applications just as in windows .x and one winl application can crash other winl applications by corrupting the address space. multiple winl environments can coexist however by using the command start separate wml application from the command line. there are relatively few bit applications that users need to continue to run on windows xp but some of them include common installation setup programs. thus the wow environment continues to exist primarily because a number of bit applications cannot be installed on windows xp without it. . . bit windows environment on ia the native environment for windows on ia uses bit addresses and the native ia instruction set. to execute ia programs in this environment requires a thunking layer to translate bit win api calls into the corresponding bit calls just as bit applications require translation on ia systems. . environmental subsystems thus bit windows supports the wow environment. the implementations of bit and bit windows are essentially identical and the ia processor provides direct execution of ia instructions so wow achieves a higher level of compatibility than vvow . . . win environment the main subsystem in windows xp is the win api. it runs win api applications and manages all keyboard mouse and screen i o. since it is the controlling environment it is designed to be extremely robust. several features of the win api contribute to this robustness. unlike processes in the winl environment each win process has its own input queue. the window manager dispatches all input on the system to the appropriate process's input queue so a failed process does not block input to other processes. the windows xp kernel also provides preemptive multitasking which enables the user to terminate applications that have failed or are no longer needed. the win api also validates all objects before using them to prevent crashes that could otherwise occur if an application tried to use an invalid or wrong handle. the win api subsystem verifies the type of the object to which a handle points before using the object. the reference counts kept by the object manager prevent objects from being deleted while they are still being vised and prevent their use after they have been deleted. to achieve a high level of compatibility with windows systems windows xp allows users to specify that individual applications be run using a shim layer which modifies the win api to better approximate the behavior expected by old applications. for example some applications expect to see a particular version of the system and fail on new versions. frequently applications have latent bugs that become exposed due to changes in the implementation. for example using memory after freeing it may cause corruption only if the order of memory reuse by the heap changes or an application may make assumptions about which errors can be returned by a routine or about the number of valid bits in an address. running an application with the windows shims enabled causes the system to provide behavior much closer to windows though with reduced performance and limited interoperability with other applications. . . posix subsystem the posix subsystem is designed to run posix applications written to follow the posix standard which is based on the unix model. posix applications can be started by the win api subsystem or by another posix application. posix applications use the posix subsystem server psxss.exe the posix dynamic link library psxdll .dll and the posix console session manager posix .exe. although the posix standard does not specify printing posix applications can use printers transparently via the windows xp redirection mechanism. posix applications have access to any file system on the windows xp system the posix environment enforces unix like permissions on directory trees. due to scheduling issues the posix system in windows xp does not ship with the system but is available separately for professional desktop systems and servers. it provides a much higher level of compatibility with unix applications than previous versions of nt. of the commonly available unix chapter windows xp applications most compile and run without change with the latest version of interix. . . logon and security subsystems before a user can access objects on windows xp that user must be authenticated by the logon sendee winlogon. winlogon is responsible for responding to the secure attention sequence control alt delete . the secure attention sequence is a required mechanism for keeping an application from acting as a trojan horse. only winlogon can intercept this sequence in order to put up a logon screen change passwords and lock the workstation. to be authenticated a user must have an account and provide the password for that account. alternatively a user logs on by using a smart card and personal identification number subject to the security policies in effect for the domain. the local security authority subsystem lsass is the process that generates access tokens to represent users on the system. it calls an authentication package to perform authentication using information from the logon subsystem or network server. typically the authentication package simply looks up the account information in a local database and checks to see that the password is correct. the security subsystem then generates the access token for the user id containing the appropriate privileges quota limits and group ids. whenever the user attempts to access an object in the system such as by opening a handle to the object the access token is passed to the security reference monitor which checks privileges and quotas. the default authentication package for windows xp domains is kerberos. lsass also has the responsibility for implementing security policy such as strong passwords for authenticating users and for performing encryption of data and keys