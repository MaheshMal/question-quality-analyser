 . naming and transparency naming is a mapping between logical and physical objects. for instance users deal with logical data objects represented by file names whereas the system manipulates physical blocks of data stored on disk tracks. usually a user refers to a file by a textual name. the latter is mapped to a lower level numerical identifier that in turn is mapped to disk blocks. this multilevel mapping provides users with an abstraction of a file that hides the details of how and where on the disk the file is stored. in a transparent dfs a new dimension is added to the abstraction that of hiding where in the network the file is located. in a conventional file system the range of the naming mapping is an address within a disk. in a dfs this range is expanded to include the specific machine on whose disk the file is stored. going one step further with the concept of treating files as abstractions leads to the possibility of file replication. given a file name the mapping returns a set of the locations of this file's replicas. in this abstraction both the existence of multiple copies and their locations are hidden. . . naming structures we need to differentiate two related notions regarding name mappings in a dfs . location transparency. the name of a file does not reveal any hint of the file's physical storage location. . location independence. the name of a file does not need to be changed when the file's physical storage location changes. both definitions are relative to the level of naming discussed previously since files have different names at different levels that is user level textual names and system level numerical identifiers . a location independent naming scheme is a dynamic mapping since it can map the same file name to different locations at two different times. therefore location independence is a stronger property than is location transparency. in practice most of the current dfss provide a static location transparent mapping for user level names. these systems however do not support file migration that is changing the location of a file automatically is impossible. hence the notion of location independence is irrelevant for these systems. files are associated permanently with a specific set of disk blocks. files and disks can be moved between machines manually but file migration implies an automatic operating system initiated action. only afs and a few experimental file systems support location independence and file mobility. afs supports file mobility mainly for administrative purposes. a protocol provides migration of afs component units to satisfy high level user requests without changing either the user level names or the low level names of the corresponding files. a few aspects can further differentiate location independence and static location transparency divorce of data from location as exhibited by location independence provides a better abstraction for files. a file name should denote the file's chapter distributed file systems most significant attributes which are its contents rather than its location. location independent files can be viewed as logical data containers that are not attached to a specific storage location. if only static location transparency is supported the file name still denotes a specific although hidden set of physical disk blocks. static location transparency provides users with a convenient way to share data. users can share remote files by simply naming the files in a locationtransparent manner as though the files were local. nevertheless sharing the storage space is cumbersome because logical names are still statically attached to physical storage devices. location independence promotes sharing the storage space itself as well as the data objects. when files can be mobilized the overall system wide storage space looks like a single virtual resource. a possible benefit of such a view is the ability to balance the utilization of disks across the system. location independence separates the naming hierarchy from the storagedevices hierarchy and from the intercomputer structure. by contrast if static location transparency is used although names are transparent we can easily expose the correspondence between component units and machines. the machines are configured in a pattern similar to the naming structure. this configuration may restrict the architecture of the system unnecessarily and conflict with other considerations. a server in charge of a root directory is an example of a structure that is dictated by the naming hierarchy and contradicts decentralization guidelines. once the separation of name and location has been completed clients can access files residing on remote server systems. in fact these clients may be diskless and rely on servers to provide all files including the operatingsystem kernel. special protocols are needed for the boot sequence however. consider the problem of getting the kernel to a diskless workstation. the diskless workstation has no kernel so it cannot use the dfs code to retrieve the kernel. instead a special boot protocol stored in read only memory rom on the client is invoked. it enables networking and retrieves only one special file the kernel or boot code from a fixed location. once the kernel is copied over the network and loaded its dfs makes all the other operating system files available. the advantages of diskless clients are many including lower cost because the client machines require no disks and greater convenience when an operating system upgrade occurs only the server needs to be modified . the disadvantages are the added complexity of the boot protocols and the performance loss resulting from the use of a network rather than a local disk. the current trend is for clients to use both local disks and remote file servers. operating systems and networking software are stored locally file systems containing user data and possibly applications are stored on remote file systems. some client systems may store commonly used applications such as word processors and web browsers on the local file system as well. other less commonly used applications may be pushed from the remote file server to the client on demand. the main reason for providing clients with local file systems rather than pure diskless systems is that disk drives are rapidly increasing in capacity and decreasing in cost with new generations appearing every year or so. the same cannot be said for networks which evolve every few years. . naming and transparency overall systems are growing more quickly than are networks so extra work is needed to limit network access to improve system throughput. . . naming schemes there are three main approaches to naming schemes in a dfs. in the simplest approach a file is identified by some combination of its host name and local name which guarantees a unique system wide name. in ibis for instance a file is identified uniquely by the name host local name where local name is a umx like path. this naming scheme is neither location transparent nor location independent. nevertheless the same file operations can be used for both local and remote files. the dfs is structured as a collection of isolated component units each of which is an entire conventional file system. in this first approach component units remain isolated although means are provided to refer to a remote file. we do not consider this scheme any further in this text. the second approach was popularized by sun's network file system nfs . nfs is the file system component of onc a networking package supported by many unix vendors. nfs provides a means to attach remote directories to local directories thus giving the appearance of a coherent directory tree. early nfs versions allowed only previously mounted remote directories to be accessed transparently. with the advent of the automount feature mounts are done on demand based on a table of mount points and file structure names. components are integrated to support transparent sharing although this integration is limited and is not uniform because each machine may attach different remote directories to its tree. the resulting structure is versatile. we can achieve total integration of the component file systems by using the third approach. a single global name structure spans all the files in the system. ideally the composed file system structure is isomorphic to the structure of a conventional file system. in practice however the many special files for example unix device files and machine specific binary directories make this goal difficult to attain. to evaluate naming structures we look at their administrative complexity. the most complex and most difficult to maintain structure is the nfs structure. because any remote directory can be attached anywhere onto the local directory tree the resulting hierarchy can be highly unstructured. if a server becomes unavailable some arbitrary set of directories on different machines becomes unavailable. in addition a separate accreditation mechanism controls which machine is allowed to attach which directory to its tree. thus a user might be able to access a remote directory tree on one client but be denied access on another client. . . implementation techniques implementation of transparent naming requires a provision for the mapping of a file name to the associated location. to keep this mapping manageable we must aggregate sets of files into component units and provide the mapping on a component unit basis rather than on a single file basis. this aggregation serves administrative purposes as well. unix like systems use the hierarchical directory tree to provide name to location mapping and to aggregate files recursively into directories. chapter distributed file systems to enhance the availability of the crucial mapping information we ca n use replication local caching or both. as we noted location independence means that the mapping changes over time hence replicating the mapping makes a simple yet consistent update of this information impossible. a technique to overcome this obstacle is to introduce low level location independent file identifiers. textual file names are mapped to lower level file identifiers that indicate to which component unit the file belongs. these identifiers are still location independent. they can be replicated and cached freely without being invalidated by migration of component units. the inevitable price is the need for a second level of mapping which maps component units to locations and needs a simple yet consistent update mechanism. implementing unix like directory trees using these low level location independent identifiers makes the whole hierarchy invariant under component unit migration. the only aspect that does change is the component unit location mapping. a common way to implement low level identifiers is to use structured names. these names are bit strings that usually have two parts. the first part identifies the component unit to which the file belongs the second part identifies the particular file within the unit. variants with more parts are possible. the invariant of structured names however is that individual parts of the name are unique at all times only within the context of the rest of the parts. we can obtain uniqueness at all times by taking care not to reuse a name that is still used by adding sufficiently more bits this method is used in afs or by using a timestamp as one part of the name as done in apollo domain . another way to view this process is that we are taking a location transparent system such as ibis and adding another level of abstraction to produce a location independent naming scheme. aggregating files into component units and using lower level locationindependent file identifiers are techniques exemplified in afs