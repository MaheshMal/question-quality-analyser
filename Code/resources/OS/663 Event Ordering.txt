 in a centralized system we can always determine the order in which two events occurred since the system has a single common memory and clock. many applications may require us to determine order. for example in a resourceallocation scheme we specify that a resource can be used only after the resource has been granted. a distributed system however has no common memory and no common clock. therefore it is sometimes impossible to say which of two events occurred first. the liappened before relation is only a partial ordering of the events in distributed systems. since the ability to define a total ordering is chapter distributed coordination crucial in many applications we present a distributed algorithm for exterfding the happened before relation to a consistent total ordering of all the events in the system. . . the happened before relation since we are considering only sequential processes all events executed in a single process are totally ordered. also by the law of causality a message can be received only after it has been sent. therefore we can define the happenedbefore relation denoted by on a set of events as follows assuming that sending and receiving a message constitutes an event . if a and b are events in the same process and a was executed before b then a b. . if a is the event of sending a message by one process and b is the event of receiving that message by another process then a b. . if a b and b c then a c. since an event cannot happen before itself the relation is an irreflexive partial ordering. if two events a and b are not related by the relation that is a did not happen before b and b did not happen before a then we say that these two events were executed concurrently. in this case neither event can causally affect the other. if however a b then it is possible for event a to affect event b causally. a space time diagram such as that in figure . can best illustrate the definitions of concurrency and happened before. the horizontal direction represents space that is different processes and the vertical direction represents time. the labeled vertical lines denote processes or processors . the labeled dots denote events. a wavy line denotes a message sent from one process to another. events are concurrent if and only if no path exists between them. for example these are some of the events related by the happened before relation in figure . p ? since p c i and q i these are some of the concurrent events in the system q a n d p 'oandcj rq and p ? and p. we cannot know which of two concurrent events such as qo and pi happened first. however since neither event can affect the other there is no way for one of them to know whether the other has occurred yet it is not important which . event ordering figure . relative time for three concurrent processes. happened first. it is important only that any processes that care about the order of two concurrent events agree on some order. . . implementation to determine that an event a happened before an event b we need either a common clock or a set of perfectly synchronized clocks. since neither of these is available in a distributed system we must define the happened before relation without the use of physical clocks. we associate with each system event a timestamp. we can then define the global ordering requirement for every pair of events a and b if a b then the timestamp of a is less than the timestamp of b. below we will see that the converse need not be true. how do we enforce the global ordering requirement in a distributed environment? we define within each process p a logical clock lq. the logical clock can be implemented as a simple counter incremented between any two successive events executed within a process. since the logical clock has a monotonically increasing value it assigns a unique number to every event and if an event a occurs before event b in process p then lc a lc b . the timestamp for an event is the value of the logical clock for that event. this scheme enstires that for any two events in the same process the global ordering requirement is met. unfortunately this scheme does not ensure that the global ordering requirement is met across processes. to illustrate the problem consider two processes pi and p that communicate with each other. suppose that pi sends a message to pi event a with lci a and pi receives the message event b with lcjib because the processor for p is slower than the processor for p r its logical clock ticks more slowly . this situation violates our requirement since a b but the timestamp of a is greater than the timestamp ofb. to resolve this difficulty we require a process to advance its logical clock when it receives a message whose timestamp is greater than the current value of its logical clock. in particular if process p receives a message event b with timestamp f and lc b t then it should advance its clock so that lc b t . thus in our example when p receives the message from pi it will advance its logical clock so that lc b . chapter distributed coordination finally to realize a total ordering we need only observe that with ur timestamp ordering scheme if the timestamps of two events a and b are the same then the events are concurrent. in this case we may use process identity numbers to break ties and to create a total ordering. the use of timestamps is further discussed in section