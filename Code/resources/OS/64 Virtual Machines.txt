 the layered approach described in section . . is taken to its logical conclusion in the concept of a virtual machine. the fundamental idea behind a virtual machine is to abstract the hardware of a single computer the cpu memory disk drives network interface cards and so forth into several different execution environments thereby creating the illusion that each separate execution environment is running its own private computer. by using cpu scheduling chapter and virtual memory techniques chapter an operating system can create the illusion that a process has its own processor with its own virtual memory. normally a process has additional features such as system calls and a file system that are not provided by the bare hardware. the virtual machine approach does not provide any such additional functionality but rather provides an interface that is identical to the underlying bare hardware. each process is provided with a virtual copy of the underlying computer figure . . there are several reasons for creating a virtual machine all of which are fundamentally related to being able to share the same hardware yet run several different execution environments that is different operating systems concurrently. we will explore the advantages of virtual machines in more detail in section . . . throughout much of this section we discuss the vm operating system for ibm systems as it provides a useful working example furthermore ibm pioneered the work in this area. a major difficulty with the virtual machine approach involves disk systems. suppose that the physical machine has three disk drives but wants to support seven virtual machines. clearly it cannot allocate a disk drive to each virtual machine because the virtual machine software itself will need substantial disk space to provide virtual memory and spooling. the solution is to provide virtual disks termed minidisks in ibm's vm operating system that are identical in all respects except size. the system implements each minidisk by allocating as many tracks on the physical disks as the minidisk needs. obviously the sum of the sizes of all minidisks must be smaller than the size of the physical disk space available. users thus are given their own virtual machines. they can then run any of the operating systems or software packages that are available on the underlying . virtual machines j processes processes processes i iliill . hte i . i programming interface vm vm vm ijj . f i j!tsj rti h ini'ji '. hardware a b figure . system models a nonvirtual machine b virtual machine. machine. for the ibm vm system a user normally runs cms a single user interactive operating system. the virtual machine software is concerned with multiprogramming multiple virtual machines onto a physical machine but it does not need to consider any user support software. this arrangement may provide a useful way to divide the problem of designing a multiuser interactive system into two smaller pieces. . . implementation although the virtual machine concept is useful it is difficult to implement. much work is required to provide an exact duplicate of the underlying machine. remember that the underlying machine has two modes user mode and kernel mode. the virtual machine software can run in kernel mode since it is the operating system. the virtual machine itself can execute in only user mode. just as the physical machine has two modes however so must the virtual machine. consequently we must have a virtual user mode and a virtual kernel mode both of which run in a physical user mode. those actions that cause a transfer from user mode to kernel mode on a real machine such as a system call or an attempt to execute a privileged instruction must also cause a transfer from virtual user mode to virtual kernel mode on a virtual machine. such a transfer can be accomplished as follows. when a system call for example is made by a program running on a virtual machine in virtual user mode it will cause a transfer to the virtual machine monitor in the real machinewhen the virtual machine monitor gains control it can change the register contents and program counter for the virtual machine to simulate the effect of the system call. it can then restart the virtual machine noting that it is now in virtual kernel mode. the major difference of course is time. whereas the real i o might have taken milliseconds the virtual i o might take less time because it is chapter operating system structures spooled or more time because it is interpreted . in addition the cpu is being multiprogrammed among many virtual machines further slowing down the virtual machines in unpredictable ways. in the extreme case it may be necessary to simulate all instructions to provide a true virtual machine. vm works for ibm machines because normal instructions for the virtual machines can execute directly on the hardware. only the privileged instructions needed mainly for i o must be simulated and hence execute more slowly. . . benefits the virtual machine concept has several advantages. notice that in this environment there is complete protection of the various system resources. each virtual machine is completely isolated from all other virtual machines so there are no protection problems. at the same time however there is no direct sharing of resources. two approaches to provide sharing have been implemented. first it is possible to share a minidisk and thus to share files. this scheme is modeled after a physical shared disk but is implemented by software. second it is possible to define a network of virtual machines each of which can send information over the virtual communications network. again the network is modeled after physical communication networks but is implemented in software. such a virtual machine system is a perfect vehicle for operating systems research and development. normally changing an operating system is a difficult task. operating systems are large and complex programs and it is difficult to be sure that a change in one part will not cause obscure bugs in some other part. the power of the operating system makes changing it particularly dangerous. because the operating system executes in kernel mode a wrong change in a pointer could cause an error that would destroy the entire file system. thus it is necessary to test all changes to the operating system carefully. the operating system however runs on and controls the entire machine. therefore the current system must be stopped and taken out of use while changes are made and tested. this period is commonly called systemdevelopment time. since it makes the system unavailable to users systemdevelopment time is often scheduled late at night or on weekends when system load is low. a virtual machine system can eliminate much of this problem. system programmers are given their own virtual machine and system development is done on the virtual machine instead of on a physical machine. normal system operation seldom needs to be disrupted for system development. . . examples despite the advantages of virtual machines they received little attention for a number of years after they were first developed. today however virtual machines are coming back into fashion as a means of solving system compatibility problems. in this section we explore two popular contemporary virtual machines vmware and the java virtual machine. as we will see these virtual machines typically run on top of an operating system of any of the design types discussed earlier. thus operating system design methods . virtual machines simple layers microkernel modules and virtual machines are not nuitually exclusive. . . . vmware vmware is a popular commercial application that abstracts intel x hardware into isolated virtual machines. vmware runs as an application on a host operating system such as windows or linux and allows this host system to concurrently run several different guest operating systems as independent virtual machines. consider the following scenario a developer has designed an application and would like to test it on linux freebsd windows nt and windows xp. one option is for her to obtain four different computers each running a copy of one of these operating systems. another alternative is for her first to install linux on a computer system and test the application then to install freebsd and test the application and so forth. this option allows her to use the same physical computer but is time consuming since she must install a new operating system for each test. such testing could be accomplished concurrently on the same physical computer using vmware. in this case the programmer could test the application on a host operating system and on three guest operating systems with each system running as a separate virtual machine. the architecture of such a system is shown in figure . . in this scenario linux is running as the host operating system freebsd windows nt and windows xp are running as guest operating systems. the virtualization layer is the heart of vmware as it abstracts the physical hardware into isolated virtual machines running as guest operating systems. each virtual machine has its own virtual cpu memory disk drives network interfaces and so forth. application application application application guest operating guest operating guest operating system system system free bsd windows nt windows xp virtual cpu virtual cpu virtual cpu virtual memory virtual memory virtual memory virtual devices virtual devices virtual devices virtualization layer host operating system . a z' isis'm linux wit a a iva v hardware cpu memory i o devices j figure . vmware architecture. chapter operating system structures . . . the java virtual machine java is a popular object oriented programming language introduced by sun microsystems in . in addition to a language specification and a large api library java also provides a specification for a java virtual machine or jvm. java objects are specified with the class construct a java program consists of one or more classes. for each java class the compiler produces an architecture neutral bytecode output .class file that will run on any implementation of the jvm. the jvmis a specification for an abstract computer. it consists of a class loader and a java interpreter that executes the architecture neutral bytecodes as diagrammed in figure . . the class loader loads the compiled . class files from both the java program and the java api for execution by the java interpreter. after a class is loaded the verifier checks that the . class file is valid java bytecode and does not overflow or underflow the stack. it also ensures that the bytecode does not perform pointer arithmetic which could provide illegal memory access. if the class passes verification it is run by the java interpreter. the jvm also automatically manages memory by performing garbage collection the practice of reclaiming memory from objects no longer in use and returning it to the system. much research focuses on garbage collection algorithms for increasing the performance of java programs in the virtual machine. the jvm may be implemented in software on top of a host operating system such as windows linux or mac os x or as part of a web browser. alternatively the jvm may be implemented in hardware on a chip specifically designed to run java programs. if the jvm is implemented in software the java interpreter interprets the bytecode operations one at a time. a faster software technique is to use a just in time jit compiler. here the first time a java method is invoked the bytecodes for the method are turned into native machine language for the host system. these operations are then cached so that subsequent invocations of a method are performed using the native machine instructions and the bytecode operations need not be interpreted all over again. a technique that is potentially even faster is to run the jvm in hardware on a special java chip that executes the java bytecode operations as native code thus bypassing the need for either a software interpreter or a just in time compiler. class loader java interpreter . . . . . .' ' '.' . . . . . . . .' '.'' figure . the java virtual machine. . virtual machines the .net framework the .met framework is a collection of technologies including a set of class libraries and an execution environment that come together to provide a platform for developing software. this platform allows programs to be written to target the .ntt framework instead of a specific architecture. a program written for the .net framework need not worry about the specifics of the hardware or the operating system on which it will run. thus any architecture implementing .net will be able to successfully execute the program this is because the execution environment abstracts these details and provides a virtual machine as an intermediary between the executing program and the underlying a rchitecture at the core of the .net framework is the common language runtime clr . the clr is the implementation of the .net virtual machine. it provides an environment for execution of programs written in any of the languages targeted at the .net framework. programs written in languages such as c pronounced c sharp and vb.net are compiled into an intermediate architecture independent language called i icrosoft intermediate language ms l . these compiled files called assemblies include ms il instructions and metadata. they have a file extension of either .exe or .dll. upon execution of a program the clr loads assemblies into what is known as the application domain. as instructions are requested by the executing program the clr converts the ms il instructions inside the assemblies into native code that is specific to the underlying arcliitecture using just in time compilation. once instructions have been converted to native code they are kept and will continue to run as native code for the cpu. the architecture of the clr for the .net framework is shown in figure . . . c vb.net source source compilation ms il ms il assembly assembly clr just in time compiler host system figure . architecture of the clr for the .net framework. chapter operating system structures