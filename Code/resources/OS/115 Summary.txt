 client remote object val server.somemethod a b boolean somemeihod object x object y implementation of somemethod ii stub skeleton a b somemethod boolean return value figure . marshalling parameters. the boolean value returned from somemethod and sends this value back to the client. the stub unmarshals this return value and passes it to the client. the process is shown in figure . . fortunately the level of abstraction that rmi provides makes the stubs and skeletons transparent allowing java developers to write programs that invoke distributed methods just as they would invoke local methods. it is crucial however to understand a few rules about the behavior of parameter passing. if the marshalled parameters are local or nonremote objects they are passed by copy using a technique known as object serialization. however if the parameters are also remote objects they are passed by reference. in our example if a is a local object and b a remote object a is serialized and passed by copy and b is passed by reference. this in turn allows the server to invoke methods on b remotely. if local objects are to be passed as parameters to remote objects they must implement the interface j ava. io . s e r i a l i z a b l e . many objects in the core java api implement s e r i a l i z a b l e allowing them to be used with rmi. object serialization allows the state of an object to be written to a byte stream. . summary a process is a program in execution. as a process executes it changes state. the state of a process is defined by that process's current activity. each process may be in one of the following states new ready running waiting or terminated. each process is represented in the operating system by its own process control block pcb . a process when it is not executing is placed in some waiting queue. there are two major classes of queues in an operating system i o request queues chapter processes and the ready queue. the ready queue contains all the processes that areteady to execute and are waiting for the cpu. each process is represented by a pcb and the pcbs can be linked together to form a ready queue. long term job scheduling is the selection of processes that will be allowed to contend for the cpu. normally long term scheduling is heavily influenced by resourceallocation considerations especially memory management. short term cpu scheduling is the selection of one process from the ready queue. operating systems must provide a mechanism for parent processes to create new child processes. the parent may wait for its children to terminate before proceeding or the parent and children may execute concurrently. there are several reasons for allowing concurrent execution information sharing computation speedup modularity and convenience. the processes executing in the operating system may be either independent processes or cooperating processes. cooperating processes require an interprocess communication mechanism to communicate with each other. principally communication is achieved through two schemes shared memory and message passing. the shared memory method requires communicating processes to share some variables. the processes are expected to exchange information through the use of these shared variables. in a shared memory system the responsibility for providing communication rests with the application programmers the operating system needs to provide only the shared memory. the message passing method allows the processes to exchange messages. the responsibility for providing communication may rest with the operating system itself. these two schemes are not mutually exclusive and can be used simultaneously within a single operating system. communication in client server systems may use sockets remote procedure calls rpcs or java's remote method invocation rmi . a socket is defined as an endpoint for communication. a connection between a pair of applications consists of a pair of sockets one at each end of the communication channel. rpcs are another form of distributed communication. an rpc occurs when a process or thread calls a procedure on a remote application. rmi is the java version of rpcs. rmi allows a thread to invoke a method on a remote object just as it would invoke a method on a local object. the primary distinction between rpcs and rmi is that in rpcs data are passed to a remote procedure in the form of an ordinary data structure whereas rmi allows objects to be passed in remote method calls. exercises . describe the differences among short term medium term and longterm scheduling. . describe the actions taken by a kernel to context switch between processes. . consider the rpc mechanism. describe the undesirable consequences that could arise from not enforcing either the at most once or exactly once semantic. describe possible uses for a mechanism that has neither of these guarantees. exercises include sys types.h t include stdio.h include unistd.h int value int main pid t pid pid fork if pid child process value else if pid parent process wait null printf parent value d value line a exit figure . c program. . using the program shown in figure . explain what will be output at line a. . what are the benefits and the disadvantages of each of the following? consider both the system level and the programmer level. a. synchronous and asynchronous communication b. automatic and explicit buffering c. send by copy and send by reference d. fixed sized and variable sized messages . the fibonacci sequence is the series of numbers formally it can be expressed as fibo jibi fib fib fib write a c program using the fork system call that that generates the fibonacci sequence in the child process. the number of the sequence will be provided in the command line. for example if is provided the first five numbers in the fibonacci sequence will be output by the child process. because the parent and child processes have their own copies of the data it will be necessary for the child to output the sequence. have the parent invoke the wait call to wait for the child process to complete before exiting the program. perform necessary error checking to ensure that a non negative number is passed on the command line. chapter processes . repeat the preceding exercise this time using the createprocess in the win api. in this instance you will need to specify a separate program to be invoked from createprocessc . it is this separate program that will run as a child process outputting the fibonacci sequence. perform necessary error checking to ensure that a nonnegative number is passed on the command line. . modify the date server shown in figure . so that it delivers random fortunes rather than the current date. allow the fortunes to contain multiple lines. the date client shown in figure . can be used to read the multi line fortunes returned by the fortune server. . an echo server is a server that echoes back whatever it receives from a client. for example if a client sends the server the string hello there! the server will respond with the exact data it received from the client that is hello therei write an echo server using the java networking api described in section . . . this server will wait for a client connection using the accept method. when a client connection is received the server will loop performing the following steps read data from the socket into a buffer. write the contents of the buffer back to the client. the server will break out of the loop only when it has determined that the client has closed the connection. the date server shown in figure . uses the java io .bufferedreader class. buff eredreader extends the java io .reader class which is used for reading character streams. however the echo server cannot guarantee that it will read characters from clients it may receive binary data as well. the class java. io. inputstream deals with data at the byte level rather than the character level. thus this echo server must use an object that extends java. io.inputstream. the read method in the j ava. io. inputstream class returns when the client has closed its end of the socket connection. . in exercise . the child process must output the fibonacci sequence since the parent and child have their own copies of the data. another approach to designing this program is to establish a shared memory segment between the parent and child processes. this technique allows the child to write the contents of the fibonacci sequence to the sharedmemory segment and has the parent output the sequence when the child completes. because the memory is shared any changes the child makes to the shared memory will be reflected in the parent process as well. this program will be structured using posix shared memory as described in section . . . the program first requires creating the data structure for the shared memory segment. this is most easily accomplished using a struct. this data structure will contain two items a fixed sized array of size max sequence that will hold the fibonacci values and the size of the sequence the child process is to generate exercises sequence size where sequence size max..sequence. these items can be represented in a s t r u c t as follows define max sequence typedef struct long f ib sequence max sequence int sequence size shared data the parent process will progress through the following steps a. accept the parameter passed on the command line and perform error checking to ensure that the parameter is max sequence. b. create a shared memory segment of size shared data. c. attach the shared memory segment to its address space. d. set the value of sequence size to the parameter on the command line. e. fork the child process and invoke the wait system call to wait for the child to finish. f. output the value of the fibonacci sequence in the shared memory segment. g. detach and remove the shared memory segment. because the child process is a copy of the parent the shared memory region will be attached to the child's address space as well. the child process will then write the fibonacci sequence to shared memory and finally will detach the segment. one issue of concern with cooperating processes involves synchronization issues. in this exercise the parent and child processes must be synchronized so that the parent does not output the fibonacci sequence until the child finishes generating the sequence. these two processes will be synchronized using the wait system call the parent process will invoke wait which will cause it to be suspended until the child process exits. . most unix and linux systems provide the ipcs command. this command lists the status of various posix interprocess communication mechanisms including shared memory segments. much of the information for the command comes from the data structure s t r u c t shmiclds which is available in the u s r i n c l u d e s y s s h m . h file. some of the fields of this structure include int shm segsz size of the shared memory segment short shmjiattch number of attaches to the shared memory segment struct ipc perm shm perm permission structure of the shared memory segment chapter processes the struct ipc perm data structure which is available in the file u s r i n c l u d e s y s i p c .h contains the fields unsigned short uid identifier of the user of the shared memory segment unsigned short mode permission modes key t key on linux systems key user specified key identifier the permission modes are set according to how the shared memory segment is established with the shmget system call. permissions are identified according to the following mode meaning read permission of owner. write permission of owner. read permission of group. write permission of group read permission of world. write permission of world. permissions can be accessed by using the bitwise and operator . for example if the statement mode evaluates to true the permission mode allows read permission by the owner of the shared memory segment. shared memory segments can be identified according to a userspecified key or according to the integer value returned from the shmget system call which represents the integer identifier of the shared memory segment created. the shm ds structure for a given integer segment identifier can be obtained with the following shmctl system call identifier of the shared memory segment int s egment i d shm ds shmbuffer shmctl segmented ipcstat shmbuf f e r if successful shmctl returns otherwise it returns . write a c program that is passed an identifier for a shared memory segment. this program will invoke the shmctl function to obtain its shnuds structure. it will then output the following values of the given shared memory segment segment id key mode exercises owner ifid size number of attaches project unix shell and history feature this project consists of modifying a c program which serves as a shell interface that accepts user commands and then executes each command in a separate process. a shell interface provides the user a prompt after which the next command is entered. the example below illustrates the prompt sh and the user's next command cat prog. c. this command displays the file prog. c on the terminal using the unix cat command. sh cat prog.c one technique for implementing a shell interface is to have the parent process first read what the user enters on the command line i.e. cat prog. c and then create a separate child process that performs the command unless otherwise specified the parent process waits for the child to exit before continuing. this is similar in functionality to what is illustrated in figure . . however unix shells typically also allow the child process to run in the background or concurrently as well by specifying the ampersand at the end of the command. by rewriting the above command as sh cat prog.c the parent and child processes now run concurrently. the separate child process is created using the f ork system call and the user's command is executed by using one of the system calls in the execo family as described in section . . . simple shell a c program that provides the basic operations of a command line shell is supplied in figure . . this program is composed of two functions main and setup . the setup function reads in the user's next command which can be up to characters and then parses it into separate tokens that are used to fill the argument vector for the command to be executed. if the command is to be run in the background it will end with ' ' and setupo will update the parameter background so the maino function can act accordingly. this program is terminated when the user enters controlxd and setup then invokes exit . the mainc function presents the prompt c mmand and then invokes s e t u p o which waits for the user to enter a command. the contents of the command entered by the user is loaded into the args array. for example if the user enters i s at the c mmand prompt args becomes equal to the string is and args l is set to the string to . by ''string we mean a null terminated c style string variable. chapter processes if include stdio.h include unistd.h define max line setup reads in the next command line separating it into distinct tokens using whitespace as delimiters setup modifies the args parameter so that it holds pointers to the null terminated strings that are the tokens in the most recent user command line as well as a null pointer indicating the end of the argument list which comes after the string pointers that have been assigned to args. void setup char inputbuffer char args int background full source code available online int main void char inputbuffer maxjline buffer to hold command entered int background equals if a command is followed by ' ' char args max lin command line arguments while background printf command setup calls exito when control d is entered setup inputbuffer args fcbackground the steps are fork a child process using fork the child process will invoke execvp if background the parent will wait otherwise it will invoke the setup function again. figure . outline of simple shell. this project is organized into two parts creating the child process and executing the command in the child and modifying the shell to allow a history feature. creating a child process the first part of this project is to modify the mainq function in figure . so that upon returning from s e t u p a child process is forked and executes the command specified by the user. exercises as noted above the setup function loads the contents of the args array with the command specified by the user. this args array will be passed to the execvpo function which has the following interface execvp char command char params where command represents the command to be performed and par ams stores the parameters to this command. for this project the execvp function should be invoked as execvp args args be sure to check the value of background to determine if the parent process is to wait for the child to exit or not. creating a history feature the next task is to modify the program in figure . so that it provides a history feature that allows the user access up to the most recently entered commands. these commands will be numbered starting at and will continue to grow larger even past e.g. if the user has entered commands the most recent commands should be numbered to . this history feature will be implementing using a few different techniques. first the user will be able to list these commands when he she presses control c which is the sigint signal. unix systems use signals to notify a process that a particular event has occurred. signals may be either synchronous or asynchronous depending upon the source and the reason for the event being signaled. once a signal has been generated by the occurrence of a certain event e.g. division by zero illegal memory access user entering control c etc. the signal is delivered to a process where it must be handled. a process receiving a signal may handle it by one of the following techniques ignoring the signal using the default signal handler or providing a separate signal handling function. signals may be handled by first setting certain fields in the c structure struct sigaction and then passing this structure to the sigactionq function. signals are defined in the include file u s r i n c l u d e s y s s i g n a l . h. for example the signal sigint represents the signal for terminating a program with the control sequence control c . the default signal handler for sigint is to terminate the program. alternatively a program may choose to set up its own signal handling function by setting the sajhandler field in s t r u c t sigaction to the name of the function which will handle the signal and then invoking the s i g a c t i o n o function passing it the signal we are setting up a handler for and a pointer to s t r u c t sigaction. in figure . we show a c program that uses the function handle.sigintq for handling the sigint signal. this function prints out the message''caught control c and then invokes the e x i t function to terminate the program. we must use the write function for performing output rather than the more common p r i n t f as the former is known as being chapter processes include signal.h include unistd.h include stdio.h define buffer size char buffer buffer size the signal handling function void handle sigint write stdout fileno buffer s t r l e n buf f er exit int mainfint argc char argv set up the signal handler struct sigaction handler handler . sa handler handle.sigint sigaction sigint chandler null generate the output message strcpy buffer caught control c n loop until we receive controlxc while return figure . signal handling program. signal safe indicating it can be called from inside a signal handling function such guarantees cannot be made of p r i n t f . this program will run in the while l loop until the user enters the sequence control c . when this occurs the signal handling function handle sigint is invoked. the signal handling function should be declared above main and because control can be transferred to this function at any point no parameters may be passed to it this function. therefore any data that it must access in your program must be declared globally i.e. at the top of the source file before your function declarations. before returning from the signal handling function it should reissue the command prompt. if the user enters control c the signal handler will output a list of the most recent commands. with this list the user can run any of the previous commands by entering r x where 'x' is the first letter of that command. if more than one command starts with v execute the most recent one. also the user should be able to run the most recent command again by just entering v. you can assume that only one space will separate the 'r' and the first letter and bibliographical notes that the letter will be followed by ' n'. again 'r' alone will be immediately followed by the n character if it is wished to execute the most recent command. any command that is executed in this fashion should be echoed on the user's screen and the command is also placed in the history buffer as the next command r x does not go into the history list the actual command that it specifies though does. it the user attempts to vise this history facility to run a command and the command is detected to be erroneous an error message should be given to the user and the command not entered into the history list and the execvpq function should not be called. it would be nice to know about improperly formed commands that are handed off to execvpo that appear to look valid and are not and not include them in the history as well but that is beyond the capabilities of this simple shell program. you should also modify setup so it returns an i n t signifying if has successfully created a valid args list or not and the main should be updated accordingly. bibliographical notes interprocess communication in the rc system was discussed by brinchhansen . schlichting and schneider discussed asynchronous message passing primitives. the ipc facility implemented at the user level was described by bershad et al. . details of interprocess communication in unix systems were presented by gray . barrera and vahalia described interprocess communication in the mach system. solomon and russinovich and stevens outlined interprocess communication in windows and unix respectively. the implementation of rpcs was discussed by birrell and nelson . a design of a reliable rpc mechanism was described by shrivastava and panzieri and tay and ananda presented a survey of rpcs. stankovic and staunstrup discussed procedure calls versus message passing communication. grosso discussed rmi in significant detail. calvertand donahoo provided coverage of socket programming in java