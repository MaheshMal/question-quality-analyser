 capability and its table entry must match. this scheme was adopted in the cal system. it does not allow selective revocation. keys. a key is a unique bit pattern that can be associated with a capability. tliis key is defined when the capability is created and it can be neither modified nor inspected by the process owning the capability. a master key is associated with each object it can be defined or replaced with the set key operation. when a capability is created the current value of the master key is associated with the capability. when the capability is exercised its key is compared with the master key. if the keys match the operation is allowed to continue otherwise an exception condition is raised. revocation replaces the master key with a new value via the set key operation invalidating all previous capabilities for this object. this scheme does not allowr selective revocation since only one master key is associated with each object. if we associate a list of keys with each object then selective revocation can be implemented. finally we can group all keys into one global table of keys. a capability is valid only if its key matches some key in the global table. we implement revocation by removing the matching key from the table. with this scheme a key can be associated with several objects and several keys can be associated with each object providing maximum flexibility. in key based schemes the operations of defining keys inserting them into lists and deleting them from lists should not be available to all users. in particular it would be reasonable to allow only the owner of an object to set the keys for that object. this choice however is a policy decision that the protection system can implement but should not define. . capability based systems in this section we survey two capability based protection systems. these systems vary in their complexity and in the types of policies that can be implemented on them. neither system is widely used but they are interesting proving grounds for protection theories. . . an example hydra hydra is a capability based protection system that provides considerable flexibility. a fixed set of possible access rights is known to and interpreted by the system. these rights include such basic forms of access as the right to read write or execute a memory segment. in addition a user of the protection system can declare other rights. the interpretation of user defined rights is performed solely by the user's program but the system provides access protection for the use of these rights as well as for the use of system defined rights. these facilities constitute a significant development in protection technology. operations on objects are defined procedurally. the procedures that implement such operations are themselves a form of object and they are accessed indirectly by capabilities. the names of user defined procedures must be identified to the protection system if it is to deal with objects of the userdefined type. when the definition of an object is made known to hydra the chapter protection names of operations on the type become auxiliary rights. auxiliary rights can be described in a capability for an instance of the type. for a process to perform an operation on a typed object the capability it holds for that object must contain the name of the operation being invoked among its auxiliary rights. this restriction enables discrimination of access rights to be made on an instance by instance and process by process basis. hydra also provides rights amplification. this scheme allows a procedure to be certified as trustworthy to act on a formal parameter of a specified type on behalf of any process that holds a right to execute the procedure. the rights held by a trustworthy procedure are independent of and may exceed the rights held by the calling process. however such a procedure must not be regarded as universally trustworthy the procedure is not allowed to act on other types for instance and the trustworthiness must not be extended to any other procedures or program segments that might be executed by a process. amplification allows implementation procedures access to the representation variables of an abstract data type. if a process holds a capability to a typed object a for instance this capability may include an auxiliary right to invoke some operation p but would not include any of the so called kernel rights such as read write or execute on the segment that represents a. such a capability gives a process a means of indirect access through the operation p to the representation of a but only for specific purposes. when a process invokes the operation p on an object a however the capability for access to a may be amplified as control passes to the code body of p. this amplification may be necessary to allow p the right to access the storage segment representing a so as to implement the operation that p defines on the abstract data type. the code body of p may be allowed to read or to write to the segment of a directly even though the calling process cannot. on return from p the capability for a is restored to its original unamplified state. this case is a typical one in which the rights held by a process for access to a protected segment must change dynamically depending on the task to be performed. the dynamic adjustment of rights is performed to guarantee consistency of a programmer defined abstraction. amplification of rights can be stated explicitly in the declaration of an abstract type to the hydra operating system. when a user passes an object as an argument to a procedure we may need to ensure that the procedure cannot modify the abject. we can implement this restriction readily by passing an access right that does not have the modification write right. however if amplification may occur the right to modify may be reinstated. thus the user protection requirement can be circumvented. in general of course a user may trust that a procedure performs its task correctly. this assumption is not always correct however because of hardware or software errors. hydra solves this problem by restricting amplifications. the procedure call mechanism of hydra was designed as a direct solution to the problem of mutually suspicious subsystems. this problem is defined as follows. suppose that a program is provided that can be invoked as a service by a number of different users for example a sort routine a compiler a game . when users invoke this service program they take the risk that the program will malfunction and will either damage the given data or retain some access right to the data to be used without authority later. similarly the service program may have some private files for accounting purposes . capability based systems for example that should not be accessed directly by the calling user program. hydra provides mechanisms for directly dealing with this problem. a hydra subsystem is built on top of its protection kernel and may require protection of its own components. a subsystem interacts with the kernel through calls on a set of kernel defined primitives that define access rights to resources defined by the subsystem. the subsystem designer can define policies for use of these resources by user processes but the policies are enforceable by use of the standard access protection afforded by the capability system. a programmer can make direct use of the protection system after acquainting herself with its features in the appropriate reference manual. hydra provides a large library of system defined procedures that can be called by user programs. a user of the hydra system would explicitly incorporate calls on these system procedures into the code of her programs or would use a program translator that had been interfaced to hydra. . . an example cambridge cap system a different approach to capability based protection has been taken in the design of the cambridge cap system. cap's capability system is simpler and superficially less powerful than that of hydra. however closer examination shows that it too can be used to provide secure protection of user defined objects. cap has two kinds of capabilities. the ordinary kind is called a data capability. it can be used to provide access to objects but the only rights provided are the standard read write and execute of the individual storage segments associated with the object. data capabilities are interpreted by microcode in the cap machine. the second kind of capability is the so called software capability which is protected but not interpreted by the cap microcode. it is interpreted by a protected that is a privileged procedure which may be written by an application programmer as part of a subsystem. a particular kind of rights amplification is associated with a protected procedure. when executing the code body of such a procedure a process temporarily acquires the right to read or write the contents of a software capability itself. this specific kind of rights amplification corresponds to an implementation of the seal and unseal primitives on capabilities. of course this privilege is still subject to type verification to ensure that only software capabilities for a specified abstract type are passed to any such procedure. universal trust is not placed in any code other than the cap machine's microcode. see bibliographical notes for references. the interpretation of a software capability is left completely to the subsystem. through the protected procedures it contains. this scheme allows a variety of protection policies to be implemented. although a programmer can define her own protected procedures any of which might be incorrect the security of the overall system cannot be compromised. the basic protection system will not allow an unverified user defined protected procedure access to any storage segments or capabilities that do not belong to the protection environment in which it resides. the most serious consequence of an insecure protected procedure is a protection breakdown of the subsystem for which that procedure has responsibility. . chapter protection the designers of the cap system have noted that the use of software capabilities allowed them to realize considerable economies in formulating and implementing protection policies commensurate with the requirements of abstract resources. however a subsystem designer who wants to make use of this facility cannot simply study a reference manual as is the case with hydra. instead she must learn the principles and techniques of protection since the system provides her with no library of procedures