 i o is a major factor in system performance. it places heavy demands on the cpu to execute device driver code and to schedule processes fairly and efficiently as they block and unblock. the resulting context switches stress the cpu and its hardware caches. i o also exposes any inefficiencies in the interrupt handling mechanisms in the kernel. in addition i o loads down the memory bus during data copy between controllers and physical memory and again during copies between kernel buffers and application data space. coping gracefully with all these demands is one of the major concerns of a computer architect. although modern computers can handle many thousands of interrupts per second interrupt handling is a relatively expensive task each interrupt causes the system to perform a state change to execute the interrupt handler and then to restore state. programmed i o can be more efficient than interrupt driven j o if the number of cycles spent in busy waiting is not excessive. an i o completion typically unblocks a process leading to the full overhead of a context switch. network traffic can also cause a high context switch rate. consider for instance a remote login from one machine to another. each character typed on the local machine must be transported to the remote machine. on the local machine the character is typed a keyboard interrupt is generated and the character is passed through the interrupt handler to the device driver to the kernel and then to the user process. the user process issues a network i o system call to send the character to the remote machine. the character then flows into the local kernel through the network layers that construct a network packet and into the network device driver. the network device driver transfers the packet to the network controller which sends the character and generates an interrupt. the interrupt is passed back up through the kernel to cause the network i o system call to complete. . performance now the remote system's network hardware receives the packet and an interrupt is generated. the character is unpacked from the network protocols and is given to the appropriate network daemon. the network daemon. identifies which remote login session is involved and passes the packet to the appropriate subdaemon for that session. throughout this flow there are context switches and state switches figure . . usually the receiver echoes the character back to the sender that approach doubles the work. to eliminate the context switches involved in moving each character between daemons and the kernel the solaris developers reimplemented the telnet daemon using in kernel threads. sun estimates that this improvement increased the maximum number of network logins from a few hundred to a few thousand on a large server. other systems use separate front end processors for terminal i o to reduce the interrupt burden on the main cpu. for instance a terminal concentrator can multiplex the traffic from hundreds of remote terminals into one port on a large computer. an i o channel is a dedicated special purpose cpu found in v fyped system all packei 'contplstbs s f ! ' i interrupt iijiterrl!jp t ' generated' har 'djbd adapef . . jjj.. . . . r . v.. td! ! ijl . . !. b i! a v if? interrupt . ihteirrtipt! j ! handled generated qenefated network '. device tietifiark v drby'ef . sdspisr. j. kei ' e . o j ill . i user imnlem ketnm nrhpp ' ' sendingsystem figure . intercomputer communications. chapter i o systems mainframes and in other high end systems. the job of a channel is to offload i o work from the main cpu. the idea is that the channels keep the data flowing smoothly while the main cpu remains free to process the data. like the device controllers and dma controllers found in smaller computers a channel can process more general and sophisticated programs so channels can be tuned for particular workloads. we can employ several principles to improve the efficiency of i o reduce the number of context switches. reduce the number of times that data must be copied in memory while passing between device and application. reduce the frequency of interrupts by using large transfers smart controllers and polling if busy waiting can be minimized . increase concurrency by using dma knowledgeable controllers or channels to offload simple data copying from the cpu. move processing primitives into hardware to allow their operation in device controllers to be concurrent with cpu and bus operation. balance cpu memory subsystem bus and r o performance because an overload in any one area will cause idleness in others. devices vary greatly in complexity. for instance a mouse is simple. the mouse movements and button clicks are converted into numeric values that are passed from hardware through the mouse device driver to the application. by contrast the functionality provided by the windows nt disk device driver is complex. it not only manages individual disks but also implements raid arrays section . . to do so it converts an application's read or write request into a coordinated set of disk i o operations. moreover it implements sophisticated error handling and data recovery algorithms and takes many steps to optimize disk performance. where should the i o functionality be implemented in the device hardware in the device driver or in application software? sometimes we observe the progression depicted in figure . . initially we implement experimental i o algorithms at the application level because application code is flexible and application bugs are unlikely to cause system crashes. furthermore by developing code at the application level we avoid the need to reboot or reload device drivers after every change to the code. an application level implementation can be inefficient however because of the overhead of context switches and because the application cannot take advantage of internal kernel data structures and kernel functionality such as efficient in kerne! messaging threading and locking . when an application level algorithm has demonstrated its worth we may reimplement it in the kernel. this can improve the performance but the development effort is more challenging because an operatingsystem kernel is a large complex software system. moreover an in kernel