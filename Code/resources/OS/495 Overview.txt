 the control of devices connected to the computer is a major concern of operating system designers. because i o devices vary so widely in their function and speed consider a mouse a hard disk and a cd rom jukebox varied methods are needed to control them. these methods form the i o subsystem of the kernel which separates the rest of the kernel from the complexities of managing i o devices. chapter i o systems i o device technology exhibits two conflicting trends. on one hand we see increasing standardization of software and hardware interfaces. this trend helps us to incorporate improved device generations into existing computers and operating systems. on the other hand we see an increasingly broad variety of i o devices. some new devices are so unlike previous devices that it is a challenge to incorporate them into our computers and operating systems. this challenge is met by a combination of hardware and software techniques. the basic i o hardware elements such as ports buses and device controllers accommodate a wide variety of i o devices. to encapsulate the details and oddities of different devices the kernel of an operating system is structured to use device driver modules. the device drivers present a uniform deviceaccess interface to the i o subsystem much as system calls provide a standard interface between the application and the operating system. . i o hardware computers operate a great many kinds of devices. most fit into the general categories of storage devices disks tapes transmission devices network cards modems and human interface devices screen keyboard mouse . other devices are more specialized such as the steering of a military fighter jet or a space shuttle. in these aircraft a human gives input to the flight computer via a joystick and foot pedals and the computer sends output commands that cause motors to move rudders flaps and thrusters. despite the incredible variety of i o devices though we need only a few concepts to understand how the devices are attached and how the software can control the hardware. a device communicates with a computer system by sending signals over a cable or even through the air. the device communicates with the machine via a connection point or port for example a serial port. if devices use a common set of wires the connection is called a bus. a bus is a set of wires and a rigidly defined protocol that specifies a set of messages that can be sent on the wires. in terms of the electronics the messages are conveyed by patterns of electrical voltages applied to the wires with defined timings. when device a has a cable that plugs into device b and device b has a cable that plugs into device c and device c plugs into a port on the computer this arrangement is called a daisy chain. a daisy chain usually operates as a bus. buses are used widely in computer architecture. a typical pc bus structure appears in figure . . this figure shows a pci bus the common pc system bus that connects the processor memory subsystem to the fast devices and an expansion bus that connects relatively slow devices such as the keyboard and serial and parallel ports. in the upper right portion of the figure four disks are connected together on a scsi bus plugged into a scsi controller. a controller is a collection of electronics that can operate a port a bus or a device. a serial port controller is a simple device controller. it is a single chip or portion of a chip in the computer that controls the signals on the wires of a serial port. by contrast a scsi bus controller is not simple. because the scsi protocol is complex the scsi bus controller is often implemented as a separate circuit board or a host adapter that plugs into the computer. it typically contains a processor microcode and some private memory to enable it to process the scsi protocol messages. some devices have their own built in . i o hardware monitor process '! ' cache grapriscs 'h nernory scsi cont oller controller pc! bus ide disk control'er expansion bus keyboard interlace expansion bus parallel serial port port figure . a typical pc bus structure. controllers. if you look at a disk drive you will see a circuit board attached to one side. this board is the disk controller. it implements the disk side of the protocol for some kind of connection scsi or ata for instance. tt has microcode and a processor to do many tasks such as bad sector mapping prefetching buffering a n c caching. how can the processor give commands and data to a controller to accomplish an i o transfer? the short answer is that the controller has one or more registers for data and control signals. the processor communicates with the controller by reading and writing bit patterns in these registers. one way in which this communication can occur is through the use of special i o instructions that specify the transfer of a byte or word to an i o port address. the i o instruction triggers bus lines to select the proper device and to move bits into or out of a device register. alternatively the device controller can support memory mapped i o. in this case the device control registers are mapped into the address space of the processor. the cpu executes i o requests using the standard data transfer instructions to read and write the device control registers. some systems use both techniques. for instance pcs use i o instructions to control some devices and memory mapped i o to control others. figure . shows the usual t o port addresses for pcs. the graphics controller has i o ports for basic control operations but the controller has a large memorymapped region to hold screen contents. the process sends output to the screen by writing data into the memory mapped region. the controller generates the screen image based on the contents of this memory this technique is simple to use. moreover writing millions of bytes to the graphics memory is faster than issuing millions of i o instructions. but the ease of writing chapter i o systems issrange fr !i! iii !i! iii !i! i! iii i i pft iii.ili ii i!i t u i i . i .. ! . . '.. itt i j. . r i i i ''j ' ' ' ' ' ' ' ' ' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . f . . . . ... . . . . . . .. . . . .. . ! ! . gf f . . j ji . tiillill l.i l l .li . lllss!illil f. mi lii !i! iii iii iii i ?s f i i i i i hi. i lalffdff if . lui l iiti f ! i i f f f f i ''! ' ! . '. ' . . . . . . . . . . . . . . . . ii! ! . !ih . !i serial p o tft eftrwy mn ' ' figure . device i o port locations on pcs partial . to a memory mapped i o controller is offset by a disadvantage. because a common type of software fault is a write through an incorrect pointer to an unintended region of memory a memory mapped device register is vulnerable to accidental modification. of course protected memory helps to reduce this risk. an i o port typically consists of four registers called the status control data in and data out registers. the data in register is read by the host to get input. the data out register is written by the host to send output. the status register contains bits that can be read by the host. these bits indicate states such as whether the current command has completed whether a byte is available to be read from the data in register and whether a device error has occurred. the control register can be written by the host to start a command or to change the mode of a device. for instance a certain bit in the control register of a serial port chooses between full duplex and half duplex communication another bit enables parity checking a third bit sets the word length to or bits and other bits select one of the speeds supported by the serial port. the data registers are typically to bytes in size. some controllers have fifo chips that can hold several bytes of input or output data to expand the capacity of the controller beyond the size of the data register. a fifo chip can hold a small burst of data until the device or host is able to receive those data. . . polling the complete protocol for interaction between the host and a controller can be intricate but the basic handshaking notion is simple. we explain handshaking . i o hardware with an example. we assume that bits are used to coordinate the producer consumer relationship between the controller and the host. the controller indicates its state through the busy bit in the status register. recall that to set a bit means to write a into the bit and to clear a bit means to write a into it. the controller sets the busy bit when it is busy working and clears the busy bit when it is ready to accept the next command. the host signals its wishes via the command ready bit in the command register. the host sets the command ready bit when a command is available for the controller to execute. for this example the host writes output through a port coordinating with the controller by handshaking as follows. . the host repeatedly reads the busy bit until that bit becomes clear. . the host sets the write bit in the command register and writes a byte into the data out register. . the host sets the command ready bit. . when the controller notices that the command ready bit is set it sets the busy bit. . the controller reads the command register and sees the write command. it reads the data out register to get the byte and does the i o to the device. . the controller clears the command ready bit clears the error bit in the status register to indicate that the device i o succeeded and clears the busy bit to indicate that it is finished. this loop is repeated for each byte. tn step the host is busy waiting or polling it is in a loop reading the status register over and over until the busy bit becomes clear f the controller and device are fast this method is a reasonable one. but if the wait may be long the host should probably swritch to another task. how then does the host know when the controller has become idle? for some devices the host must service the device quickly or data will be lost. for instance when data are streaming in on a serial port or from a keyboard the small buffer on the controller will overflow and data will be lost if the host waits too long before returning to read the bytes. in many computer architectures three cpu instruction cycles are sufficient to poll a device read a device register logical arid to extract a status bit and branch if not zero. clearly the basic polling operation is efficient. but polling becomes inefficient when it is attempted repeatedly yet rarely finds a device to be ready for service while other useful cpu processing remains undone. in such instances it may be more efficient to arrange for the hardware controller to notify the cpu when the device becomes ready for service rather than to require the cpu to poll repeatedly for an i o completion. the hardware mechanism that enables a device to notify the cpu is called an interrupt. . . interrupts the basic interrupt mechanism works as follows. the cpu hardware has a wire called the interrupt request line that the cpu senses after executing every instruction. when the cpu detects that a controller has asserted a signal on the chapter i o systems cpu i o controller device driver initiates i o cpu executing checks for interrupts between instructions mm i i transfers aorttrotm i tmm.. ! gemrates m . .! . .. .. .j.j l . inferruptihariaitfr . . i u prioi ess idatg ii it v ! i . . ' . cpu resumes processing of interrupted task figure . interrupt driven i o cycle. interrupt request line the cpu performs a state save and jumps to the interrupthandler routine at a fixed address in memory. the interrupt handler determines the cause of the interrupt performs the necessary processing performs a state restore and executes a return from interrupt instruction to return the cpu to the execution state prior to the interrupt. we say that the device controller raises an interrupt by asserting a signal on the interrupt request line the cpu catches the interrupt and dispatches it to the interrupt handler and the handler clears the interrupt by servicing the device. figure summarizes the interrupt driven i o cycle. this basic interrupt mechanism enables the cpu to respond to an asynchronous event as when a device controller becomes ready for service. in a modern operating system however we need more sophisticated interrupthandling features. . we need the ability to defer interrupt handling during critical processing. . we need an efficient way to dispatch to the proper interrupt handler for a device without first polling all the devices to see which one raised the interrupt. . i o hardware . we need multilevel interrupts so that the operating system can.distinguish between high and low priority interrupts and can respond with the appropriate degree of urgency. in modern computer hardware these three features are provided by the cpu and by the interrupt controller hardware. most cpus have two interrupt request lines. one is the nonmaskable interrupt which is reserved for events such as unrecoverable memory errors. the second interrupt line is maskable it can be turned off by the cpu before the execution of critical instruction sequences that must not be interrupted. the maskable interrupt is used by device controllers to request service. the interrupt mechanism accepts an address a number that selects a specific interrupt handling routine from a small set. in most architectures this address is an offset in a table called the interrupt vector. this vector contains the memory addresses of specialized interrupt handlers. the purpose of a vectored interrupt mechanism is to reduce the need for a single interrupt handler to search all possible sources of interrupts to determine which one needs service. in practice however computers have more devices and hence interrupt handlers than they have address elements in the interrupt vector. a common way to solve this problem is to use the technique of interrupt chaining in which each element in the interrupt vector points to the head of a list of interrupt handlers. when an interrupt is raised the handlers on the corresponding list are called one by one until one is found that can service the request. this structure is a compromise between the overhead of a huge interrupt table and the inefficiency of dispatching to a single interrupt handler. figure . illustrates the design of the interrupt vector for the intel pentium processor. the events from to which are nonmaskable are used to signal various error conditions. the events from to which are maskable are used for purposes such as device generated interrupts. the interrupt mechanism also implements a system of interrupt priority levels. this mechanism enables the cpu to defer the handling of low priority interrupts without masking off all interrupts and makes it possible for a high priority interrupt to preempt the execution of a low priority interrupt. a modern operating system interacts with the interrupt mechanism in several ways. at boot time the operating system probes the hardware buses to determine what devices are present and installs the corresponding interrupt handlers into the interrupt vector. during i o the various device controllers raise interrupts when they are ready for service. these interrupts signify that output has completed or that input data are available or that a failure has been detected. the interrupt mechanism is also used to handle a wide variety of exceptions such as dividing by zero accessing a protected or nonexistent memory address or attempting to execute a privileged instruction from user mode. the events that trigger interrupts have a common property they are occurrences that induce the cpu to execute an urgent self contained routine. an operating system has other good uses for an efficient hardware and software mechanism that saves a small amount of processor state and then calls a privileged routine in the kernel. for example many operating systems use the interrupt mechanism for virtual memory paging. a page fault is an exception that raises an interrupt. the interrupt suspends the current process and jumps to the page fault handler in the kernel. this handler saves the state chapter i o systems vector number . ... . . descspiwi . j q v . ciivide error. . . . . ' . . . . . . . . . . rti'ii ih'fj'i'fii' . . i i ib l c . f ' ' .j i . . . . . . . . . . . . . . ' . . . . . . . . . . ! . . r . ' ' ' ' ' ' ' fergakpoigt . i . . i i ' 'il ' i ! ilsi t cieteq!e qverlfaw i i ' i . v i . ' .'. i. i i . ' i boprid iraingf bxeepfiort ! . . i i i 'i i . v it i i i i i . elsweelnqt gvltladle i i ! i . . i i '. ' i cnprocbssgr segraefitlpvenrun eresgruee r mi ii iwafid task st ts!segment i ' ' ' ' . aegrne ht r iqt gras?nt ' v ' . ' ' . '. . . . . . . . j j.. . .. .... stapfcfault.. .'. . . . ....... . . i . .. . gb ara pfojeetim . . e . . . . e e e . e ' page fault ... ' injejiressryeci.dqnot.usb iloa'irigrppintbrror . ' i . . giignment check . . machine check infefteserved do not use maskable interrupts figure . intel pentium processor event vector table. of the process moves the process to the wait queue performs page cache management schedules an i o operation to fetch the page schedules another process to resume execution and then returns from the interrupt. another example is found in the implementation of system calls. usually a program uses library calls to issue system calls. the library routines check the arguments given by the application build a data structure to convey the arguments to the kernel and then execute a special instruction called a software interrupt or a trap . this instruction has an operand that identifies the desired kernel service. when a process executes the trap instruction the interrupt hardware saves the state of the user code switches to supervisor mode and dispatches to the kernel routine that implements the requested service. the trap is given a relatively low interrupt priority compared with those assigned to device interrupts executing a system call on behalf of an application is less urgent than servicing a device controller before its fifo queue overflows and loses data. interrupts can also be used to manage the flow of control within the kernel. for example consider the processing required to complete a disk read. one step is to copy data from kernel space to the user buffer. this copying is time consuming but not urgent it should not block other high priority interrupt handling. another step is to start the next pending i o for that disk drive. this step has higher priority if the disks are to be used efficiently we need to start the next i o as soon as the previous one completes. consequently a pair of interrupt handlers implements the kernel code that completes a disk read. the . i o hardware high priority handler records the i o status clears the device interrupt.starts the next pending i o and raises a low priority interrupt to complete the work. later when the cpu is not occupied with high priority work the low priority interrupt will be dispatched. the corresponding handler completes the userlevel i o by copying data from kernel buffers to the application space and then calling the scheduler to place the application on the ready queue. a threaded kernel architecture is well suited to implement multiple interrupt priorities and to enforce the precedence of interrupt handling over background processing in kernel and application routines. we illustrate this point with the solaris kernel in solaris interrupt handlers are executed as kernel threads. a range of high priorities is reserved for these threads. these priorities give interrupt handlers precedence over application code and kernel housekeeping and implement the priority relationships among interrupt handlers. the priorities cause the solaris thread scheduler to preempt lowpriority interrupt handlers in favor of higher priority ones and the threaded implementation enables multiprocessor hardware to run several interrupt handlers concurrently. we describe the interrupt architecture of unix and windows xp in appendices a and respectively. in summary interrupts are used throughout modern operating systems to handle asynchronous events and to trap to supervisor mode routines in the kernel. to enable the most urgent work to be done first modern computers use a system of interrupt priorities. device controllers hardware faults and system calls all raise interrupts to trigger kernel routines. because interrupts are used so heavily for time sensitive processing efficient interrupt handling is required for good system performance. . . direct memory access for a device that does large transfers such as a disk drive it seems wasteful to use an expensive general purpose processor to watch status bits and to feed data into a controller register one byte at a time a process termed programmed i o pio . many computers avoid burdening the main cpu with pio by offloading some of this work to a special purpose processor called a direct memory access dma controller. to initiate a dma transfer the host writes a dma command block into memory. this block contains a pointer to the source of a transfer a pointer to the destination of the transfer and a count of the number of bytes to be transferred. the cpu writes the address of this command block to the dma controller then goes on with other work. the dma controller proceeds to operate the memory bus directly placing addresses on the bus to perform transfers without the help of the main cpu. a simple dma controller is a standard component in pcs and bus mastering i o boards for the pc usually contain their own high speed dma hardware. handshaking between the dma controller and the device controller is performed via a pair of wires called dma request and dma acknowledge. the device controller places a signal on the dma request wire when a word of data is available for transfer. this signal causes the dma controller to seize the memory bus to place the desired address on the memory address wires and to place a signal on the dma acknowledge wire. when the device controller receives the dma acknowledge signal it transfers the w ord of data to memory and removes the dma request signal. chapter i o systems . device driver is told to transfer disk data to buffer at address x . dma controller . device driver teiis transfers bytes to disk controller to buffer x increasing transfer c bytes memory address from disk to buffer and decreasing c at address x until c . when c dma i cp . tsemofv 'jo interrupts cpu to signal d transfer completion pci ens . disk controller initiates dma transfer . disk controller sends each byte to dma controller figure . steps in a dma transfer. when the entire transfer is finished the dma controller interrupts the cpu. this process is depicted in figure . . when the dma controller seizes the memory bus the cpu is momentarily prevented from accessing main memory although it can still access data items in its primary and secondary caches. although this cycle stealing can slow down the cpu computation offloading the data transfer work to a. dma controller generally improves the total system performance. some computer architectures use physical memory addresses for dma but others perform direct virtual memory access dvma using virtual addresses that undergo translation to physical addresses. dvma can perform a transfer between two memory mapped devices without the intervention of the cpu or the use of main memory. on protected mode kernels the operating system generally prevents processes from issuing device commands directly. this discipline protects data from access control violations and also protects the system from erroneous use of device controllers that could cause a system crash. instead the operating system exports functions that a sufficiently privileged process can use to access low level operations on the underlying hardware. on kernels without memory protection processes can access device controllers directly. this direct access can be used to obtain high performance since it can avoid kernel communication context switches and layers of kernel software. unfortunately it interferes with system security and stability. the trend in general purpose operating systems is to protect memory and devices so that the system can try to guard against erroneous or malicious applications. . . i o hardware summary although the hardware aspects of i o are complex when considered at the level of detail of electronics hardware design the concepts that we have . application i o interface just described are sufficient to enable us to understand many i o features of operating systems. let's review the main concepts a bus a controller an i o port and its registers the handshaking relationship between the host and a device controller the execution of this handshaking in a polling loop or via interrupts the offloading of this work to a dma controller for large transfers we gave a basic example of the handshaking that takes place between a device controller and the host earlier in this section. in reality the wide variety of available devices poses a problem for operating system implementers. each kind of device has its own set of capabilities control bit definitions and protocols for interacting with the host and they are all different. how can the operating system be designed so that we can attach new devices to the computer without rewriting the operating system? and when the devices vary so widely how can the operating system give a convenient uniform i o interface to applications? we address those questions next. . application s o interface in this section we discuss structuring techniques and interfaces for the operating system that enable i o devices to be treated in a standard uniform way. we explain for instance how an application can open a file on a disk without knowing what kind of disk it is and how new disks and other devices can be added to a computer without disruption of the operating system. like other complex software engineering problems the approach here involves abstraction encapsulation and software layering. specifically we can abstract away the detailed differences in i o devices by identifying a fewgeneral kinds. each general kind is accessed through a standardized set of functions an interface. the differences are encapsulated in kernel modules called device drivers that internally are custom tailored to each device but that export one of the standard interfaces. figure . illustrates how the i o related portions of the kernel are structured in software layers. the purpose of the device driver layer is to hide the differences among device controllers from the i o subsystem of the kernel much as the i o system calls encapsulate the behavior of devices in a few generic classes that hide hardware differences from applications. making the i o subsystem independent of the hardware simplifies the job of the operating system developer. it also benefits the hardware manufacturers. they either design new devices to be compatible with an existing host controller interface such as scsi or they write device drivers to interface the new hardware to popular operating systems. thus we can attach new peripherals to a computer without waiting for the operating system vendor to develop support code. unfortunately for device hardware manufacturers each type of operating system has its own standards for the device driver interface. a given device chapter i o systems ibriver .silver co o jbdmcbsi ipjslbiisi iiiclrises figure . a kernel i o structure. may ship with multiple device drivers for instance drivers for ms dos windows windows nt and solaris. devices vary on many dimensions as illustrated in figure . . character stream or block. a character stream device transfers bytes one by one whereas a block device transfers a block of bytes as a unit. sequential or random access. a sequential device transfers data in a fixed order determined by the device whereas the user of a random access device can instruct the device to seek to any of the available data storage locations. synchronous or asynchronous. a synchronous device performs data transfers with predictable response times. an asynchronous device exhibits irregular or unpredictable response times. sharable or dedicated. a sharable device can be used concurrently by several processes or threads a dedicated device cannot. speed of operation. device speeds range from a few bytes per second to a few gigabytes per second. read write read only or write only. some devices perform both input and output but others support only one data direction. for the purpose of application access many of these differences are hidden by the operating system and the devices are grouped into a few conventional . application i o interface f ff m m m lpm sm. d ial i n g ! x v . . . . . . . . . . . . i i lal ngy i n i i i . l l w l l s jhi ' . m. !ij ' ' ' m tela teteeein g eratons n u . . ' o . gfaphics eo mtoiter . . . . figure . characteristics of i o devices. types. the resulting styles of device access have been found to be useful and broadly applicable. although the exact system calls may differ across operating systems the device categories are fairly standard. the major access conventions include block i o character stream i o memory mapped file access and network sockets. operating systems also provide special system calls to access a few additional devices such as a time of day clock and a timer. some operating systems provide a set of system calls for graphical display video and audio devices. most operating systems also have an escape or back door that transparently passes arbitrary commands from an application to a device driver. tn unix this system call is i o c t l o for i o control . the i o c t l o system call enables an application to access any functionality that can be implemented by any device driver without the need to invent a new system call. the i o c t l o system call has three arguments. the first is a file descriptor that connects the application to the driver by referring to a hardware device managed by that driver. the second is an integer that selects one of the commands implemented in the driver. the third is a pointer to an arbitrary data structure in memory that enables the application and driver to communicate any necessary control information or data. . . block and character devices the block device interface captures all the aspects necessary for accessing disk drives and other block oriented devices. the device is expected to understand commands such as read and wr i t e if it is a random access device it is also expected to have a seek command to specify which block to transfer next. applications normally access such a device through a file system interface. we can see that r e a d o write and seeko capture the essential behaviors chapter i o systems of block storage devices so that applications are insulated from the low level differences among those devices. the operating system itself as well as special applications such as databasemanagement systems may prefer to access a block device as a simple linear array of blocks. this mode of access is sometimes called raw i o. if the application performs its own buffering then using a file system would cause extra unneeded buffering. likewise if an application provides its own locking of file blocks or regions then any operating system locking services would be redundant at the least and contradictory at the worst. to avoid these conflicts raw device access passes control of the device directly to the application letting the operating system step out of the way. unfortunately no operating system services are then performed on this device. a compromise that is becoming common is for the operating system to allow a mode of operation on a file that disables buffering and locking. in the unix world this is called direct i o. memory mapped file access can be layered on top of block device drivers. rather than offering read and write operations a memory mapped interface provides access to disk storage via an array of bytes in main memory. the system call that maps a file into memory returns the virtual memory address that contains a copy of the file. the actual data transfers are performed only when needed to satisfy access to the memory image. because the transfers are handled by the same mechanism as that used for demand paged virtual memory access memory mapped i o is efficient. memory mapping is also convenient for programmers access to a memory mapped file is as simple as reading from and writing to memory. operating systems that offer virtual memory commonly use the mapping interface for kernel services. for instance to execute a program the operating system maps the executable into memory and then transfers control to the entry address of the executable. the mapping interface is also commonly used for kernel access to swap space on disk. a keyboard is an example of a device that is accessed through a characterstream interface. the basic system calls in this interface enable an application to get or puto one character. on top of this interface libraries can be built that offer line at a time access with buffering and editing services for example when a user types a backspace the preceding character is removed from the input stream . this style of access is convenient for input devices such as keyboards mice and modems that produce data for input spontaneously that is at times that cannot necessarily be predicted by the application. this access style is also good for output devices such as printers and audio boards which naturally fit the concept of a linear stream of bytes. . . network devices because the performance and addressing characteristics of network i o differ significantly from those of disk i o most operating systems provide a network i o interface that is different from the read w r i t e s e e k o interface used for disks. one interface available in many operating systems including unix and windows nt is the network socket interface. think of a wall socket for electricity any electrical appliance can be plugged in. by analogy the system calls in the socket interface enable an application to create a socket to connect a local socket to a remote address which plugs this application into a socket created by another application to . application i o interface listen for any remote application to plug into the local socket and to send and receive packets over the connection. to support the implementation of servers the socket interface also provides a function called s e l e c t that manages a set of sockets. a call to s e l e c t returns information about which sockets have a packet waiting to be received and which sockets have room to accept a packet to be sent. the use of s e l e c t eliminates the polling and busy waiting that would otherwise be necessary for network i o. these functions encapsulate the essential behaviors of networks greatly facilitating the creation of distributed applications that can use any underlying network hardware and protocol stack. many other approaches to interprocess communication and network communication have been implemented. for instance windows nt provides one interface to the network interface card and a second interface to the network protocols section c. . in unix which has a long history as a proving ground for network technology we find half duplex pipes full duplex fifos full duplex