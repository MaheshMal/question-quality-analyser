 we turn next to the issue of allocation. how do we allocate the fixed amount of free memory among the various processes? if we have free frames and two processes how many frames does each process get? the simplest case is the single user system. consider a single user system with kb of memory composed of pages kb in size. this system has frames. the operating system may take kb leaving frames for the user process. under pure demand paging all frames would initially be put on the free frame list. when a user process started execution it would generate a sequence of page faults. the first page faults would all get free frames from the free frame list. when the free frame list was exhausted a page replacement algorithm would he used to select one of the in memory pages to be replaced with the th and so on. when the process terminated the frames would once again be placed on the free frame list. there are many variations on this simple strategy. we can require that the operating system allocate all its buffer and table space from the free frame list. when this space is not in use by the operating system it can be used to support user paging. we can try to keep three free frames reserved on the free frame list at all times. thus when a page fault occurs there is a free frame available to page into. while the page swap is taking place a replacement can be selected which is then written to the disk as the user process continues to execute. other variants are also possible but the basic strategy is clear the user process is allocated any free frame. . . minimum number of frames our strategies for the allocation of frames are constrained in various ways. we cannot for example allocate more than the total number of available frames unless there is page sharing . we must also allocate at least a minimum number of frames. here we look more closely at the latter requirement. one reason for allocating at least a minimum number of frames involves performance. obviously as the number of frames allocated to each process decreases the page fault rate increases slowing process execution. in addition remember that when a page fault occurs before an executing instruction is complete the instruction must be restarted. consequently we must have enough frames to hold all the different pages that any single instruction can reference. for example consider a machine in which all memory reference instructions have only one memory address. in this case we need at least one frame for the instruction and one frame for the memory reference. in addition if one level indirect addressing is allowed for example a load instruction on page can refer to an address on page which is an indirect reference to page then paging requires at least three frames per process. think about what might happen if a process had only two frames. the minimum number of frames is defined by the computer architecture. for example the move instruction for the pdp includes more than one word for some addressing modes and thus the instruction itself may straddle two pages. in addition each of its two operands may be indirect references for a total of six frames. another example is the ibm mvc instruction. since the . allocation of frames instruction is from storage location to storage location it takes bytes and can straddle two pages. the block of characters to move and the area to which it is to be moved can each also straddle two pages. this situation would require six frames. the worst case occurs when the mvc instruction is the operand of an execute instruction that straddles a page boundary in this case we need eight frames. the worst case scenario occurs in computer architectures that allow multiple levels of indirection for example each bit word could contain a bit address plus a bit indirect indicator . theoretically a simple load instruction could reference an indirect address that could reference an indirect address on another page that could also reference an indirect address on yet another page and so on until every page in virtual memory had been touched. thus in the worst case the entire virtual memory must be in physical memory. to overcome this difficulty we must place a limit on the levels of indirection for example limit an instruction to at most levels of indirection . when the first indirection occurs a counter is set to the counter is then decremented for each successive indirection for this instruction. tf the counter is decremented to a trap occurs excessive indirection . this limitation reduces the maximum number of memory references per instruction to requiring the same number of frames. whereas the minimum number of frames per process is defined by the architecture the maximum number is defined by the amount of available physical memory. in between we are still left with significant choice in frame allocation. . . allocation algorithms the easiest way to split in frames among n processes is to give everyone an equal share m n frames. for instance if there are frames and five processes each process will get frames. the leftover three frames can be used as a free frame buffer pool. this scheme is called equal allocation. an alternative is to recognize that various processes will need differing amounts of memory. consider a system with a kb frame size. if a small student process of kb and an interactive database of kb are the only two processes running in a system with free frames it does not make much sense to give each process frames. the student process does not need more than frames so the other are strictly speaking wasted. to solve this problem we can use proportional allocation in which we allocate available memory to each process according to its size. let the size of the virtual memory for process pt be s and define then if the total number of available frames is m we allocate a frames to process where a is approximately a sj s x m. chapter virtual memory of course we must adjust each to be an integer that is greater rha i the minimum number of frames required by the instruction set with a sum not exceeding m. for proportional allocation we would split frames between two processes one of pages and one of pages by allocating frames and frames respectively since x and x . in this way both processes share the available frames according to their needs rather than equally. in both equal and proportional allocation of course the allocation may vary according to the multiprogramming level. if the multiprogramming level is increased each process will lose some frames to provide the memory needed for the new process. conversely if the multiprogramming level decreases the frames that were allocated to the departed process can be spread over the remaining processes. notice that with either equal or proportional allocation a high priority process is treated the same as a low priority process. by its definition however we may want to give the high priority process more memory to speed its execution to the detriment of low priority processes. one solution is to use a proportional allocation scheme wherein the ratio of frames depends not on the relative sizes of processes but rather on the priorities of processes or on a combination of size and priority. . . global versus local allocation another important factor in the way frames are allocated to the various processes is page replacement. with multiple processes competing for frames we can classify page replacement algorithms into two broad categories global replacement and local replacement. global replacement allows a process to select a replacement frame from the set of all frames even if that frame is currently allocated to some other process that is one process can take a frame from another. local replacement requires that each process select from only its own set of allocated frames. for example consider an allocation scheme where we allow high priority processes to select frames from low priority processes for replacement. a process can select a replacement from among its own frames or the frames of any lower priority process. this approach allows a high priority process to increase its frame allocation at the expense of a low priority process. with a local replacement strategy the number of frames allocated to a process does not change. with global replacement a process may happen to select only frames allocated to other processes thus increasing the number of frames allocated to it assuming that other processes do not choose its frames for replacement . one problem with a global replacement algorithm is that a process cannot control its own page fault rate. the set of pages in memory for a process depends not only on the paging behavior of that process but also on the paging behavior of other processes. therefore the same process may perform quite