 . kernel modules the linux kernel has the ability to load and unload arbitrary sections of kernel code on demand. these loadable kernel modules run in privileged kernel mode and as a consequence have full access to all the hardware capabilities of the machine on which they run. in theory there is no restriction on what a kernel module is allowed to do typically a module might implement a device driver a file system or a networking protocol. kernel modules are convenient for several reasons. linux's source code is free so anybody wanting to write kernel code is able to compile a modified kernel and to reboot to load that new functionality however recompiling relinking and reloading the entire kernel is a cumbersome cycle to undertake when you are developing a new driver. if you use kernel modules you do not have to make a new kernel to test a new driver the driver can be compiled on its own and loaded into the already running kernel. of course once a new driver is written it can be distribttted as a module so that other users can benefit from it without having to rebuild their kernels. this latter point has another implication. because it is covered by the gpl license the linux kernel cannot be released with proprietary components added to it unless those new components are also released under the gpl and the source code for them is made available on demand. the kernel's module interface allows third parties to write and distribute on their own terms device drivers or file systems that could not be distributed under the gpl. kernel modules allow a linux system to be set up with a standard minimal kernel without any extra device drivers built in. any device drivers that the user needs can be either loaded explicitly by the system at startup or loaded automatically by the system on demand and unloaded when not in use. for example a cd rom driver might be loaded when a cd is mounted and unloaded from memory when the cd is dismounted from the file system. the module support under linux has three components . the module management allows modules to be loaded into memory and to talk to the rest of the kernel. . the driver registration allows modules to tell the rest of the kernel that a new driver has become available. . a conflict resolution mechanism allows different device drivers to reserve hardware resources and to protect those resources from accidental use by another driver. . . module management loading a module requires more than just loading its binary contents into kernel memory. the system must also make sure that any references the module makes to kernel symbols or entry points are updated to point to the correct locations in the kernel's address space. linux deals with this reference updating by splitting the job of module loading into two separate sections the management of sections of module code in kernel memory and the handling of symbols that modules are allowed to reference. chapter the linux system linux maintains an internal symbol table in the kernel. this symbol table does not contain the full set of symbols defined in the kernel during the latter's compilation rather a symbol must be exported explicitly by the kernel. the set of exported symbols constitutes a well defined interface by which a module can interact with the kernel. although exporting symbols from a kernel function requires an explicit request by the programmer no special effort is needed to import those symbols into a module. a module writer just uses the standard external linking of the c language any external symbols referenced by the module but not declared by it are simply marked as unresolved in the final module binary produced by the compiler. when a module is to be loaded into the kernel a system utility first scans the module for these unresolved references. all symbols that still need to be resolved are looked up in the kernel's symbol table and the correct addresses of those symbols in the currently running kernel are substituted into the module's code. only then is the module passed to the kernel for loading. if the system utility cannot resolve any references in the module by looking them up in the kernel's symbol table then the module is rejected. the loading of the module is performed in two stages. first the moduleloader utility asks the kernel to reserve a continuous area of virtual kernel memory for the module. the kernel returns the address of the memory allocated and the loader utility can use this address to relocate the module's machine code to the correct loading address. a second system call then passes the module plus any symbol table that the new module wants to export to the kernel. the module itself is now copied verbatim into the previously allocated space and the kernel's symbol table is updated with the new symbols for possible use by other modules not yet loaded. the final module management component is the module requestor. the kernel defines a communication interface to which a module management program can connect. with this connection established the kernel will inform the management process whenever a process requests a device driver file system or network service that is not currently loaded and will give the manager the opportunity to load that service. the original service request will complete once the module is loaded. the manager process regularly queries the kernel to see whether a dynamically loaded module is still in use and unloads that module when it is no longer actively needed. . . driver registration once a module is loaded it remains no more than an isolated region of memory until it lets the rest of the kernel know what new functionality it provides. the kernel maintains dynamic tables of all known drivers and provides a set of routines to allow drivers to be added to or removed from these tables at any time. the kernel makes sure that it calls a module's startup routine when that module is loaded and calls the module's cleanup routine before that module is unloaded these routines are responsible for registering the module's functionality. a module may register many types of drivers and may register more than one driver if it wishes. for example a device driver might want to register two separate mechanisms for accessing the device. registration tables include the following items . kernel modules device drivers. these drivers include character devices such as printers terminals and mice block devices including all disk drives and network . interface devices. file systems. the file system may be anything that implements linux's virrual file system calling routines. it might implement a format for storing files on a disk but it might equally well be a network file system such as nfs or a virtual file system whose contents are generated on demand such as linux's proc file system. network protocols. a module may implement an entire networking protocol such as ipx or simply a new set of packet filtering rules for a network firewrall. binary format. this format specifies a way of recognizing and loading a new type of executable file. in addition a module can register a new set of entries in the sysctl and proc ' tables to allow that module to be configured dynamically section . a . . conflict resolution commercial unix implementations are usually sold to run on a vendor's own hardware. one advantage of a single supplier solution is that the software vendor has a good idea about what hardware configurations are possible. ibm pc hardware however comes in a vast number of configurations with large numbers of possible drivers for devices such as network cards scsi controllers and video display adapters. the problem of managing the hardware configuration becomes more severe when modular device drivers are supported since the currently active set of devices becomes dynamically variable. linux provides a central conflict resolution mechanism to help arbitrate access to certain hardware resources. its aims are as follows to prevent modules from clashing over access to hardware resources to prevent autoprobes device driver probes that auto detect device configuration from interfering with existing device drivers j to resolve conflicts among multiple drivers trying to access the same j hardware for example as when both the parallel printer driver and the i parallel line ip plip network driver try to talk to the parallel printer port . to these ends the kernel maintains lists of allocated hardware resources. e the pc has a limited number of possible i o ports addresses in its hardware i i o address space interrupt lines and dma channels when any device driver i wants to access such a resource it is expected to reserve the resource with i the kernel database first. this requirement incidentally allows the system i administrator to determine exactly which resources have been allocated by which driver at any given point. a module is expected to use this mechanism to reserve in advance any f hardware resources that it expects to use. if the reservation is rejected because i the resource is not present or is already in use then it is up to the module chapter the linux system to decide how to proceed. it may fail its initialization and request thatnt be unloaded if it cannot continue or it may carry on using alternative hardware resources