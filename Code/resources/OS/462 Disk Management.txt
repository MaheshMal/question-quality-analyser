 the operating system is responsible for several other aspects of disk management too. here we discuss disk initialization booting from disk and bad block recovery. . . disk formatting a new magnetic disk is a blank slate it is just a platter of a magnetic recording material. before a disk can store data it must be divided into sectors that the disk controller can read and write. this process is called low level formatting or physical formatting. low level formatting fills the disk with a special data structure for each sector. the data structure for a sector typically consists of a header a data area usually bytes in size and a trailer. the header and trailer contain information used by the disk controller such as a sector number and an error correcting code ecc . when the controller writes a sector of data during normal i o the ecc is updated with a value calculated from all the bytes in the data area. when the sector is read the ecc is recalculated and is compared with the stored value. if the stored and calculated numbers are different this mismatch indicates that the data area of the sector has become corrupted and that the disk sector may be bad section . . . the ecc is an error correcting code because it contains enough information that if only a few . disk management bits or data have been corrupted the controller can identify which bits have changed and can calculate what their correct values should be. it then reports a recoverable soft error. the controller automatically does the ecc processing whenever a sector is read or written. most hard disks are low level forniatted at the factory as a part of the manufacturing process. this formatting enables the manufacturer to test the disk and to initialize the mapping from logical block numbers to defect free sectors on the disk. for many hard disks when the disk controller is instructed to low level format the disk it can also be told how many bytes of data space to leave between the header and trailer of all sectors. it is usually possible to choose among a few sizes such as and bytes. formatting a disk with a larger sector size means that fewer sectors can fit on each track but it also means that fewer headers and trailers are written on each track and more space is available for user data. some operating systems can handle only a sector size of bytes. to use a disk to hold files the operating system still needs to record its own data structures on the disk. it does so in two steps. the first step is to partition the disk into one or more groups of cylinders. the operating system can treat each partition as though it were a separate disk. for instance one partition can hold a copy of the operating system's executable code while another holds user files. after partitioning the second step is logical formatting or creation of a file system . in this step the operating system stores the initial file system data structures onto the disk. these data structures may include maps of free and allocated space a fat or modes and an initial empty directory. to increase efficiency most file systems group blocks together into larger chunks frequently called clusters. disk i o is done via blocks but file system i o is done via clusters effectively assuring that i o has more sequential access and fewer random access characteristics. some operating systems give special programs the ability to use a disk partition as a large sequential array of logical blocks without any file system data structures. this array is sometimes called the raw disk and o to this array is termed raw i o. for example some database systems prefer raw i o because it enables them to control the exact disk location where each database record is stored. raw i o bypasses all the file system services such as the buffer cache file locking prefetching space allocation file names and directories. we can make certain applications more efficient by allowing them to implement their own special purpose storage services on a raw partition but most applications perform better when they use the regular file system services. . . boot block for a computer to start running for instance when it is powered up or rebooted it must have an initial program to run. this initial bootstrap program tends to be simple. it initializes all aspects of the system from cpu registers to device controllers and the contents of main memory and then starts the operating system. to do its job the bootstrap program finds the operatingsystem kernel on disk loads that kernel into memory and jumps to an initial address to begin the operating system execution. for most computers the bootstrap is stored in read only memory rom . this location is convenient because rom needs no initialization and is at a fixed chapter mass storage structure boo' code partition part ten ia.d'e partition partition boot partition partition figure . booting from disk in windows . location that the processor can start executing when powered up or reset. and since rom is read only it cannot be infected by a computer virus. the problem is that changing this bootstrap code requires changing the rom hardware chips. for this reason most systems store a tiny bootstrap loader program in the boot rom whose only job is to bring in a full bootstrap program from disk. the full bootstrap program can be changed easily a new version is simply written onto the disk. the full bootstrap program is stored in ''the boot blocks at a fixed location on the disk. a disk that has a boot partition is called a boot disk or system disk. the code in the boot rom instructs the disk controller to read the boot blocks into memory no device drivers are loaded at this point and then starts executing that code. the full bootstrap program is more sophisticated than the bootstrap loader in the boot rom it is able to load the entire operating system from a non fixed location on disk and to start the operating system running. even so the full bootstrap code may be small. let's consider as an example the boot process in windows . the windows system places its boot code in the first sector on the hard disk which it terms the master boot record or mbr . furthermore windows allows a hard disk to be divided into one or more partitions one partition identified as the boot partition contains the operating system and device drivers. booting begins in a windows system by running code that is resident in the system's rom memory. this code directs the system to read the boot code from the mbr. in addition to containing boot code the mbr contains a table listing the partitions for the hard disk and a flag indicating which partition the system is to be booted from. this is illustrated in figure . . once the system identifies the boot partition it reads the first sector from that partition which is called the boot sector and continues with the remainder of the boot process which includes loading the various subsystems and system services. . . bad blocks because disks have moving parts and small tolerances recall that the disk head flies just above the disk surface they are prone to failure. sometimes the failure is complete in this case the disk needs to be replaced and its contents restored from backup media to the new disk. more frequently one or more . disk management sectors become defective. most disks even come from the factory with bad blocks. depending on the disk and controller in use these blocks are handled in a variety of ways. on simple disks such as some disks with de controllers bad blocks are handled manually. for instance the ms dos format command performs logical formatting and as a part of the process scans the disk to find bad blocks. if format finds a bad block it writes a special value into the corresponding fat entry to tell the allocation routines not to use that block. if blocks go bad during normal operation a special program such as chkdsk must be run manually to search for the bad blocks and to lock them away as before. data that resided on the bad blocks usually are lost. more sophisticated disks such as the scsi disks used in high end pcs and most workstations and servers are smarter about bad block recovery. the controller maintains a list of bad blocks on the disk. the list is initialized during the low level formatting at the factory and is updated over the life of the disk. low level formatting also sets aside spare sectors not visible to the operating system. the controller can be told to replace each bad sector logically with one of the spare sectors. this scheme is known as sector sparing or forwarding. a typical bad sector transaction might be as follows the operating system tries to read logical block . the controller calculates the ecc and finds that the sector is bad. it reports this finding to the operating system. the next time the system is rebooted a special command is run to tell the scsi controller to replace the bad sector with a spare. after that whenever the system requests logical block the request is translated into the replacement sector's address by the controller. such a redirection by the controller could invalidate any optimization by the operating system's disk scheduling algorithm! for this reason most disks are formatted to provide a few spare sectors in each cylinder and a spare cylinder as well. when a bad block is remapped the controller uses a spare sector from the same cylinder if possible. as an alternative to sector sparing some controllers can be instructed to replace a bad block by sector slipping. here is an example suppose that logical block becomes defective and the first available spare follows sector . then sector slipping remaps all the sectors from to moving them all down one spot. that is sector is copied into the spare then sector into and then into and so on until sector is copied into sector . slipping the sectors in this way frees up the space of sector so sector can be mapped to it. the replacement of a bad block generally is not totally automatic because the data in the bad block are usually lost. several soft errors could trigger a process in which a copy of the block data is made and the block is spared or slipped. an unrecoverable hard error however results in lost data. whatever file was using that block must be repaired for instance by restoration from a backup tape and that requires manual intervention. chapter mass storage structure 