 in its overall design linux resembles any other traditional nonmicrokernel unix implementation. it is a multiuser multitasking system with a full set of unix compatible tools. linux's file system adheres to traditional unix semantics and the standard unix networking model is implemented fully. the internal details of linux's design have been influenced heavily by the history of this operating system's development. although linux runs on a wide variety of platforms it was developed exclusively on pc architecture. a great deal of that early development was carried out by individual enthusiasts rather than by well funded development or research facilities so from the start linux attempted to squeeze as much functionality as possible from limited resources. today linux can run happily on a multiprocessor machine with hundreds of megabytes of main memory and many gigabytes of disk space but it is still capable of operating usefully in under mb of ram. as pcs became more powerful and as memory and hard disks became cheaper the original minimalist linux kernels grew to implement more unix functionality. speed and efficiency are still important design goals but much of the recent and current work on linux has concentrated on a third major design goal standardization. one of the prices paid for the diversity of unix implementations currently available is that source code written for one flavor may not necessarily compile or run correctly on another. even when the same system calls are present on two different unix systems they do not necessarily behave in exactly the same way. the posix standards comprise a set of specifications of different aspects of operating system behavior. there are posix documents for common operating system functionality and for extensions such as process threads and real time operations. linux is designed to be compliant with the relevant posix documents at least two linux distributions have achieved official posix certification. because it presents standard interfaces to both the programmer and the user linux presents few surprises to anybody familiar with unix. we do not detail these interfaces here. the sections on the programmer interface section a. and user interface section a. of bsd apply equally well to linux. by default however the linux programming interface adheres to svr unix semantics rather than to bsd behavior. a separate set of libraries is available to implement bsd semantics in places where the two behaviors are significantly different. many other standards exist in the unix world but full certification of linux against them is sometimes slowed because they are often available only for a fee and the expense involved in certifying an operating system's compliance with most standards is substantial. however supporting a wide base of applications is important for any operating system so implementation of standards is a major goal for linux development even if the implementation is not formally certified. in addition to the basic posix standard linux currently . design principles supports the posix threading extensions pthreads and a subset of tl e posix extensions for real time process control. . . components of a linux system the linux system is composed of three main bodies of code in line with most traditional unix implementations . kernel. the kernel is responsible for maintaining all the important abstractions of the operating system including such things as virtual memory and processes. . system libraries. the system libraries define a standard set of functions through which applications can interact with the kernel. these functions implement much of the operating system functionality that does not need the full privileges of kernel code. . system utilities. the system utilities are programs that perform individual specialized management tasks. some system utilities may be invoked just once to initialize and configure some aspect of the system others known as daemons in unix terminology may run permanently handling such tasks as responding to incoming network connections accepting logon requests from terminals and updating log files. figure . illustrates the various components that make up a full linux system. the most important distinction here is between the kernel and everything else. all the kernel code executes in the processor's privileged mode with full access to all the physical resources of the computer. linux refers to this privileged mode as kernel mode. under linux no user mode code is built into the kernel. any operating system support code that does not need to run in kernel mode is placed into the system libraries instead. although various modern operating systems have adopted a messagepassing architecture for their kernel internals linux retains unix's historical model the kernel is created as a single monolithic binary. the main reason is to improve performance because all kernel code and data structures are kept in a single address space no context switches are necessary when a process calls an operating system function or when a hardware interrupt is delivered. not system ! user j manaqement ' utility i compilers programs r i progiarrw j system sharer! libraries linux kernel loadable kernel modules figure . components of the linux system. chapter the linux system only the core scheduling and virtual memory code occupies this address space all kernel code including all device drivers file systems and networking cod e is present in the same single address space. even though all the kernel components share this same melting pot there is still room for modularity. in the same way that user applications can load shared libraries at run time to pull in a needed piece of code so the linux kernel can load and unload modules dynamically at run time. the kernel does not necessarily need to know in advance which modules may be loaded they are truly independent loadable components. the linux kernel forms the core of the linux operating system. it provides all the functionality necessary to run processes and it provides system services to give arbitrated and protected access to hardware resources. the kernel implements all the features required to qualify as an operating system. on its own however the operating system provided by the linux kernel looks nothing like a unix system. it is missing many of the extra features of unix and the features that it does provide are not necessarily in the format in which a unix application expects them to appear. the operating system interface visible to running applications is not maintained directly by the kernel. rather applications make calls to the system libraries which in turn call the operatingsystem services as necessary. the system libraries provide many types of functionality. at the simplest level they allow applications to make kernel system service requests. making a system call involves transferring control from unprivileged user mode to privileged kernel mode the details of this transfer vary from architecture to architecture. the libraries take care of collecting the system call arguments and if necessary arranging those arguments in the special form necessary to make the system call. the libraries may also provide more complex versions of the basic system calls. for example the c language's buffered file handling functions are all implemented in the system libraries providing more advanced control of file i o than the basic kernel system calls. the libraries alsoprovide routines that do not correspond to system calls at all such as sorting algorithms mathematical functions and string manipulation routines. all the functions necessary to support the running of unix or pos x applications are implemented here in the system libraries. the linux system includes a wide variety of user mode programs both system utilities and user utilities. the system utilities include all the programs necessary to initialize the system such as those to configure network devices and to load kernel modules. continually running server programs also count as system utilities svich programs handle user login requests incoming network connections and the printer queues. not all the standard utilities serve key system administration functions. the unix user environment contains a large number of standard utilities to do simple everyday tasks such as listing directories moving and deleting files and displaying the contents of a file. more complex utilities can perform text processing functions such as sorting textual data and performing pattern searches on input text. together these utilities form a standard tool set that users can expect on any unix system although they do not perform any operating system function they are an important part of the basic linux system