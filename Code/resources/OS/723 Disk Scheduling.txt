 that assign dynamic priorities allow priorities to change over time. .most operating systems use dynamic priorities when scheduling non real time tasks with the intention of giving higher priority to interactive processes. however when scheduling real time tasks most systems assign static priorities as the design of the scheduler is less complex. several of the real time scheduling strategies discussed in section . can be used to meet the rate and deadline qos requirements of continuous media applications. . disk scheduling we first discussed disk scheduling in chapter . there we focused primarily on systems that handle conventional data for these systems the scheduling goals are fairness and throughput. as a result most traditional disk schedulers employ some form of the scan section . . or c scan section . . algorithm. continuous media files however have two constraints that conventional data files generally do not have timing deadlines and rate requirements. these two constraints must be satisfied to preserve qos guarantees and diskscheduling algorithms must be optimized for the constraints. unfortunately these two constraints are often in conflict. continuous media files typically require very high disk bandwidth rates to satisfy their data rate requirements. because disks have relatively low transfer rates and relatively high latency rates disk schedulers must reduce the latency times to ensure high bandwidth. however reducing latency times may result in a scheduling policy that does not prioritize according to deadlines. in this section we explore two diskscheduling algorithms that meet the qos requirements for continuous media systems. . . earliest deadline first scheduling we first saw the earliest deadline first edf algorithm in section . . as an example of a cpu scheduling algorithm that assigns priorities according to deadlines. edf can also be used as a disk scheduling algorithm in this context edf uses a queue to order requests according to the time each request must be completed its deadline . edf is similar to shortest seek time first sstf which was discussed in . . except that instead of servicing the request closest to the current cylinder we service requests according to deadline the request with the closest deadline is serviced first. a problem with this approach is that servicing requests strictly according to deadline may result in higher seek times since the disk heads may move randomly throughout the disk without any regard to their current position. for example suppose a disk head is currently at cylinder and the queue of cylinders ordered according to deadlines is . under strict edf scheduling the disk head will move from to to and then back to . note that the head passes over cylinder as it travels from to . it is possible that the disk scheduler could have serviced the request for cylinder en route to cylinder and still preserved the deadline requirement for cylinder . chapter multimedia systems . . scan edf scheduling ? the fundamental problem with strict edf scheduling is that it ignores the position of the read write heads of the disk it is possible that the movement of the heads will swing wildly to and fro across the disk leading to unacceptable seek times that negatively affect disk throughput. recall that this is the same issue faced with fcfs scheduling section . . . we ultimately addressed this issue by adopting scan scheduling wherein the disk arm moves in one direction across the disk servicing requests according to their proximity to the current cylinder. once the disk arm reaches the end of the disk it begins moving in the reverse direction. this strategy optimizes seek times. scan edf is a hybrid algorithm that combines edf with scan scheduling. scan edf starts with edf ordering but services requests with the same deadline using scan order. what if several requests have different deadlines that are relatively close together? in this case scan edf may batch requests using scan ordering to service requests in the same batch. there are many techniques for batching requests with similar deadlines the only requirement is that reordering requests within a batch must not prevent a request from being serviced by its deadline. if deadlines are equally distributed batches can be organized in groups of a certain size say requests per batch. another approach is to batch requests whose deadlines fall within a given time threshold say milliseconds. let's consider an example in which we batch requests in this way. assume we have the following requests each with a specified deadline in milliseconds and the cylinder being requested request deadline cylinder a b c d e f g h j suppose we are at ti meo the cylinder currently being serviced is and the disk head is moving toward cylinder . according to our batching scheme requests d and f will be in the first batch a g and h in batch b e and j in batch and c and i in the last batch. requests within each batch will be ordered according to scan order. thus in batch we will first service request f and then request d. note that we are moving downward in cylinder numbers from to . in batch we first service request a then the heads begin moving upward in cylinders servicing requests h and then g. batch is serviced in the order e b j. requests i and c are serviced in the final batch