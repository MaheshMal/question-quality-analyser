 the compatible time sharing system ctss corbato et al. was designed at mit as an experimental time sharing system. it was implemented on an ibm and eventually supported up to interactive users. the users were provided with a set of interactive commands that allowed them to manipulate files and to compile and run programs through a terminal. the had a kb memory made up of bit words. the monitor used kb words leaving kb for the users. user memory images were swapped between memory and a fast drum. cpu scheduling employed a multilevelfeedback queue algorithm. the time quantum for level i was i time units. if a program did not finish its cpu burst in one time quantum it was moved down to the next level of the queue giving it twice as much time. the program at the highest level with the shortest quantum was run first. the initial level of a program was determined by its size so that the time quantum was at least as long as the swap time. ctss was extremely successful and was in use as late as . although it was limited it succeeded in demonstrating that time sharing was a convenient and practical mode of computing. one result of ctss was increased development of time sharing systems. another result was the development of multics. . multics the multics operating system corbato and vyssotsky organick was designed at mit as a natural extension of ctss. ctss and other early time sharing systems were so successful that they created an immediate desire to proceed quickly to bigger and better systems. as larger computers became available the designers of ctss set out to create a time sharing utility. computing service would be provided like electrical power. large computer systems would be connected by telephone wires to terminals in offices and homes throughout a city. the operating system would be a time shared system running continuously with a vast file system of shared programs and data. multics was designed by a team from mit ge which later sold its computer department to honeywell and bell laboratories which dropped out of the project in . the basic ge computer was modified to a new computer system called the ge mainly by the addition of pagedsegmentation memory hardware. a virtual address was composed of an bit segment number and a bit word offset. the segments were then paged in kb word pages. the second chance page replacement algorithm was used. the segmented virtual address space was merged into the file system each segment was a file. segments were addressed by the name of the file. the file system itself was a multilevel tree structure allowing users to create their own subdirectory structures. chapter influential operating systems like ctss multics used a multilevel feedback queue for cpu scheduling. protection was accomplished through an access list associated with each file and a set of protection rings for executing processes. the system which was written almost entirely in pl comprised about lines of code. it was extended to a multiprocessor system allowing a cpu to be taken out of service for maintenance while the system continued running. . ibm os the longest line of operating system development is undoubtedly that of ibm computers. the early ibm computers such as the ibm and the ibm are prime examples of the development of common i o subroutines followed by development of a resident monitor privileged instructions memory protection and simple batch processing. these systems were developed separately often by each site independently. as a result ibm was faced with many different computers with different languages and different system software. the ibm was designed to alter this situation. the ibm was designed as a family of computers spanning the complete range from small business machines to large scientific machines. only one set of software would be needed for these systems which all used the same operating system os mealy et al. . this arrangement was intended to reduce maintenance problems for ibm and to allow users to move programs and applications freely from one ibm system to another. unfortunately os tried to be all things for all people. as a result it did none of its tasks especially well. the file system included a type field that defined the type of each file and different file types were defined for fixed length and variable length records and for blocked and unblocked files. contiguous allocation was used so the user had to guess the size of each output file. the job control language jcl added parameters for every possible option making it incomprehensible to the average user. the memory management routines were hampered by the architecture. although a base register addressing mode was used the program could access and modify the base register so that absolute addresses were generated by the cpu. this arrangement prevented dynamic relocation the program was bound to physical memory at load time. two separate versions of the operating system were produced os mpt used fixed regions and os mvt used variable regions. the system was written in assembly language by thousands of programmers resulting in millions of lines of code. the operating system itself required large amounts of memory for its code and tables. operating system overhead often consumed one half of the total cpu cycles. over the years new versions were released to add new features and to fix errors. however fixing one error often caused another in some remote part of the system so that the number of known errors in the system remained fairly constant. virtual memory was added to os with the change to the ibm architecture. the underlying hardware provided a segmented paged virtual memory. new versions of os used this hardware in different ways. os vs created one large virtual address space and ran os mft in that virtual memory. thus the operating system itself was paged as well as user programs. os vs