 different operating systems. thus programs written for ms dos microsoft windows and posix all run on windows xp in the appropriate environment. see section . for more information on environmental subsystems. because of the modular structure additional environmental subsystems can be added without affecting the executive. in addition windows xp uses loadable drivers in the i o system so new file systems new kinds of i o devices and new kinds of networking can be added while the system is running. windows xp uses a client server model like the mach operating system and supports distributed processing by remote procedure calls rpcs as defined by the open software foundation. . . portability an operating system is portable if it can be moved from one hardware architecture to another with relatively few changes. windows xp is designed to be portable. as is true of the unix operating system the majority of the system is written in c and c . most processor dependent code is isolated in a dynamic link library dll called the hardware abstraction layer hal . a dll is a file that is mapped into a process's address space such that any functions in the dll appear to be part of the process. the upper layers of the windows xp kernel depend on the hal interfaces rather than on the underlying hardware bolstering windows xp portability. the hal manipulates hardware directly isolating the rest of windows xp from hardware differences among the platforms on which it runs. although for market reasons windows shipped only on intel ia compatible platforms it was also tested on ia and dec alpha platforms until just prior to release to ensure portability. windows xp runs on ia compatible and ia processors. microsoft recognizes the importance of multiplatform development and testing since as a practical matter maintaining portability is a matter of use it or lose it. . . international support windows xp is also designed for international and multinational use. it provides support for different locales via the national language support nls api. the nls api provides specialized routines to format dates time and money in accordance with various national customs. string comparisons are specialized to account for varying character sets. unicode is windows xp's native character code. windows xp supports ansi characters by converting them to unicode characters before manipulating them bit to bit conversion . system text strings are kept in resource files that can be replaced to localize the system for different languages. multiple locales can be used concurrently which is important to multilingual individuals and businesses. . system components the architecture of windows xp is a layered system of modules as shown in figure . . the main layers are the hal the kernel and the executive all of which run in protected mode and a collection of subsystems and services that run in user mode. the user mode subsystems fall into two categories chapter windows xp logon wini ms dos process applications applications applications i applications appticamons security. winw ms dos bqsu subsystem subsystem vom o vfdm security account manager database executive i o manager local object security ! process plug and virtual procedure file system manager reference manager play memory call window cache monitor manager manager facility manager device drivers kernel graphic n networ device drivers drivers hardware abstraction layer hardware figure . windows xp block diagram. the environmental subsystems which emulate different operating systems and the protection subsystems which provide security functions. one of the chief advantages of this type of architecture is that interactions between modules are kept simple. the remainder of this section describes these layers and subsystems. . . hardware abstraction layer the hal is the layer of software that hides hardware differences from upper levels of the operating system to help make windows xp portable. the hal exports a virtual machine interface that is used by the kernel dispatcher the executive and the device drivers. one advantage of this approach is that only a single version of each device driver is required it runs on all hardware platforms without porting the driver code. the hal also provides support for symmetric multiprocessing. device drivers map devices and access them directly but the administrative details of mapping memory configuring i o buses setting up dma and coping with motherboard specific facilities are all provided by the hal interfaces. . . kernel the kernel of windows xp provides the foundation for the executive and the subsystems. the kernel remains in memory and its execution is never . system components preempted. it has four main responsibilities thread scheduling interrupt and exception handling low level processor synchronization and recovery after a power failure. the kernel is object oriented. an object type in windows is a systemdefined data type that has a set of attributes data values and a set of methods for example functions or operations . an object is an instance of an object type. the kernel performs its job by using a set of kernel objects whose attributes store the kernel data and whose methods perform the kernel activities. . . . kernel dispatcher the kernel dispatcher provides the foundation for the executive and the subsystems. most of the dispatcher is never paged out of memory and its execution is never preempted. its main responsibilities are thread scheduling implementation of synchronization primitives timer management software interrupts asynchronous and deferred procedure calls and exception dispatching. . . . threads and scheduling like many other modern operating systems windows xp uses processes and threads for executable code. the process has a virtual memory address space and information used to initialize each thread such as a base priority and an affinity for either one or more processors. each process has one or more threads each of which is an executable unit dispatched by the kernel. each thread has its own scheduling state including actual priority processor affinity and cpu usage information. the six possible thread states are ready standby running waiting transition and terminated. ready indicates that the thread is waiting to run. the highest priority ready thread is moved to the standby state which means it is the next thread to run. in a multiprocessor system each process keeps one thread in a standby state. a thread is running when it is executing on a processor. it runs until it is preempted by a higher priority thread until it terminates until its allotted exectition time quantum ends or until it blocks on a dispatcher object such as an event signaling i o completion. a thread is in the waiting state when it is waiting for a dispatcher object to be signaled. a new thread is in the transition state while it waits for resources necessary for execution. a thread enters the terminated state when it finishes execution. the dispatcher uses a level priority scheme to determine the order of thread execution. priorities are divided into two classes variable class and real time class. the variable class contains threads having priorities from to and the real time class contains threads with priorities ranging from to . the dispatcher uses a queue for each scheduling priority and traverses the set of queues from highest to lowest until it finds a thread that is ready to run. if a thread has a particular processor affinity but that processor is not available the dispatcher skips past it and continues looking for a ready thread that is willing to run on the available processor. if no ready thread is found the dispatcher executes a special thread called the idle thread. when a thread's time quantum runs out the clock interrupt queues a quantum end deferred procedure call dpc to the processor in order to reschedule the processor. if the preempted thread is in the variable priority class its priority is lowered. the priority is never lowered below the base chapter windows xp priority. lowering the thread's priority tends to limit the cpu consumption of compute bound threads. when a variable priority thread is released from a wait operation the dispatcher boosts the priority. the amount of the boost depends on the device for which the thread was waiting for example a thread waiting for keyboard i o would get a large priority increase whereas a thread waiting for a disk operation would get a moderate one. this strategy tends to give good response times to interactive threads using a mouse and windows. it also enables i o bound threads to keep the i o devices busy while permitting compute bound threads to use spare cpu cycles in the background. this strategy is used by several time sharing operating systems including unix. in addition the thread associated with the user's active gui window receives a priority boost to enhance its response time. scheduling occurs when a thread enters the ready or wait state when a thread terminates or when an application changes a thread's priority or processor affinity if a higher priority real time thread becomes ready while a lower priority thread is running the lower priority thread is preempted. this preemption gives a real time thread preferential access to the cpu when the thread needs such access. windows xp is not a hard real time operating system however because it does not guarantee that a real time thread will start to execute within a particular time limit. . . . implementation of synchronization primitives key operating system data structures are managed as objects using common facilities for allocation reference counting and security. dispatcher objects control dispatching and synchronization in the system. examples of these objects are events mutants mutexes semaphores processes threads and timers. the event object is used to record an event occurrence and to synchronize the latter with some action. notification events signal all waiting threads and synchronization events signal a single waiting thread. the mutant provides kernel mode or user mode mutual exclusion with the notion of ownership. the mutex available only in kernel mode provides deadlock free mutual exclusion. a semaphore object acts as a counter or gate to control the number of threads that access a resource. the thread object is the entity that is scheduled by the kernel dispatcher and is associated with a process object which encapsulates a virtual address space. timer objects are used to keep track of time and to signal timeouts when operations take too long and need to be interrupted or when a periodic activity needs to be scheduled. many of the dispatcher objects are accessed from user mode via an open operation that returns a handle. the user mode code polls and or waits on handles to synchronize with other threads as well as the operating system see section . . . . . . software interrupts asynchronous and deferred procedure calls the dispatcher implements two types of software interrupts asynchronous procedure calls and deferred procedure calls. asynchronous procedure calls apcs break into an executing thread and call a procedure. apcs are used to begin execution of a new thread terminate processes and deliver notification that an asynchronous i o has completed. apcs are queued to specific threads . system components and allow the system to execute both system and user code within a process's context. deferred procedure calls dpcs are used to postpone interrupt processing. after handling all blocked device interrupt processes the interrupt service routine isr schedules the remaining processing by queuing a dpc. the dispatcher schedules software interrupts at a lower priority than the device interrupts so that dpcs do not block other isrs. in addition to deferring deviceinterrupt processing the dispatcher uses dpcs to process timer expirations and to preempt thread execution at the end of the scheduling quantum. execution of dpcs prevents threads from being scheduled on the current processor and also keeps apcs from signaling the completion of i o. this is done so that dpc routines do not take an extended amount of time to complete. as an alternative the dispatcher maintains a pool of worker threads. isrs and dpcs queue work items to the worker threads. dpc routines are restricted so that they cannot take page faults call system services or take any other action that might possibly result in an attempt to block execution on a dispatcher object. unlike apcs dpc routines make no assumptions about what process context the processor is executing. . . . exceptions and interrupts the kernel dispatcher also provides trap handling for exceptions and interrupts generated by hardware or software. windows xp defines several architectureindependent exceptions including memory access violation integer overflow floating point overflow or underflow integer divide by zero floating point divide by zero illegal instruction data misalignment privileged instruction page read error access violation paging file quota exceeded debugger breakpoint debugger single step the trap handlers deal with simple exceptions. elaborate exception handling is performed by the kernel's exception dispatcher. the exception dispatcher creates an exception record containing the reason for the exception and finds an exception handler to deal with it. when an exception occurs in kernel mode the exception dispatcher simply calls a routine to locate the exception handler. if no handler is found a fatal chapter windows xp system error occurs and the user is left with the infamous blue screen of death that signifies system failure. exception handling is more complex for user mode processes because an environmental subsystem such as the posix system sets up a debugger port and an exception port for every process it creates. if a debugger port is registered the exception handler sends the exception to the port. if the debugger port is not found or does not handle that exception the dispatcher attempts to find an appropriate exception handler. if no handler is found the debugger is called again to catch the error for debugging. if no debugger is running a message is sent to the process's exception port to give the environmental subsystem a chance to translate the exception. for example the posix environment translates windows xp exception messages into posix signals before sending them to the thread that caused the exception. finally if nothing else works the kernel simply terminates the process containing the thread that caused the exception. the interrupt dispatcher in the kernel handles interrupts by calling either an interrupt service routine isr supplied by a device driver or a kernel trap handler routine. the interrupt is represented by an interrupt object that contains all the information needed to handle the interrupt. using an interrupt object makes it easy to associate interrupt service routines with an interrupt without having to access the interrupt hardware directly. different processor architectures such as intel and dec alpha have different types and numbers of interrupts. for portability the interrupt dispatcher maps the hardware interrupts into a standard set. the interrupts are prioritized and are serviced in priority order. there are interrupt request levels irqls in windows xp. eight are reserved for use by the kernel the remaining represent hardware interrupts via the hal although most ia systems use only . the windows xp interrupts are defined in figure . . the kernel uses an interrupt dispatch table to bind each interrupt level to a service routine. in a multiprocessor computer windows xp keeps a separate interrupt dispatch table for each processor and each processor's irql can be set independently to mask out interrupts. all interrupts that occur at a level equal to or less than the irql of a processor are blocked until the irql is lowered by a interrupt levels types of interrupts machine check or bus error power fail interprocessor notification request another processor to act e.g. dispatch a process or update the tlb clock used to keep track of time profile traditional pc irq hardware interrupts dispatch and deferred procedure call dpc kernel asynchronous procedure call apc passive figure . windows xp interrupt request levels. . system components kernel level thread or by an sr returning from interrupt processing. windows xp takes advantage of this property and uses software interrupts to deliver apcs and dpcs to perform system functions such as synchronizing threads with i o completion to start thread dispatches and to handle timers. . . executive the windows xp executive provides a set of services that all environmental subsystems use. the services are grouped as follows object manager virtual memory manager process manager local procedure call facility i o manager cache manager security reference monitor plug and play and security managers registry and booting. . . . object manager for managing kernel mode entities windows xp uses a generic set of interfaces that are manipulated by user mode programs. windows xp calls these entities objects and the executive component that manipulates them is the object manager. each process has an object table containing entries that track the objects used by the process. user mode code accesses these objects using an opaque value called a handle that is returned by many apis. object handles can also be created by duplicating an existing handle either from the same process or a different process. examples of objects are semaphores mutexes events processes and threads. these are all dispatcher objects. threads can block in the kernel dispatcher waiting for any of these objects to be signaled. the process thread and virtual memory apis use process and thread handles to identify the process or thread to be operated on. other examples of objects include files sections ports and various internal i o objects. file objects are vised to maintain the open state of files and devices. sections are used to map files. open files are described in terms of file objects. local communication endpoints are implemented as port objects. the object manager maintains the windows xp internal name space. in contrast to unix which roots the system name space in the file system windows xp uses an abstract name space and connects the file systems as devices. the object manager provides interfaces for defining both object types and object instances translating names to objects maintaining the abstract name space through internal directories and symbolic links and managing object creation and deletion. objects are typically managed using reference counts in protected mode code and handles in user mode code. however some kernelmode components use the same apis as user mode code and thus use handles to manipulate objects. if a handle needs to exist beyond the lifetime of the current process it is marked as a kernel handle and stored in the object table for the system process. the abstract name space does not persist across reboots but is built up from configuration information stored in the system registry plug and play device discovery and creation of objects by system components. the windows xp executive allows any object to be given a name. one process may create a named object while a second process opens a handle to the object and shares it with the first process. processes can also share objects by duplicating handles between processes in which case the objects need not be named. chapter windows xp a name can be either permanent or temporary. a permanent 'name represents an entity such as a disk drive that remains even if no process is accessing it. a temporary name exists only while a process holds a handle to the object. object names are structured like file path names in ms dos and unix. name space directories are represented by a directory object that contains the names of all the objects in the directory. the object name space is extended by the addition of device objects representing volumes containing file systems. objects are manipulated by a set of virtual functions with implementations provided for each object type create open close delete qiieryjname parse and s e c u r i t y . the latter three objects need explanation query name is called when a thread has a reference to an object but wants to know the object's name. parse is used by the object manager to search for an object given the object's name. s e c u r i t y is called to make security checks on all object operations such as when a process opens or closes an object makes changes to the security descriptor or duplicates a handle for an object. the parse procedure is used to extend the abstract name space to include files. the translation of a path name to a file object begins at the root of the abstract name space. path name components are separated by whack characters ' ' rather than the slashes ' ' used in unix. each component is looked up in the current parse directory of the name space. internal nodes within the name space are either directories or symbolic links. if a leaf object is found and there are no path name components remaining the leaf object is returned. otherwise the leaf object's parse procedure is invoked with the remaining path name. parse procedures are only used with a small number of objects belonging to the windows gui the configuration manager registry and most notably device objects representing file systems. the parse procedure for the device object type allocates a file object and initiates an open or create i o operation on the file system. if successful the file object fields are filled in to describe the file. in summary the path name to a file is used to traverse the object manager namespace translating the original absolute path name into a device object relative path name pair. this pair is then passed to the file system via the i o manager which fills in the file object. the file object itself has no name but is referred to by a handle. unix file systems have symbolic links that permit multiple nicknames or aliases for the same file. the symbolic link object implemented by the windows xp object manager is used within the abstract name space not to provide files aliases on a file system. even so symbolic links are very useful. they are used to organize the name space similar to the organization of the devices directory in unix. they are also used to map standard ms dos drive letters to drive names. drive letters are symbolic links that can be remapped to suit the convenience of the user or administrator. . system components drive letters are one place where the abstract name space in windows xp is not global. each logged on user has his or her own set of drive letters so that users can avoid interfering with one another. in contrast terminal server sessions share all processes within a session. basenamedobjects contain the named objects created by most applications. although the name space is not directly visible across a network the object manager's parse method is used to help access a named object on another system. when a process attempts to open an object that resides on a remote computer the object manager calls the parse method for the device object corresponding to a network redirector. this results in an i o operation that accesses the file across the network. objects are instances of an object type. the object type specifies how instances are to be allocated the definitions of the data fields and the implementation of the standard set of virtual functions used for all objects. these functions implement operations such as mapping names to objects closing and deleting and applying security. the object manager keeps track of two counts for each object. the pointer count is the number of distinct references made to an object. protected mode code that refers to objects must keep a reference on the object to ensure that the object is not deleted while in use. the handle count is the number of handle table entries referring to an object. each handle is also reflected in the reference count. when a handle for an object is closed the object's close routine is called. in the case of file objects this call causes the i o manager to do a cleanup operation at the close of the last handle. the cleanup operation tells the file system that the file is no longer accessed by user mode so that sharing restrictions range locks and other states specific to the corresponding open routine can be removed. each handle close removes a reference from the pointer count but internal system components may retain additional references. when the final reference is removed the object's delete procedure is called. again using file objects as an example the delete procedure causes the i o manager to send the file system a close operation on the file object. this causes the file system to deallocate any internal data structures that were allocated for the file object. after the delete procedure for a temporary object completes the object is deleted from memory. objects can be made permanent at least with respect to the current boot of the system by asking the object manager to take an extra reference against the object. thus permanent objects are not deleted even when the last reference outside the object manager is removed. when a permanent object is made temporary again the object manager removes the extra reference. if this was the last reference the object is deleted. permanent objects are rare used mostly for devices drive letter mappings and the directory and symbolic link objects. the job of the object manager is to supervise the use of all managed objects. when a thread wants to use an object it calls the object manager's open method to get a reference to the object. if the object is being opened from a user mode api the reference is inserted into the process's object table and a handle is returned. a process gets a handle by creating an object by opening an existing object by receiving a duplicated handle from another process or by inheriting a handle from a parent process similar to the way a unix process gets a file chapter windows xp descriptor. these handles are all stored in the process's object table. an entry in the object table contains the object's access rights and states whether the handle should be inherited by child processes. when a process terminates windows xp automatically closes all the process's open handles. handles are a standardized interface to all kinds of objects. like a file descriptor in unix an object handle is an identifier unique to a process that confers the ability to access and manipulate a system resource. handles can be duplicated within a process or between processes. the latter case is used when child processes are created and when out of process execution contexts are implemented. since the object manager is the only entity that generates object handles it is the natural place to check security. the object manager checks whether a process has the right to access an object when the process tries to open the object. the object manager also enforces quotas such as the maximum amount of memory a process may use by charging a process for the memory occupied by all its referenced objects and refusing to allocate more memory when the accumulated charges exceed the process's quota. when the login process authenticates a user an access token is attached to the user's process. the access token contains information such as the security id group ids privileges primary group and default access control list. the services and objects a user can access are determined by these attributes. the token that controls access is associated with the thread making the access. normally the thread token is missing and defaults to the process token but services often need to execute code on behalf of their client. windows xp allows threads to impersonate temporarily by using a client's token. thus the thread token is not necessarily the same as the process token. in windows xp each object is protected by an access control list that contains the security ids and access rights granted. when a thread attempts to access an object the system compares the security id in the thread's access token with the object's access control list to determine whether access should be permitted. the check is performed only when an object is opened so it is not possible to deny access after the open occurs. operating system components executing in kernel mode bypass the access check since kernel mode code is assumed to be trusted. therefore kernel mode code must avoid security vulnerabilities such as leaving checks disabled while creating a user modeaccessible handle in an untrusted process. generally the creator of the object determines the access control list for the object. if none is explicitly supplied one may be set to a default by the object type's open routine or a default list may be obtained from the user's access token object. the access token has a field that controls auditing of object accesses. operations that are being audited are logged to the system's security log with an identification of the user. an administrator monitors this log to discover attempts to break into the system or to access protected objects. . . . virtual memory manager the executive component that manages the virtual address space physical memory allocation and paging is the virtual memory vm manager. the design of the vm manager assumes that the underlying hardware supports . system components virtual to physical mapping a paging mechanism and transparent cache coherence on multiprocessor systems as well as allowing multiple page table entries to map to the same physical page frame. the vm manager in windows xp uses a page based management scheme with a page size of kb on ia compatible processors and kb on the ia . pages of data allocated to a process that are not in physical memory are either stored in the paging files on disk or mapped directly to a regular file on a local or remote file system. pages can also be marked zero fill on demand which fills the page with zeros before being allocated thus erasing the previous contents. on ia processors each process has a gb virtual address space. the upper gb are mostly identical for all processes and are used by windows xp in kernel mode to access the operating system code and data structures. key areas of the kernel mode region that are not identical for all processes are the page table self map hyperspace and session space. the hardware references a process's page tables using physical page frame numbers. the vm manager maps the page tables into a single mb region in the process's address space so they are accessed through virtual addresses. hyperspace maps the current process's working set information into the kernel mode address space. session space is used to share the win and other session specific drivers among all the processes in the same terminal server session rather than all the processes in the system. the lower gb are specific to each process and are accessible by both user and kernel mode threads. certain configurations of windows xp reserve only gb for operating system use allowing a process to use gb of address space. running the system in gb mode drastically reduces the amount of data caching in the kernel. however for large applications that manage their own i o such as sql databases the advantage of a larger user mode address space may be worth the loss of caching. the windows xp vm manager uses a two step process to allocate user memory. the first step reserves a portion of the process's virtual address space. the second step commits the allocation by assigning virtual memory space physical memory or space in the paging files . windows xp limits the amount of virtual memory space a process consumes by enforcing a quota on committed memory. a process decommits memory that it is no longer using to free up virtual memory for use by other processes. the apis used to reserve virtual addresses and commit virtual memory take a handle on a process object as a parameter. this allows one process to control the virtual memory of another. environmental subsystems manage the memory of their client processes in this way. for performance the vm manager allows a privileged process to lock selected pages in physical memory thus ensuring that the pages are not paged out to the paging file. processes also allocate raw physical memory and then map regions into its virtual address space. ia processors with the physical address extension pae feature can have up to gb of physical memory on a system. this memory cannot all be mapped in a process's address space at once but windows xp makes it available using the address windowing extension awe apis which allocate physical memory and then map regions of virtual addresses in the process's address space onto part of the physical memory. the awe facility is used primarily by very large applications such as the sql database. chapter windows xp windows xp implements shared memory by defining a section dbject. after getting a handle to a section object a process maps the memory portion it needs into its address space. this portion is called a view. a process redefines its view of an object to gain access to the entire object one region at a time. a process can control the use of a shared memory section object in many ways. the maximum size of a section can be bounded. the section can be backed by disk space either in the system paging file or in a regular file a memory mapped file . a section can be based meaning the section appears at the same virtual address for all processes attempting to access it. finally the memory protection of pages in the section can be set to read only read write read write execute execute only no access or copy on write. the last two of these protection settings need some explanation a no access page raises an exception if accessed the exception is used for example to check whether a faulty program iterates beyond the end of an array. both the user mode memory allocator and the special kernel allocator used by the device verifier can be configured to map each allocation onto the end of a page followed by a no access page in order to detect buffer overruns. the copy on write mechanism increases the efficient use of physical memory by the vm manager. when two processes want independent copies of an object the vm manager places a single shared copy into virtual memory and activates the copy on write property for that region of memory. if one of the processes tries to modify data in a copy on write page the vm manager makes a private copy of the page for the process. the virtual address translation in windows xp uses a multilevel page table. for ia processors without the physical address extensions enabled page p gedirectory diregibiiy directory entry ..y .. . . f. entry page page page page page pagetabte tabled table table table table entry entry entry entry k k k k page page page page figure . page table layout. . system components each process has a page directory that contains page directory entries pdes of size bytes. each pde points to a page table that contains page table entries ptes of size bytes. each pte points to a kb page frame in physical memory. the total size of all page tables for a process is mb so the vm manager pages out individual tables to disk when necessary. see figure . for a diagram of this structure. the page directory and page tables are referenced by the hardware via physical addresses. to improve performance the vm manager self maps the page directory and page tables into a mb region of virtual addresses. the self map allows the vm manager to translate a virtual address into the corresponding pde or pte without additional memory accesses. when a process context is changed a single page directory entry needs to be changed to map the new process's page tables. for a variety of reasons the hardware requires that each page directory or page table occupy a single page. thus the number of pdes or ptes that fit in a page determine how virtual addresses are translated. the following describes how virtual addresses are translated into physical addresses on ia compatible processors without pae enabled . a bit value can represent all the values from to . thus a bit value can select any entry in the page directory or in a page table. this property is used when a virtual address pointer is translated to a byte address in physical memory. a bit virtual memory address is split into three values as shown in figure . . the first bits of the virtual address are used as an index into the page directory. this address selects one page directory entry pde which contains the physical page frame of a page table. the memory management unit mmu uses the next bits of the virtual address to select a pte from the page table. the pte specifies a page frame in physical memory. the remaining bits of the virtual address are the offset of a specific byte in the page frame. the mmu creates a pointer to the specific byte in physical memory by concatenating the bits from the pte with the lower bits from the virtual address. thus the bit pte has bits to describe the state of the physical page. the ia hardware reserves bits for use by the operating system. the rest of the bits specify whether the page has been accessed or written the caching attributes the access mode whether the page is global and whether the pte is valid. a processors running with pae enabled use bit pdes and ptes in order to represent the larger bit page frame number field. thus the secondlevel page directories and the page tables contain only pdes and ptes respectively. to provide gb of virtual address space requires an extra level of page directory containing four pdes. translation of a bit virtual address uses bits for the top level directory index and bits for each of the second level page directories and the page tables. pde pte page offset figure . virtual to physical address translation on ia . chapter windows xp to avoid the overhead of translating every virtual address by looking up the pde and pte processors use a translation lookaside buffer tlb which contains an associative memory cache for mapping virtual pages to ptes. unlike the ia architecture in which the tlb is maintained by the hardware mmu the ia invokes a software trap routine to supply translations missing from the tlb. this gives the vm manager flexibility in choosing the data structures to use. in windows xp a three level tree structure is chosen for mapping user mode virtual addresses on the ia . on ia processors the page size is kb but the ptes occupy bits so a page still contains only bits' worth of pdes or ptes. therefore with bits of top level pdes bits of second level bits of page table and bits of page offset the user portion of the process's virtual address space for windows xp on the ia is tb bits' worth . the tb limitation in the current version of windows xp is less than the capabilities of the ia processor but represents a tradeoff between the number of memory references required to handle tlb misses and the size of the user mode address space supported. a physical page can be in one of six states valid free zeroed modified standby bad or in transition. a valid page is in use by an active process. a free page is a page that is not referenced in a pte. a zeroed page is a free page that has been zeroed out and is ready for immediate use to satisfy zero on demand faults. a modified page is one that has been written by a process and must be sent to the disk before it is allocated for another process. a standby page is a copy of information already stored on disk. standby pages can be pages that were not modified modified pages that have already been written to the disk or pages that were prefetched to exploit locality. a bad page is unusable because a hardware error has been detected. finally a transition page is one that is on its way in from disk to a page frame allocated in physical memory. when the valid bit in a pte is zero the vm manager defines the format of the other bits. invalid pages can have a number of states represented by bits in the pte. page file pages that have never been faulted in are marked zero ondemand. files mapped through section objects encode a pointer to that section object. pages that have been written to the page file contain enough information to find the page on disk and so forth. the actual structure of the page file pte is shown in figure . . the pte contains bits for page protection bits for page file offset bits to select the paging file and bits that describe the page state. a page file pte is marked to be an invalid virtual address to the mmu. since executable code and memorymapped files already have a copy on disk they do not need space in a paging file. if one of these pages is not in physical memory the pte structure is as follows the most significant bit is used to specify the page protection the next . system components ! piagie address j p protection page v file i i ! figure . page file page table entry. the valid bit is zero. bits are used to index into a system data structure that indicates a file and offset within the file for the page and the lower bits specify the page state. invalid virtual addresses can also be in a number of temporary states that are part of the paging algorithms. when a page is removed from a process working set it is moved either to the modified list to be written to disk or directly to the standby list. if written to the standby list the page is reclaimed without being read from disk if it is needed again before it is moved to the free list. when possible the vm manager uses idle cpu cycles to zero pages on the free list and move them to the zeroed list. transition pages have been allocated a physical page and are awaiting the completion of the paging i o before the pte is marked as valid. windows xp uses section objects to describe pages that are sharable between processes. each process has its own set of virtual page tables but the section object also includes a set of page tables containing the master or prototype ptes. when a pte in a process page table is marked valid it points to the physical page frame containing the page as it must on ia processors where the hardware mmu reads the page tables directly from memory. but when a shared page is made invalid the pte is edited to point to the prototype pte associated with the section object. the page tables associated with a section object are virtual insofar as they are created and trimmed as needed. the only prototype ptes needed are those that describe pages for which there is a currently mapped view. this greatly improves performance and allows more efficient use of kernel virtual addresses. the prototype pte contains the page frame address and the protection and state bits. thus the first access by a process to a shared page generates a page fault. after the first access further accesses are performed in the normal manner. if a process writes to a copy on write page marked read only in the pte the vm manager makes a copy of the page and marks the pte writable and the process effectively does not have a shared page any longer. shared pages never appear in the page file but are instead found in the file system. the vm manager keeps track of all pages of physical memory in a pageframe database. there is one entry for every page of physical memory in the system. the entry points to the pte which in turn points to the page frame so the vm manager can maintain the state of the page. page frames not referenced by a valid pte are linked to lists according to page type such as zeroed modified or free. if a shared physical page is marked as valid for any process the page cannot be removed from memory. the vm manager keeps a count of valid ptes for each page in the page frame database. when the count goes to zero the chapter windows xp physical page can be reused once its contents have been written back tb disk if it was marked dirty . when a page fault occurs the vm manager finds a physical page to hold the data. for zero on demand pages the first choice is to find a page that has already been zeroed. if none is available a page from the free list or standby list is chosen and the page is zeroed before proceeding. if the faulted page has been marked as in transition it is either already being read in from disk or has been unmapped or trimmed and is still available on the standby or modified list. the thread either waits for the i o to complete or in the latter cases reclaims the page from the appropriate list. otherwise an i o must be issued to read the page in from the paging file or file system. the vm manager tries to allocate an available page from either the free list or the standby list. pages in the modified list cannot be used until they have been written back to disk and transferred to the standby list. if no pages are available the thread blocks until the working set manager trims pages from memory or a page in physical memory is unmapped by a process. windows xp uses a per process first in first out fifo replacement policy to take pages from processes that are using more than their minimum workingset size. windows xp monitors the page faulting of each process that is at its minimum working set size and adjusts the working set size accordingly. when a process is started it is assigned a default minimum working set size of pages. the vm manager replaces and trims pages in the working set of a process according to their age. the age of a page is determined by how many trimming cycles have occurred without the pte. trimmed pages are moved to the standby or modified list depending on whether the modified bit is set in the page's pte. the vm manager does not fault in only the page immediately needed. research shows that the memory referencing of a thread tends to have a locality property when a page is used it is likely that adjacent pages will be referenced in the near future. think of iterating over an array or fetching sequential instructions that form the executable code for a thread. because of locality when the vm manager faults in a page it also faults in a few adjacent pages. this prefetching tends to reduce the total number of page faults. writes are also clustered to reduce the number of independent i o operations. in addition to managing committed memory the vm manager manages each process's reserved memory or virtual address space. each process has an associated splay tree that describes the ranges of virtual addresses in use and what the use is. this allows the vm manager to fault in page tables as needed. if the pte for a faulting address does not exist the vm manager searches for the address in the process's tree of virtual address descriptors vads and uses this information to fill in the missing pte and retrieve the page. in some cases a page table page itself may not exist such a page must be transparently allocated and initialized by the vm manager. . . . process manager the windows xp process manager provides services for creating deleting and using processes threads and jobs. it has no knowledge about parent child relationships or process hierarchies those refinements are left to the particular environmental subsystem that owns the process. the process manager is also . system components not involved in the scheduling of processes other than setting the priorities and affinities in processes and threads when they are created. thread scheduling takes place in the kernel dispatcher. each process contains one or more threads. processes themselves can be collected together into large units called job objects the use of job objects allows limits on cpu usage working set size and processor affinities that control multiple processes at once. job objects are used to manage large datacenter machines. an example of process creation in the win api environment is as follows. when a win api application calls createprocess . a message is sent to the win api subsystem to notify it that the process is being created. . createprocess in the original process then calls an api in the process manager of the nt executive to actually create the process. . the process manager calls the object manager to create a process object and returns the object handle to win api. . win api calls the process manager again to create a thread for the process and returns handles to the new process and thread. the windows xp apis for manipulating virtual memory and threads and for duplicating handles take a process handle so subsystems can perform operations on behalf of a new process without having to execute directly in the new process's context. once a new process is created the initial thread is created and an asynchronous procedure call is delivered to the thread to prompt the start of execution at the user mode image loader. the loader is an ntdll.dll which is a link library automatically mapped into every newly created process. windows xp also supports a unix fork style of process creation in order to support the posix environmental subsystem. although the win api environment calls the process manager from the client process posix uses the cross process nature of the windows xp apis to create the new process from within the subsystem process. the process manager also implements the queuing and delivery of asynchronous procedure calls apcs to threads. apcs are used by the system to initiate thread execution complete i o terminate threads and processes and attach debuggers. user mode code can also queue an apc to a thread for delivery of signal like notifications. to support posix the process manager provides apis that send alerts to threads to unblock them from system calls. the debugger support in the process manager includes the capability to suspend and resume threads and to create threads that begin in a suspended mode. there are also process manager apis that get and set a thread's register context and access another process's virtual memory. threads can be created in the current process they can also be injected into another process. within the executive existing threads can temporarily attach to another process. this method is used by worker threads that need to execute in the context of the process originating a work request. the process manager also supports impersonation. a thread running in a process with a security token belonging to one user can set a thread specific chapter windows xp token belonging to another user. this facility is fundamental to the clientserver computing model where services need to act on behalf of a variety of clients with different security ids. . . . local procedure call facility the implementation of windows xp uses a client server model. the environmental subsystems are servers that implement particular operating system personalities. the client server model is used for implementing a variety of operating system services besides the environmental subsystems. security management printer spooling web services network file systems plug andplay and many other features are implemented using this model. to reduce the memory footprint multiple services are often collected together into a few processes which then rely on the user mode thread pool facilities to share threads and wait for messages see section . . . . the operating system uses the local procedure call lpc facility to pass requests and results between client and server processes within a single machine. in particular lpc is used to request services from the various windows xp subsystems. lpc is similar in many respects to the rpc mechanisms used by many operating systems for distributed processing across networks but lpc is optimized for use within a single system. the windows xp implementation of open software foundation osf rpc often uses lpc as a transport on the local machine. lpc is a message passing mechanism. the server process publishes a globally visible connection port object. when a client wants services from a subsystem it opens a handle to the subsystem's connection port object and sends a connection request to the port. the server creates a channel and returns a handle to the client. the channel consists of a pair of private communication ports one for client to server messages and the other for server to client messages. communication channels support a callback mechanism so the client and server can accept requests when they would normally be expecting a reply. when an lpc channel is created one of three message passing techniques must be specified. . the first technique is suitable for small messages up to a couple of hundred bytes . in this case the port's message queue is used as intermediate storage and the messages are copied from one process to the other. . the second technique is for larger messages. in this case a sharedmemory section object is created for the channel. messages sent through the port's message queue contain a pointer and size information referring to the section object. this avoids the need to copy large messages. the sender places data into the shared section and the receiver views them directly. . the third technique uses the apis that read and write directly into a process's address space. the lpc provides functions and synchronization so a server can access the data in a client. . system components the win api window manager uses its own form of message passing that is independent of the executive lpc facilities. when a client asks for a connection that uses window manager messaging the server sets up three objects a dedicated server thread to handle requests a kb section object and an event pair object. an event pair object is a synchronization object that is used by the win api subsystem to provide notification when the client thread has copied a message to the win api server or vice versa. the section object passes the messages and the event pair object performs synchronization. window manager messaging has several advantages the section object eliminates message copying since it represents a region of shared memory. the event pair object eliminates the overhead of using the port object to pass messages containing pointers and lengths. the dedicated server thread eliminates the overhead of determining which client thread is calling the server since there is one server thread per client thread. the kernel gives scheduling preference to these dedicated server threads to improve performance. . . . i o manager the i o manager is responsible for file systems device drivers and network drivers. it keeps track of which device drivers filter drivers and file systems are loaded and it also manages buffers for i o requests. it works with the vm manager to provide memory mapped file i o and controls the windows xp cache manager which handles caching for the entire i o system. the i o manager is fundamentally asynchronous. synchronous i o is provided by explicitly waiting for an i o operation to complete. the i o manager provides several models of asynchronous i o completion including setting of events delivery of apcs to the initiating thread and use of i o completion ports which allow a single thread to process i o completions from many other threads. device drivers are arranged as a list for each device called a driver or i o stack because of how device drivers are added . the i o manager converts the requests it receives into a standard form called an i o request packet irp . it then forwards the irp to the first driver in the stack for processing. after each driver processes the irp it calls the i o manager either to forward it to the next driver in the stack or if all processing is finished to complete the operation on theirp. completions may occur in a different context from the original i o request. for example if a driver is performing its part of an i o operation and is forced to block for an extended time it may queue the irp to a worker thread to continue processing in the system context. in the original thread the driver returns a status indicating that the i o request is pending so that the thread can continue executing in parallel with the i o operation. irps may also be processed in interrupt service routines and completed in an arbitrary context. because some final processing may need to happen in the context that initiated chapter windows xp the i o the i o manager uses an apc to do final i o completion processing in the context of the originating thread. the stack model is very flexible. as a driver stack is built various drivers have the opportunity to insert themselves into the stack as filter drivers. filter drivers can examine and potentially modify each i o operation. mount management partition management and disk striping and mirroring are all examples of functionality implemented using filter drivers that execute beneath the file system in the stack. file system filter drivers execute above the file system and have been used to implement functionality such as hierarchical storage management single instancing of files for remote boot and dynamic format conversion. third parties also use file system filter drivers to implement virus detection. device drivers for windows xp are written to the windows driver model wdm specification. this model lays out all the requirements for device drivers including how to layer filter drivers share common code for handling power and plug and play requests build correct cancellation logic and so forth. because of the richness of the wdm writing a full wdm device driver for each new hardware device can involve an excessive amount of work. fortunately the port miniport model makes it unnecessary to do this. within a class of similar devices such as audio drivers scsi devices or ethernet controllers each instance of a device shares a common driver for that class called a port driver. the port driver implements the standard operations for the class and then calls device specific routines in the device's miniport driver to implement device specific functionality. . . . cache manager in many operating systems caching is done by the file system. instead windows xp provides a centralized caching facility. the cache manager works closely with the vm manager to provide cache services for all components under the control of the i o manager. caching in windows xp is based on files rather than raw blocks. the size of the cache changes dynamically according to how much free memory is available in the system. recall that the upper gb of a process's address space comprise the system area it is available in the context of all processes. the vm manager allocates up to one half of this space to the system cache. the cache manager maps files into this address space and uses the capabilities of the vm manager to handle file i o. the cache is divided into blocks of kb. each cache block can hold a view that is a memory mapped region of a file. each cache block is described by a virtual address control block vacb that stores the virtual address and file offset for the view as well as the number of processes using the view. the vacbs reside in a single array maintained by the cache manager. for each open file the cache manager maintains a separate vacb index array that describes the caching for the entire file. this array has an entry for each kb chunk of the file so for instance a mb file would have an entry vacb index array an entry in the vacb index array points to the vacb if that portion of the file is in the cache it is null otherwise. when the i o manager receives a file's user level read request the i o manager sends an irp to the device driver stack on which the file resides. the file system attempts to look . system components es s i o i o manager cached i o . . t . . eacwiraartager . . . data copy isip page fault vm itianagep figure . file i o. up the requested data in the cache manager unless the request specifically asks for a noncached read . the cache manager calculates which entry of that file's vacb index array corresponds to the byte offset of the request. the entry either points to the view in the cache or is invalid. if it is invalid the cache manager allocates a cache block and the corresponding entry in the vacb array and maps the view into the cache block. the cache manager then attempts to copy data from the mapped file to the caller's buffer. if the copy succeeds the operation is completed. if the copy fails it does so because of a page fault which causes the vm manager to send a noncached read request to the i o manager. the i o manager sends another request down the driver stack this time requesting a paging operation which bypasses the cache manager and reads the data from the file directly into the page allocated for the cache manager. upon completion the vacb is set to point at the page. the data now in the cache are copied to the caller's buffer and the original i o request is completed. figure . shows an overview of these operations. when possible for synchronous operations on cached files i o is handled by the fast i o mechanism. this mechanism parallels the normal irp based i o but calls into the driver stack directly rather than passing down an irp. because no irp is involved the operation should not block for an extended period of time and cannot be queued to a worker thread. therefore when the operation reaches the file system and calls the cache manager the operation fails if the information is not already in cache. the i o manager then attempts the operation using the normal irp path. a kernel level read operation is similar except that the data can be accessed directly from the cache rather than being copied to a buffer in user space. to use file system metadata data structures that describe the file system the kernel uses the cache manager's mapping interface to read the metadata. to modify the metadata the file system uses the cache manager's pinning interface. pinning a page locks the page into a physical memory page frame so that the vm manager cannot move or page out the page. after updating chapter windows xp the metadata the file system asks the cache manager to unpin the page. a modified page is marked dirty and so the vm manager flushes the page to disk. the metadata is stored in a regular file. to improve performance the cache manager keeps a small history of read requests and from this history attempts to predict future requests. if the cache manager finds a pattern in the previous three requests such as sequential access forward or backward it prefetches data into the cache before the next request is submitted by the application. in this way the application finds its data already cached and does not need to wait for disk i o. the win api dpenfile and c r e a t e f i l e o functions can be passed the file flag sequential scan flag which is a hint to the cache manager to try to prefetch kb ahead of the thread's requests. typically windows xp performs i o operations in chunks of kb or pages thus this read ahead is three times the normal amount. the cache manager is also responsible for telling the vm manager to flush the contents of the cache. the cache manager's default behavior is write back caching it accumulates writes for to seconds and then wakes up the cachewriter thread. when write through caching is needed a process can set a flag when opening the file or the process can call an explicit cache flush function. a fast writing process could potentially fill all the free cache pages before the cache writer thread had a chance to wake up and flush the pages to disk. the cache writer prevents a process from flooding the system in the following way. when the amount of free cache memory becomes low the cache manager temporarily blocks processes attempting to write data and wakes the cachewriter thread to flush pages to disk. if the fast writing process is actually a network redirector for a network file system blocking it for too long could cause network transfers to time out and be retransmitted. this retransmission would waste network bandwidth. to prevent such waste network redirectors can instruct the cache manager to limit the backlog of writes in the cache. because a network file system needs to move data between a disk and the network interface the cache manager also provides a dma interface to move the data directly. moving data directly avoids the need to copy data through an intermediate buffer. . . . security reference monitor centralizing management of system entities in the object manager enables windows xp to use a uniform mechanism to perform run time access validation and audit checks for every user accessible entity in the system. whenever a process opens a handle to an object the security reference monitor srm checks the process's security token and the object's access control list to see whether the process has the necessary rights. the srm is also responsible for manipulating the privileges in security tokens. special privileges are required for users to perform backup or restore operations on file systems overcome certain checks as an administrator debug processes and so forth. tokens can also be marked as being restricted in their privileges so that they cannot access objects that are available to most users. restricted tokens are primarily used to restrict the damage that can be done by execution of untrusted code. another responsibility of the srm is logging security audit events. a c security rating requires that the system have the ability to detect and log all . system components attempts to access system resources so that it is easier to trace attempts at unauthorized access. because the srm is responsible for making access checks it generates most of the audit records in the security event log. . . . plug and play and power managers the operating system uses the plug and play pnp manager to recognize and adapt to changes in the hardware configuration. for pnp to work both the device and the driver must support the pnp standard. the pnp manager automatically recognizes installed devices and detects changes in devices as the system operates. the manager also keeps track of resources used by a device as well as potential resources that could be used and takes care of loading the appropriate drivers. this management of hardware resources primarily interrupts and i o memory ranges has the goal of determining a hardware configuration in which all devices are able to operate. for example if device b can use interrupt and device a can use or then the pnp manager will assign to b and to a. in previous versions the user might have had to remove device a and reconfigure it to use interrupt before installing device b. the user thus had to study system resources before installing new hardware and had to determine which devices were using which hardware resources. the proliferation of pcmcia cards laptop docks and usb ieee infiniband and other hot pluggable devices also dictates the support of dynamically configurable resources. the pnp manager handles dynamic reconfiguration as follows. first it gets a list of devices from each bus driver for example pci usb . it loads the installed driver or installs one if necessary and sends an add device request to the appropriate driver for each device. the pnp manager figures out the optimal resource assignments and sends a s t a r t d e v i c e request to each driver along with the resource assignment for the device. if a device needs to be reconfigured the pnp manager sends a query stop request which asks the driver whether the device can be temporarily disabled. if the driver can disable the device then all pending operations are completed and new operations are prevented from starting. next the pnp manager sends a stop request it can then reconfigure the device with another s t a r t d e v i c e request. the pnp manager also supports other requests such as query remove. this request which is used when the user is getting ready to eject a pccard device operates in a fashion similar to query stop. the surprise remove request is used when a device fails or more likely when a user removes a pccard device without stopping it first. the remove request tells the driver to stop using the device and release all resources allocated to it. windows xp supports sophisticated power management. although these facilities are useful for home systems to reduce power consumption their primary application is for ease of use quicker access and extending the battery life of laptops. the system and individual devices can be moved to low power mode called standby or sleep mode when not in use so the battery is primarily directed at physical memory ram data retention. the system can turn itself back on when packets are received from the network a phone line to a modem rings or a user opens a laptop or pushes a soft power button. windows xp can also hibernate a system by storing physical memory contents to disk and chapter windows xp completely shutting down the machine then restoring the system at a later point before execution continues. further strategies for reducing power consumption are supported as well. rather than allowing it to spin in a processor loop when the cpu is idle windows xp moves the system to a state requiring lower power consumption. if the cpu is underutilized windows xp reduces the cpu clock speed which can save significant power. . . . registry windows xp keeps much of its configuration information in an internal database called the registry. a registry database is called a hive. there are separate hives for system information default user preferences software installation and security. because the information in the system hive is required in order to boot the system the registry manager is implemented as a component of the executive. every time the system successfully boots it saves the system hive as last known good. if the user installs software such as a device driver that produces a system hive configuration that will not boot the user can usually boot using the last known good configuration. damage to the system hive from installing third party applications and drivers is so common that windows xp has a component called system restore that periodically saves the hives as well as other software states like driver executables and configuration files so that the system can be restored to a previously working state in cases where the system boots but no longer operates as expected. . . . booting the booting of a windows xp pc begins when the hardware powers on and the bios begins executing from rom. the bios identifies the system device to be booted and loads and executes the bootstrap loader from the front of the disk. this loader knows enough about the file system format to load the ntldr program from the root directory of the system device. ntldr is used to determine which boot device contains the operating system. next the ntldr loads in the hal library the kernel and the system hive from the boot device. from the system hive it determines what device drivers are needed to boot the system the boot drivers and loads them. finally ntldr begins kernel execution. the kernel initializes the system and creates two processes. the system process contains all the internal worker threads and never executes in user mode. the first user mode process created is smss which is similar to the nit initialization process in unix. smss does further initialization of the system including establishing the paging files and loading device drivers and creates the vvinlogon and csrss processes. csrss is the win api subsystem. winlogon brings up the rest of the system including the lsass security subsystem and the remaining services needed to run the system. the system optimizes the boot process by pre loading files from disk based on previous boots of the system. disk access patterns at boot are also used to lay out system files on disk to reduce the number of i o operations required. the processes required to start the system are reduced by grouping services