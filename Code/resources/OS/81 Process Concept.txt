 a question that arises in discussing operating systems involves what to call all the cpu activities. a batch system executes jobs whereas a time shared system has user programs or tasks. even on a single user system such as microsoft windows a user may be able to run several programs at one time a word processor a web browser and an e mail package. even if the user can execute chapter processes only one program at a time the operating system may need to suppoft its own internal programmed activities such as memory management. in many respects all these activities are similar so we call all of them processes. the terms job and process are used almost interchangeably in this text. although we personally prefer the term process much of operating system theory and terminology was developed during a time when the major activity of operating systems was job processing. it would be misleading to avoid the use of commonly accepted terms that include the word job such as job scheduling simply because process has superseded job. . . the process informally as mentioned earlier a process is a program in execution. a process is more than the program code which is sometimes known as the text section. it also includes the current activity as represented by the value of the program counter and the contents of the processor's registers. a process generally also includes the process stack which contains temporary data such as function parameters return addresses and local variables and a data section which contains global variables. a process may also include a heap which is memory that is dynamically allocated during process run time. the structure of a process in memory is shown in figure . . we emphasize that a program by itself is not a process a program is a passive entity such as a file containing a list of instructions stored on disk often called an executable file whereas a process is an active entity with a program counter specifying the next instruction to execute and a set of associated resources. a program becomes a process when an executable file is loaded into memory. two common techniques for loading executable files are double clicking an icon representing the executable file and entering the name of the executable file on the command line as in prog. exe or a. out. although two processes may be associated with the same program they are nevertheless considered two separate execution sequences. for instance max stack heap data text figure . process in memory. . process concept .. x scheduler dispatch i o or event completion ' y i o or event wait figure . diagram of process state. several users may be running different copies of the mail program or the same user may invoke many copies of the web browser program. each of these is a separate process and although the text sections are equivalent the data heap and stack sections vary. it is also common to have a process that spawns many processes as it runs. we discuss such matters in section . . . . process state as a process executes it changes state. the state of a process is defined in part by the current activity of that process. each process may be in one of the following states new. the process is being created. running. instructions are being executed. waiting. the process is waiting for some event to occur such as an i o completion or reception of a signal . ready. the process is waiting to be assigned to a processor. terminated. the process has finished execution. these names are arbitrary and they vary across operating systems. the states that they represent are fotind on all systems however. certain operating systems also more finely delineate process states. it is important to realize that only one process can be running on any processor at any instant. many processes may be ready and limiting however. the state diagram corresponding to these states is presented in figure . . . . process control block each process is represented in the operating system by a process control block pcb also called a task control block. a pcb is shown in figure . . it contains many pieces of information associated with a specific process including these process state. the state may be new ready running waiting halted and soon. chapter processes process state process number program counter registers memory limits list of open files figure . process control block pcb . program counter. the counter indicates the address of the next instruction to be executed for this process. cpu registers. the registers vary in number and type depending on the computer architecture. they include accumulators index registers stack pointers and general purpose registers plus any condition code information. along with the program counter this state information must be saved when an interrupt occurs to allow the process to be continued correctly afterward figure . . cpu scheduling information. this information includes a process priority pointers to scheduling queues and any other scheduling parameters. chapter describes process scheduling. memory management information. this information may include such information as the value of the base and limit registers the page tables or the segment tables depending on the memory system used by the operating system chapter . accounting information. this information includes the amount of cpu and real time used time limits account mimbers job or process numbers and so on. i o status information. this information includes the list of i o devices allocated to the process a list of open files and so on. in brief the pcb simply serves as the repository for any information that may vary from process to process. . . threads the process model discussed so far has implied that a process is a program that performs a single thread of execution. for example when a process is running a word processor program a single thread of instructions is being executed. this single thread of control allows the process to perform only one task at one time. the user cannot simultaneously type in characters and run the spell checker within the same process for example. many modern operating systems have extended the process concept to allow a process to have multiple . process scheduling process p operating system process interrupt or system call executing save state into pcb mdle reload state from pcb idle j r terrupt or system call exe save state into pcb hdle reload state from pcb executing figure . diagram showing cpu switch from process to process. threads of execution and thus to perform more than one task at a time. chapter explores multithreaded processes in detail. . process scheduling the objective of multiprogramming is to have some process running at all times to maximize cpu utilization. the objective of time sharing is to switch the cpu among processes so frequently that users can interact with each program while it is running. to meet these objectives the process scheduler selects an available process possibly from a set of several available processes for program execution on the cpu. for a single processor system there will never be more than one running process. if there are more processes the rest will have to wait until the cpu is free and can be rescheduled. . . scheduling queues as processes enter the system they are put into a job queue which consists of all processes in the system. the processes that are residing in main memory and are ready and waiting to execute are kept on a list called the ready queue. this queue is generally stored as a linked list. a ready queue header contains pointers to the first and final pcbs in the list. each pcb includes a pointer field that points to the next pcb in the ready queue. the system also includes other queues. when a process is allocated the cpu it executes for a while and eventually quits is interrupted or waits for the occurrence of a particular event such as the completion of an i o request. chapter processes process representation in linux the process control block in the linux operating system is represented by the c structure task strtict. this structure contains all the necessary information for 'representing a process including the state of the process scheduling and memory management information list of open files and pointers to the process's parent and any of its children. a process's parent is the process that created it its children are any processes that it creates. some of these fields include pid t pid process identifier long state state of the process unsigned int time..slice scheduling information struct files struct files list of open files struct mm struct mm address space of this process for example the state of a process is represented by the field long state in this structure. within the linux kernel all active processes are represented using a doubly linked list of task struct and the kernel maintains a pointer current to the process currently executing on the system. this is shown in figure . . struct task struct struct task struct struct task struct process information process information process information current currently executing proccess figure active processes in linux. as an illustration of how the kernel might manipulate one of the fields in the task struct for a specified process let's assume the system would like to change the state of the process currently running to the value new .state. if current is a pointer to the process currently executing its state is changed with the following current state new..state suppose the process makes an i o request to a shared device such as a disk. since there are many processes in the system the disk may be busy with the i o request of some other process. the process therefore may have to wait for the disk. the list of processes waiting for a particular i o device is called a device queue. each device has its own device queue figure . . . process scheduling queue header pcb pcbz ready queue mag tape unit mag tape unit disk unit pcb terminal head unit tail figure . the ready queue and various i o device queues. a common representation for a discussion of process scheduling is a queueing diagram such as that in figure . . each rectangular box represents a queue. two types of queues are present the ready queue and a set of device queues. the circles represent the resources that serve the queues and the arrows indicate the flow of processes in the system. a new process is initially put in the ready queue. it waits there tmtil it is selected for execution or is dispatched. once the process is allocated the cpu and is executing one of several events could occur the process could issue an i o request and then be placed in an i o queue. the process could create a new subprocess and wait for the subprocess's termination. the process could be removed forcibly from the cpu as a result of an interrupt and be put back in the ready queue. in the first two cases the process eventually switches from the waiting state to the ready state and is then put back in the ready queue. a process continues this cycle until it terminates at which time it is removed from all queues and has its pcb and resources deallocated. . . schedulers a process migrates among the various scheduling queues throughout its lifetime. the operating system must select for scheduling purposes processes chapter processes i o request time slice expired fork a child wait for an interrupt figure . queueing diagram representation of process scheduling. from these queues in some fashion. the selection process is carried out by the appropriate scheduler. often in a batch system more processes are submitted than can be executed immediately. these processes are spooled to a mass storage device typically a disk where they are kept for later execution. the long term scheduler or job scheduler selects processes from this pool and loads them into memory for execution. the short term scheduler or cpu scheduler selects from among the processes that are ready to execute and allocates the cpu to one of them. the primary distinction between these two schedulers lies in frequency of execution. the short term scheduler must select a new process for the cpu frequently. a process may execute for only a few milliseconds before waiting for an i o request. often the short term scheduler executes at least once every milliseconds. because of the short time between executions the short term scheduler must be fast. if it takes milliseconds to decide to execute a process for milliseconds then percent of the cpu is being used wasted simply for scheduling the work. the long term scheduler executes much less frequently minutes may separate the creation of one new process and the next. the long term scheduler controls the degree of multiprogramming the number of processes in memory . if the degree of multiprogramming is stable then the average rate of process creation must be equal to the average departure rate of processes leaving the system. thus the long term scheduler may need to be invoked only when a process leaves the system. because of the longer interval between executions the long term scheduler can afford to take more time to decide which process should be selected for execution. it is important that the long term scheduler make a careful selection. in general most processes can be described as either l o bound or cpu bound. an i o bound process is one that spends more of its time doing i o than it spends doing computations. a cpu bound process in contrast generates i o requests infrequently using more of its time doing computations. it is important that the long term scheduler select a good process mix of i o bound and cpu bound . process scheduling swap in partially executed swap out swapped out processes end figure . addition of medium term scheduling to the queueing diagram. processes. if all processes are i o bound the ready queue will almost always be empty and the short term scheduler will have little to do. if all processes are cpu bound the i o waiting queue will almost always be empty devices will go unused and again the system will be unbalanced. the system with the best performance will thus have a combination of cpu bound and i o bound processes. on some systems the long term scheduler may be absent or minimal. for example time sharing systems such as unix and microsoft windows systems often have no long term scheduler but simply put every new process in memory for the short term scheduler. the stability of these systems depends either on a physical limitation such as the number of available terminals or on the self adjusting nature of human users. if the performance declines to unacceptable levels on a multiuser system some users will simply quit. some operating systems such as time sharing systems may introduce an additional intermediate level of scheduling. this medium term scheduler is diagrammed in figure . . the key idea behind a medium term scheduler is that sometimes it can be advantageous to remove processes from memory and from active contention for the cpu and thus reduce the degree of multiprogramming. later the process can be reintroduced into memory and its execution can be continued where it left off. this scheme is called swapping. the process is swapped out and is later swapped in by the medium term scheduler. swapping may be necessary to improve the process mix or because a change in memory requirements has overcommitted available memory requiring memory to be freed up. swapping is discussed in chapter . . . context switch as mentioned in . . interrupts cause the operating system to change a cpu from its current task and to run a kernel routine. such operations happen frequently on general purpose systems. when an interrupt occurs the system needs to save the current context of the process currently running on the cpu so that it can restore that context when its processing is done essentially suspending the process and then resuming it. the context is represented in the pcb of the process it includes the value of the cpu registers the process state see figure . and memory management information. generically we perform a state save of the current state of the cpu be it in kernel or user mode and then a state restore to resume operations. chapter processes switching the cpu to another process requires performing a stat save of the current process and a state restore of a different process. this task is known as a context switch. when a context switch occurs the kernel saves the context of the old process in its pcb and loads the saved context of the new process scheduled to run. context switch time is pure overhead because the system does no useful work while switching. its speed varies from machine to machine depending on the memory speed the number of registers that must be copied and the existence of special instructions such as a single instruction to load or store all registers . typical speeds are a few milliseconds. context switch times are highly dependent on hardware support. for instance some processors such as the sun ultrasparc provide multiple sets of registers. a context switch here simply requires changing the pointer to the current register set. of course if there are more active processes than there are register sets the system resorts to copying register data to and from memory as before. also the more complex the operating system the more work must be done during a context switch. as we will see in chapter advanced memory management techniques may require extra data to be switched with each context. for instance the address space of the current process must be preserved as the space of the next task is prepared for use. how the address space is preserved and what amount of work is needed to preserve it depend on the memory management method of the operating system