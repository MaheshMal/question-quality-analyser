 user's terminal. this job is complicated by the fact that several such processes may be running simultaneously and the t t y line discipline is responsible for attaching and detaching the terminal's input and output from the various processes connected to it as those processes are suspended or awakened by the user. other line disciplines also are implemented that have nothing to do with i o to a user process. the ppp and slip networking protocols are ways of encoding a networking connection over a terminal device such as a serial line. these protocols are implemented under linux as drivers that at one end appear to the terminal system as line disciplines and at the other end appear to the networking system as network device drivers. after one of these line disciplines has been enabled on a terminal device any data appearing on that terminal will be routed directly to the appropriate network device driver. . interprocess communication unix provides a rich environment for processes to communicate with each other. communication may be just a matter of letting another process know that some event has occurred or it may involve transferring data from one process to another. . . synchronization and signals the standard unix mechanism for informing a process that an event has occurred is the signal. signals canbe sent from any process to any other process with restrictions on signals sent to processes owned by another user. however a limited number of signals are available and they cannot carry information only the fact that a signal occurred is available to a process. signals are not generated only by processes. the kernel also generates signals internally for example it can send a signal to a server process when data arrive on a network channel to a parent process when a child terminates or to a waiting process when a timer expires. internally the linux kernel does not use signals to communicate with processes running in kernel mode. if a kernel mode process is expecting an event to occur it will not normally use signals to receive notification of that event. rather communication about incoming asynchronous events within the kernel is performed through the use of scheduling states and wait queue structures. these mechanisms allow kernel mode processes to inform one another about relevant events and they also allow events to be generated by device drivers or by the networking system. whenever a process wants to wait for some event to complete it places itself on a wait queue associated with that event and tells the scheduler that it is no longer eligible for execution. once the event has completed it will wake up every process on the wait queue. this procedure allows multiple processes to wait for a single event. for example if several processes are trying to read a file from a disk then they will all be awakened once the data have been read into memory successfully. although signals have always been the main mechanism for communicating asynchronous events among processes linux also implements the semaphore mechanism of system v unix. a process can wait on a semaphore chapter the linux system as easily as it can wait for a signal but semaphores have two advantages large numbers of semaphores can be shared among multiple independent processes and operations on multiple semaphores can be performed atomically. internally the standard linux wait queue mechanism synchronizes processes that are communicating with semaphores. . . passing of data among processes linux offers several mechanisms for passing data among processes. the standard unix pipe mechanism allows a child process to inherit a communication channel from its parent data written to one end of the pipe can be read at the other. under linux pipes appear as just another type of inode to virtual filesystem software and each pipe has a pair of wait queues to synchronize the reader and writer. unix also defines a set of networking facilities that can send streams of data to both local and remote processes. networking is covered in section . . two other methods of sharing data among processes are available. first shared memory offers an extremely fast way to communicate large or small amounts of data any data written by one process to a shared memory region can be read immediately by any other process that has mapped that region into its address space. the main disadvantage of shared memory is that on its own it offers no synchronization a process can neither ask the operating system whether a piece of shared memory has been written to nor suspend execution until such a write occurs. shared memory becomes particularly powerful when used in conjunction with another interprocess communication mechanism that provides the missing synchronization. a shared memory region in linux is a persistent object that can be created or deleted by processes. such an object is treated as though it were a small independent address space. the linux paging algorithms can elect to page out to disk shared memory pages just as they can page out a process's data pages. the shared memory object acts as a backing store for shared memory regions just as a file can act as a backing store for a memory mapped memory region. when a file is mapped into a virtual address space region then any page faults that occur cause the appropriate page of the file to be mapped into virtual memory. similarly shared memory mappings direct page faults to map in pages from a persistent shared memory object. also just as for files sharedmemory objects remember their contents even if no processes are currently mapping them into virtual memory