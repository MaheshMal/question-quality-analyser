 computers can store information on various storage media such as magnetic disks magnetic tapes and optical disks. so that the computer system will be convenient to use the operating system provides a uniform logical view of information storage. the operating system abstracts from the physical properties of its storage devices to define a logical storage unit the file. files are mapped by the operating system onto physical devices. these storage devices are usually nonvolatile so the contents are persistent through power failures and system reboots. chapter file system interface a file is a named collection of related information that is recorded on secondary storage. from a user's perspective a tile is the smallest allotment of logical secondary storage that is data cannot be written to secondary storage unless they are within a file. commonly files represent programs both source and object forms and data. data files may be numeric alphabetic alphanumeric or binary. files may be free form such as text files or may be formatted rigidly. in general a file is a sequence of bits bytes lines or records the meaning of which is defined by the file's creator and user. the concept of a file is thus extremely general. the information in a file is defined by its creator. many different types of information may be stored in a file source programs object programs executable programs numeric data text payroll records graphic images sound recordings and so on. a file has a certain defined structure which depends on its type. a text file is a sequence of characters organized into lines and possibly pages . a source file is a sequence of subroutines and functions each of which is further organized as declarations followed by executable statements. an object file is a sequence of bytes organized into blocks understandable by the system's linker. an executable file is a series of code sections that the loader can bring into memory and execute. . . file attributes a file is named for the convenience of its human users and is referred to by its name. a name is usually a string of characters such as example.c. some systems differentiate between uppercase and lowercase characters in names whereas other systems do not. when a file is named it becomes independent of the process the user and even the system that created it. for instance one user might create the file example.c and another user might edit that file by specifying its name. the file's owner might write the file to a floppy disk send it in an e mail or copy it across a network and it could still be called example.c on the destination system. a file's attributes vary from one operating system to another but typically consist of these s name. the symbolic file name is the only information kept in humanreadable form . identifier. this unique tag usually a number identifies the file within the file system it is the non human readable name for the file. type. this information is needed for systems that support different types of files. location. this information is a pointer to a device and to the location of the file on that device. size. the current size of the file in bytes words or blocks and possibly the maximum allowed size are included in this attribute. protection. access control information determines who can do reading writing executing and so on. . file concept time date and user identification. this information may be kept for creation last modification and last use. these data can be useful for protection security and usage monitoring. the information about all files is kept in the directory structure which also resides on secondary storage. typically a directory entry consists of the file's name and its unique identifier. the identifier in turn locates the other file attributes. it may take more than a kilobyte to record this information for each. file. in a system with many files the size of the directory itself may be megabytes. because directories like files must be nonvolatile they must be stored on the device and brought into memory piecemeal as needed. . file operations a file is an abstract data type. to define a file properly we need to consider the operations that can be performed on files. the operating system can provide system calls to create write read reposition delete and truncate files. let's examine what the operating system must do to perform each of these six basic file operations. it should then be easy to see how other similar operations such as renaming a file can be implemented. creating a file. two steps are necessary to create a file. first space in the file system must be found for the file. we discuss how to allocate space for the file in chapter . second an entry for the new file must be made in the directory. writing a file. to write a file we make a system call specifying both the name of the file and the information to be written to the file. given the name of the file the system searches the directory to find the file's location. the system must keep a write pointer to the location in the file where the next write is to take place. the write pointer must be updated whenever a write occurs. reading a file. to read from a file we use a system call that specifies the name of the file and where in memory the next block of the file should be put. again the directory is searched for the associated entry and the system needs to keep a read pointer to the location in the file where the next read is to take place. once the read has taken place the read pointer is updated. because a process is usually either reading from or writing to a file the current operation location can be kept as a per process currentfile position pointer. both the read and write operations use this same pointer saving space and reducing system complexity. repositioning within a file. the directory is searched for the appropriate entry and the current file position pointer is repositioned to a given value. repositioning within a file need not involve any actual i o. this file operation is also known as a file seek. deleting a file. to delete a file we search the directory for the named file. having found the associated directory entry we release all file space so that it can be reused bv other files and erase the directory entry. chapter file system interface truncating a file. the user may want to erase the contents of a file but keep its attributes. rather than forcing the user to delete the file and then recreate it this function allows all attributes to remain unchanged except for file length but lets the tile be reset to length zero and its file space released. these six basic operations comprise the minimal set of required file operations. other common operations include appending new information to the end of an existing file and renaming an existing file. these primitive operations can then be combined to perform other file operations. for instance we can create a copy of a file or copy the file to another i o device such as a printer or a display by creating a new file and then reading from the old and writing to the new. we also want to have operations that allow a user to get and set the various attributes of a file. for example we may want to have operations that allow a user to determine the status of a file such as the file's length and to set file attributes such as the file's owner. most of the file operations mentioned involve searching the directory for the entry associated with the named file. to avoid this constant searching many systems require that an openo system call be made before a file is first used actively. the operating system keeps a small table called the open file table containing information about all open files. when a file operation is requested the file is specified via an index into this table so no searching is required. when the file is no longer being actively used it is closed by the process and the operating system removes its entry from the open file table c r e a t e and d e l e t e are system calls that work with closed rather than open files. some systems implicitly open a file when the first reference to it is made. the file is automatically closed when the job or program that opened the file terminates. most systems however require that the programmer open a file explicitly with the openo system call before that file can be used. the openo operation takes a file name and searches the directory copying the directory entry into the open file table. the openo call can also accept accessmode information create read only read write append only and so on. this mode is checked against the file's permissions. if the request mode is allowed the file is opened for the process. the openo system call typically returns a pointer to the entry in the open file table. this pointer not the actual file name is used in all i o operations avoiding any further searching and simplifying the system call interface. the implementation of the openo and close operations is more complicated in an environment where several processes may open the file at the same time. this may occur in a system where several different applications open the same file at the same time. typically the operating system uses two levels of internal tables a per process table and a system wide table. the perprocess table tracks all files that a process has open. stored in this table is information regarding the use of the file by the process. for instance the current file pointer for each file is found here. access rights to the file and accounting information can also be included. each entry in the per process table in turn points to a system wide open file table. the system wide table contains process independent information such as the location of the file on disk access dates and file size. once a file has been opened by one process the system wide table includes an entry for the file. . file concept when another process executes an openq call a new entry is simply added to the process's open file table pointing to the appropriate entry in the systemwide table. typically. the open file table also has an open count associated with each file to indicate how many processes have the file open. each close decreases this open count and when the open count reaches zero the file is no longer in use and the file's entry is removed from the open file table. in summary several pieces of information are associated with an open file. file pointer. on systems that do not include a file offset as part of the reado and write system calls the system must track the last readwrite location as a current file position pointer. this pointer is unique to each process operating on the file and therefore must be kept separate from the on disk file attributes. file open count. as files are closed the operating system must reuse its open file table entries or it could run out of space in the table. because multiple processes may have opened a file the system must wait for the last file to close before removing the open file table entry. the file open counter tracks the number of opens and closes and reaches zero on the last close. the system can then remove the entry. disk location of the file. most file operations require the system to modify data within the file. the information needed to locate the file on disk is kept in memory so that the system does not have to read it from disk for each operation. access rights. each process opens a file in an access mode. this information is stored on the per process table so the operating system can allow or deny subsequent i o requests. some operating systems provide facilities for locking an open file or sections of a file . file locks allow one process to lock a file and prevent other processes from gaining access to it. file locks are useful for files that are shared by several processes for example a system log file that can be accessed and modified by a number of processes in the system. li i the faya ?yn afcq u hng adeck requires for tlnevfite intended to be foekrf. thelaock mei ht is used to acquire the lock. the sj 't f t.h where begin an d erid are the beg i! tn ri g asd nsjn d tti bs o tlig region ibelng loeked. isetr b g sriared i t fco?sje iis ft ihafes ilcjcmsji seltilng isflffii'el to f a l s e acquires the xock excitjtslvely thfi fpek is !eased by iflvplsiilig the r e l e a s e of the fileloick retiurredby tfee lockv optjratipn. acquires two locks oni the fi le ifc fif th e fir t ht f oshfcfife exclusive lock the lock far the second half is a shared lock. chapter file system interface .impairs java. ait! . ctjaniiel ss . piitflic s na tig. final fesoleg .v.v. .ll . .. . . randarfiagcessfire r a f . ns.w 'raildoinsc c e s s p i l e ei l.e . txt' get. the .channel fcr the file .fil.echannel ch raf gefchannel . this locks the first half of t e file sxoluaive e h i o e k to . raf . leketiih j i exigl stve mow modify the data . . . release the lock exdusiveloclv. release this locks the second r.alf c the file shared sharedlock ch . lock raf.. ienc h raf length shared. kow read the data ... ' ii release the lock exclusivelock.release catch j ava . io . ioexcept.ior. ioe i systetr..err pri.ntln ioej sfve ogk ! s hull . sharedlcck.releasei i t figure b. kle ldekiifig exartipte m file locks provide functionality similar to reader writer locks covered in section . . . a shared lock is akin to a reader lock in that several processes can acquire the lock concurrently. an exclusive lock behaves like a writer lock only one process at a time can acquire such a lock. it is important to note . file concept that not all operating systems provide both types of locks some systems only provide exclusive file locking. furthermore operating systems may provide either mandatory or advisory file locking mechanisms. if a lock is mandatory then once a process acquires an exclusive lock the operating system will prevent any other process from accessing the locked file. for example assume a process acquires an exclusive lock on the file system.log. if we attempt to open system.log from another process for example a text editor the operating system will prevent access until the exclusive lock is released. this occurs even if the text editor is not written explicitly to acquire the lock. alternatively if the lock is advisory then the operating system will not prevent the text editor from acquiring access to system. log. rather the text editor must be written so that it manually acquires the lock before accessing the file. in other words if the locking scheme is mandatory the operating system ensures locking integrity. for advisory locking it is up to software developers to ensure that locks are appropriately acquired and released. as a general rule windows operating systems adopt mandatory locking and unix systems employ advisory locks. the use of file locks requires the same precautions as ordinary process synchronization. for example programmers developing on systems with mandatory locking must be careful to hold exclusive file locks only while they are accessing the file otherwise they will prevent other processes from accessing the file as well. furthermore some measures must be taken to ensure that two or more processes do not become involved in a deadlock while trying to acquire file locks. . . fiie types when we design a file system indeed an entire operating system we always consider whether the operating system should recognize and support file types. if an operating system recognizes the type of a file it can then operate on the file in reasonable ways. for example a common mistake occurs when a user tries to print the binary object form of a program. this attempt normally produces garbage however the attempt can succeed if the operating system has been told that the file is a binary object program. a common technique for implementing file types is to include the type as part of the file name. the name is split into two parts a name and an extension usually separated by a period character figure . . in this way the user and the operating system can tell from the name alone what the type of a file is. for example most operating systems allow users to specify file names as a sequence of characters followed by a period and terminated by an extension of additional characters. file name examples include resume.doc scrver.java and readerthread.c. the system uses the extension to indicate the type of the file and the type of operations that can be done on that file. only a file with a .com .cxe or .bat extension can be executed for instance. the .com and .exe files are two forms of binary executable files whereas a .bat file is a batch file containing in ascii format commands to the operating system. ms dos recognizes only a few extensions but application programs also use extensions to indicate file types in which they are interested. for example assemblers expect source files to have an .asm extension and the microsoft word word processor expects its files to end with a .doc extension. these extensions are not required so a user may chapter file system interface multimedia may rm binary file containing mp auicito or a v informcition figure . common file types. specify a file without the extension to save typing and the application will look for a file with the given name and the extension it expects. because these extensions are not supported by the operating system they can be considered as hints to the applications that operate on them. another example of the utility of file types comes from the tops operating system. if the user tries to execute an object program whose source file has been modified or edited since the object file was produced the source file will be recompiled automatically. this function ensures that the user always runs an up to date object file. otherwise the user could waste a significant amount of time executing the old object file. for this function to be possible the operating system must be able to discriminate the source file from the object file to check the time that each file was created or last modified and to determine the language of the source program in order to use the correct compiler . consider too the mac os x operating system. in this system each file has a type such as text for text file or appl for application . each file also has a creator attribute containing the name of the program that created it. this attribute is set by the operating system during the create call so its use is enforced and supported by the system. for instance a file produced by a word processor has the word processor's name as its creator. when the user opens that file by double clicking the mouse on the icon representing the file the word processor is invoked automatically and the file is loaded ready to be edited. . file concept the unix system uses a crude magic number stored at the beginning of some files to indicate roughly the type of the file executable program batch file or shell script postscript file and so on. not all files have magic numbers so system features cannot be based solely on this information. unix does not record the name of the creating program either. unix does allow file nameextension hints but these extensions are neither enforced nor depended on by the operating system they are meant mostly to aid users in determining the type of contents of the file. extensions can be used or ignored by a given application but that is up to the application's programmer. . . file structure file types also can be used to indicate the internal structure of the file. as mentioned in section . . source and object files have structures that match the expectations of the programs that read them. further certain files must conform to a required structure that is understood by the operating system. for example the operating system requires that an executable file have a specific structure so that it can determine where in memory to load the file and what the location of the first instruction is. some operating systems extend this idea into a set of system supported file structures with sets of special operations for manipulating files with those structures. for instance dec's vms operating system has a file system that supports three defined file structures. this point brings us to one of the disadvantages of having the operating system support multiple file structures the resulting size of the operating system is cumbersome. if the operating system defines five different file structures it needs to contain the code to support these file structures. in addition every file may need to be definable as one of the file types supported by the operating system. when new applications require information structured in ways not supported by the operating system severe problems may result. for example assume that a system supports two types of files text files composed of ascii characters separated by a carriage return and line feed and executable binary files. now if we as users want to define an encrypted file to protect the contents from being read by unauthorized people we may find neither file type to be appropriate. the encrypted file is not ascii text lines but rather is apparently random bits. although it may appear to be a binary file it is not executable. as a result we may have to circumvent or misuse the operating system's file types mechanism or abandon our encryption scheme. some operating systems impose and support a minimal number of file structures. this approach has been adopted in unix ms dos and others. unix considers each file to be a sequence of bit bytes no interpretation of these bits is made by the operating system. this scheme provides maximum flexibility but little support. each application program must include its own code to interpret an input file as to the appropriate structure. however all operating systems must support at least one structure that of an executable file so... that the system is able to load and run programs. the macintosh operating system also supports a minimal number of file structures. it expects files to contain two parts a resource fork and a data fork. the resource fork contains information of interest to the user. for instance it holds the labels of any buttons displayed by the program. a foreign user may want to re label these buttons in his own language and chapter file system interface the macintosh operating system provides tools to allow modification ef the data in the resource fork. the data fork contains program code or data the traditional file contents. to accomplish the same task on a unix or ms dos system the programmer would need to change and recompile the source code unless she created her own user changeable data file. clearly it is useful for an operating system to support structures that will be used frequently and that will save the programmer substantial effort. too few structures make programming inconvenient whereas too many cause operating system bloat and programmer confusion. . . internal file structure internally locating an offset within a file can be complicated for the operating system. disk systems typically have a well defined block size determined by the size of a sector. all disk i o is performed in units of one block physical record and all blocks are the same size. it is unlikely that the physical record size will exactly match the length of the desired logical record. logical records may even vary in length. packing a number of logical records into physical blocks is a common solution to this problem. for example the unix operating system defines all files to be simply streams of bytes. each byte is individually addressable by its offset from the beginning or end of the file. in this case the logical record size is byte. the file system automatically packs and unpacks bytes into physical disk blocks say bytes per block as necessary. the logical record size physical block size and packing technique determine how many logical records are in each physical block. the packing can be done either by the user's application program or by the operating system. in either case the file may be considered to be a sequence of blocks. all the basic i o functions operate in terms of blocks. the conversion from logical records to physical blocks is a relatively simple software problem. because disk space is always allocated in blocks some portion of the last block of each file is generally wasted. if each block were bytes for example then a file of bytes would be allocated four blocks bytes the last bytes would be wasted. the waste incurred to keep everything in units of blocks instead of bytes is internal fragmentation. all file systems suffer from internal fragmentation the larger the block size the greater the internal fragmentation