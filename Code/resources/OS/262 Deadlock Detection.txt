 if a system does not employ either a deadlock prevention or a deadlockavoidance algorithm then a deadlock situation may occur. in this environment the system must provide an algorithm that examines the state of the system to determine whether a deadlock has occurred an algorithm to recover from the deadlock in the following discussion we elaborate on these two requirements as they pertain to systems with only a single instance of each resource type as well as to systems with several instances of each resource type. at this point however we note that a detection and recovery scheme requires overhead that includes not only the run time costs of maintaining the necessary information and executing the detection algorithm but also the potential losses inherent in recovering from a deadlock. . . single instance of each resource type if all resources have only a single instance then we can define a deadlockdetection algorithm that uses a variant of the resource allocation graph called a wait for graph. we obtain this graph from the resource allocation graph by removing the resource nodes and collapsing the appropriate edges. more precisely an edge from p to p in a wait for graph implies that process p is waiting for process p to release a resource that p needs. an edge p p exists in a wait for graph if and only if the corresponding resourceallocation graph contains two edges p r j and r p for some resource . deadlock detection figure . a resource allocation graph b corresponding wait for graph. r . for example in figure . we present a resource allocation graph and. the corresponding wait for graph. as before a deadlock exists in the system if and only if the wait for graph contains a cycle. to detect deadlocks the system needs to maintain the wait for graph and periodically invoke an algorithm that searches for a cycle in the graph. an algorithm to detect a cycle in a graph requires an order of n operations where n is the number of vertices in the graph. . . several instances of a resource type the wait for graph scheme is not applicable to a resource allocation system with multiple instances of each resource type. we turn now to a deadlockdetection algorithm that is applicable to such a system. the algorithm employs several time varying data structures that are similar to those used in the banker's algorithm section . . available. a vector of length m indicates the number of available resources of each type. allocation. an n x m matrix defines the number of resources of each type currently allocated to each process. request. an n x in matrix indicates the current request of each process. if request i j equals k then process p is requesting k more instances of resource type rj. the s relation between two vectors is defined as in section . . . to simplify notation we again treat the rows in the matrices allocation and request as vectors we refer to them as allocation and request . the detection algorithm chapter deadlocks described here simply investigates every possible allocation sequence f r the processes that remain to be completed. compare this algorithm with the banker's algorithm of section . . . . let work and finish be vectors of length in and n respectively. initialize work available. for i ... n if allocation then finish i false otherwise finisli i true. . find an index i such that both a. finish i false b. requesti work if no such exists go to step . . work work allocation! finish i true go to step . . if finish i false for some ' n then the system is in a deadlocked state. moreover if finish i false then process p is deadlocked. this algorithm requires an order of in x n operations to detect whether the system is in a deadlocked state. you may wonder why we reclaim the resources of process p in step as soon as we determine that request work in step b . we know that p is currently not involved in a deadlock since request work . thus we take an optimistic attitude and assume that p will require no more resources to complete its task it will thus soon return all currently allocated resources to the system. if our assumption is incorrect a deadlock may occur later. that deadlock will be detected the next time the deadlock detection algorithm is invoked. to illustrate this algorithm we consider a system with five processes pq through p and three resource types a b and c. resource type a has seven instances resource type b has two instances and resource type c has six instances. suppose that at time to we have the following resource allocation state allocation request available abc abc abc po pj p p p we claim that the system is not in a deadlocked state. indeed if we execute our algorithm we will find that the sequence pn pi pi p pa results in finish i true for all i. . deadlock detection suppose now that process pj makes one additional request for an instance of type c. the request matrix is modified as follows reilitest a bc pi! a i pi p pi we claim that the system is now deadlocked. although we can reclaim the resources held by process po the number of available resources is not sufficient to fulfill the requests of the other processes. thus a deadlock exists consisting of processes pi pi p and p . . . detection algorithm usage when should we invoke the detection algorithm? the answer depends on two factors . how often is a deadlock likely to occur? . how many processes will be affected by deadlock when it happens? if deadlocks occur frequently then the detection algorithm should be invoked frequently. resources allocated to deadlocked processes will be idle until the deadlock can be broken. in addition the number of processes involved in the deadlock cycle may grow. deadlocks occur only when some process makes a request that cannot be granted immediately. this request may be the final request that completes a chain of waiting processes. in the extreme we can invoke the deadlockdetection algorithm every time a request for allocation cannot be granted immediately. in this case we can identify not only the deadlocked set of processes but also the specific process that caused the deadlock. in reality each of the deadlocked processes is a link in the cycle in the resource graph so all of them jointly caused the deadlock. if there are many different resource types one request may create many cycles in the resource graph each cycle completed by the most recent request and caused by the one identifiable process. of course if the deadlock detection algorithm is invoked for every resource request this will incur a considerable overhead in computation time. a less expensive alternative is simply to invoke the algorithm at less frequent intervals for example once per hour or whenever cpu utilization drops below percent. a deadlock eventually cripples system throughput and causes cpu utilization to drop. if the detection algorithm is invoked at arbitrary points in time there may be many cycles in the resource graph. in this case we would generally not be able to tell which of the many deadlocked processes caused the deadlock. chapter? deadlocks