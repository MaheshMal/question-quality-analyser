 the deadlock prevention deadlock avoidance and deadlock detection algorithms presented in chapter can be extended so that they can be used in a distributed system. in this section we describe several of these distributed algorithms. . . deadlock prevention and avoidance the deadlock prevention and deadlock avoidance algorithms presented in chapter can be used in a distributed system provided that appropriate modifications are made. for example we can use the resource ordering deadlock prevention technique by simply defining a global ordering among the system resources. that is all resources in the entire system are assigned unique numbers and a process may request a resource at any processor with . deadlock handling unique number only if it is not holding a resource with a unique number greater than i. similarly we can use the banker's algorithm in a distributed system by designating one of the processes in the system the banker as the process that maintains the information necessary to carry out the banker's algorithm. every resource request must be channelled through the banker. the global resource ordering deadlock prevention scheme is simple to implement in a distributed environment and requires little overhead. the banker's algorithm can also be implemented easily but it may require too much overhead. the banker may become a bottleneck since the number of messages to and from the banker may be large. thus the banker's scheme does not seem to be of practical use in a distributed system. we turn next to a new deadlock prevention scheme based on a timestampordering approach with resource preemption. although this approach can handle any deadlock situation that may arise in a distributed system for simplicity we consider only the case of a single instance of each resource type. to control the preemption we assign a unique priority number to each process. these numbers are used to decide whether a process p should wait for a process pj. for example we can let p wait for pj if p has a priority higher than that of pj otherwise p is rolled back. this scheme prevents deadlocks because for every edge p pj in the wait for graph p has a higher priority than pj. thus a cycle cannot exist. one difficulty with this scheme is the possibility of starvation. some processes with extremely low priorities may always be rolled back. this difficulty can be avoided through the use of timestamps. each process in the system is assigned a unique timestamp when it is created. two complementary deadlock prevention schemes using timestamps have been proposed . the wait die scheme. this approach is based on a nonpreemptive technique. when process p requests a resource currently held by pj pj is allowed to wait only if it has a smaller timestamp than does p that is p is older than p . otherwise p is rolled back dies . for example suppose that processes p p and p have timestamps and respectively. if pi requests a resource held by pi p will wait. if p requests a resource held by p p will be rolled back. . the wound wait scheme. this approach is based on a preemptive technique and is a counterpart to the wait die approach. when process p requests a resource currently held by p r pi is allowed to wait only if it has a larger timestamp than does pj that is p is younger than pj . otherwise pj is rolled back pj is wounded by p . returning to our previous example with processes pi p? and p if pi requests a resource held by pi then the resource will be preempted from pi and p will be rolled back. if p requests a resource held by p? then p will wait. both schemes can avoid starvation provided that when a process is rolled back it is not assigned a new timestamp. since timestamps always increase a process that is rolled back will eventually have the smallest timestamp. thus it will not be rolled back again. there are however significant differences in the way the two schemes operate. chapter distributed coordination in the wait die scheme an older process must wait for a younger one to release its resource. thus the older the process gets the more it tends to wait. by contrast in the wound wait scheme an older process never waits for a younger process. in the wait die scheme if a process p dies and is rolled back because it has requested a resource held by process pj then p may reissue the same sequence of requests when it is restarted. if the resource is still held by pj then pj will die again. thus p may die several times before acquiring the needed resource. contrast this series of events with what happens in the wound wait scheme. process p is wounded and rolled back because pj has requested a resource it holds. when p is restarted and requests the resource now being held by pj pi waits. thus fewer rollbacks occur in the wound wait scheme. the major problem with both schemes is that unnecessary rollbacks may occur. . . deadlock detection the deadlock prevention algorithm may preempt resources even if no deadlock has occurred. to prevent unnecessary preemptions we can use a deadlockdetection algorithm. we construct a wait for graph describing the resourceallocation state. since we are assuming only a single resource of each type a cycle in the wait for graph represents a deadlock. the main problem in a distributed system is deciding how to maintain the wait for graph. we illustrate this problem by describing several common techniques to deal with this issue. these schemes require each site to keep a local wait for graph. the nodes of the graph correspond to all the processes local as well as nonlocal currently holding or requesting any of the resources local to that site. for example in figure . we have a system consisting of two sites each maintaining its local wait for graph. note that processes pj and pj appear in both graphs indicating that the processes have requested resources at both sites. these local wait for graphs are constructed in the usual manner for local processes and resources. when a process p in site si needs a resource held by process p in site sj a request message is sent by p to site si. the edge p pj is then inserted in the local wait for graph of site s . sites site figure . two local wait for graphs. . deadlock handling figure . global wait for graph for figure . . clearly if any local wait for graph has a cycle deadlock has occurred. the fact that we find no cycles in any of the local wait for graphs does not mean that there are no deadlocks however. to illustrate this problem we consider the system depicted in figure . . each wait for graph is acyclic nevertheless a deadlock exists in the system. to prove that a deadlock has not occurred we must show that the union of all local graphs is acyclic. the graph figure . that we obtain by taking the union of the two wait for graphs of figure . does indeed contain a cycle implying that the system is in a deadlocked state. a number of methods are available to organize the wait for graph in a distributed system. we describe several common schemes here. . . . centralized approach in the centralized approach a global wait for graph is constructed as the union of all the local wait for graphs. it is maintained in a single process the deadlock detection coordinator. since there is communication delay in the system we must distinguish between two types of wait for graphs. the real graph describes the real but unknown state of the system at any instance in time as would be seen by an omniscient observer. the constructed graph is an approximation generated by the coordinator during the execution of its algorithm. the constructed graph must be generated so that whenever the detection algorithm is invoked the reported results are correct. by correct we mean the following if a deadlock exists then it is reported properly. if a deadlock is reported then the system is indeed in a deadlocked state. as we shall show it is not easy to construct such correct algorithms. the wait for graph may be constructed at three different points in time . whenever a new edge is inserted in or removed from one of the local wait for graphs . periodically when a number of changes have occurred in a wait for graph . whenever the deadlock detection coordinator needs to invoke the cycledetection algorithm when the deadlock detection algorithm is invoked the coordinator searches its global graph. if a cycle is found a victim is selected to be rolled back. the chapter distributed coordination coordinator must notify all the sites that a particular process has been sejected as victim. the sites in turn roll back the victim process. let us consider option . whenever an edge is either inserted in or removed from a local graph the local site must also send a message to the coordinator to notify it of this modification. on receiving such a message the coordinator updates its global graph. alternatively option a site can send a number of such changes in a single message periodically. returning to our previous example the coordinator process will maintain the global wait for graph as depicted in figure . . when site inserts the edge p p in its local wait for graph it also sends a message to the coordinator. similarly when site si deletes the edge p pi because pi has released a resource that was requested by p an appropriate message is sent to the coordinator. note that no matter which option is used unnecessary rollbacks may occur as a result of two situations . false cycles may exist in the global wait for graph. to illustrate this point we consider a snapshot of the system as depicted in figure . . suppose that p releases the resource it is holding in site si resulting in the deletion of the edge pi p in site si. process p then requests a resource held by p at site s resulting in the addition of the edge p p in site s . if the insert p p message from site s arrives before the delete p p message from site si the coordinator may discover the false cycle pi p p pl after the insert but before the delete . deadlock recovery may be initiated although no deadlock has occurred. . unnecessary rollbacks may also result when a deadlock has indeed occurred and a victim has been picked but at the same time one of the processes has been aborted for reasons unrelated to the deadlock as when a process has exceeded its allocated time . for example suppose that site si in figure . decides to abort p . at the same time the coordinator has discovered a cycle and picked p as a victim. both p? and p are now rolled back although only p needed to be rolled back. let us now consider a centralized deadlock detection algorithm using option that detects all deadlocks that actually occur and does not detect false deadlocks. to avoid the report of false deadlocks we require that requests from different sites be appended with unique identifiers or timestamps . when site si site s coordinator figure . local and global wait for graphs. . deadlock handling process p at site si requests a resource from p. at site s? a request message with timestamp ts is sent. the edge p p with the label ts is inserted'in the local wait for graph of si. this edge is inserted in the local wait for graph of site si only if site s? has received the request message and cannot immediately grant the requested resource. a request from p to p . in the same site is handled in the usual manner no timestamps are associated with the edge p pj. the detection algorithm is as follows . the controller sends an initiating message to each site in the system. . on receiving this message a site sends its local wait for graph to the coordinator. each of these wait for graphs contains all the local information the site has about the state of the real graph. the graph reflects an instantaneous state of the site but it is not synchronized with respect to any other site. . when the controller has received a reply from each site it constructs a graph as follows a. the constructed graph contains a vertex for every process in the system. b. the graph has an edge pj pj if and only if there is an edge p pj in one of the wait for graphs or an edge p pj with some label ts in more than one wait for graph. if the constructed graph contains a cycle then the system is in a deadlocked state. if the constructed graph does not contain a cycle then the system was not in a deadlocked state when the detection algorithm was invoked as result of the initiating messages sent by the coordinator in step . . . . fully distributed approach in the fully distributed deadlock detection algorithm all controllers share equally the responsibility for detecting deadlock. every site constructs a waitfor graph that represents a part of the total graph depending on the dynamic behavior of the system. the idea is that if a deadlock exists a cycle will appear in at least one of the partial graphs. we present one such algorithm which involves construction of partial graphs in every site. each site maintains its own local wait for graph. a local wait for graph in this scheme differs from the one described earlier in that we add one additional node p .v to the graph. an arc p pl x exists in the graph if p is waiting for a data item in another site being held by any process. similarly an arc pex pj exists in the graph if a process at another site is waiting to acquire a resource currently being held by pj in this local site. to illustrate this situation we consider again the two local wait for graphs of figure . . the addition of the node pl x in both graphs results in the local wait for graphs shown in figure . . if a local wait for graph contains a cycle that does not involve node pcx then the system is in a deadlocked state. if however a local graph contains a cycle involving pcxr then this implies the possibility of a deadlock. to ascertain whether a deadlock does exist we must invoke a distributed deadlock detection algorithm. chapter distributed coordination site s figure . augmented local wait for graphs of figure . . suppose that at site s the local wait for graph contains a cycle involving node pcx. this cycle must be of the form pcx pkl pk pkn pex which indicates that process pjt . in site s is waiting to acquire a data item located in some other site say sj. on discovering this cycle site s sends to site sj a deadlock detection message containing information about that cycle. when site sj receives this deadlock detection message it updates its local wait for graph with the new information. then it searches the newly constructed wait for graph for a cycle not involving pex. if one exists a deadlock is found and an appropriate recovery scheme is invoked. if a cycle involving pex is discovered then sj transmits a deadlock detection message to the appropriate site say s . site sk in return repeats the procedure. thus after a finite number of rounds either a deadlock is discovered or the deadlock detection computation halts. to illustrate this procedure we consider the local wait for graphs of figure . . suppose that site si discovers the cycle pcx pi pi pcx. since p is waiting to acquire a data item in site s? a deadlock detection message describing that cycle is transmitted from site si to site sz when site s receives this message it updates its local wait for graph obtaining the wait for graph of figure . . this graph contains the cycle p p p p which does not include node pcx. therefore the system is in a deadlocked state and an appropriate recovery scheme must be invoked. note that the outcome would be the same if site s discovered the cycle first in its local wait for graph and sent the deadlock detection message to site si. in the worst case both sites will discover the cycle at about the same time and two deadlock detection messages will be sent one by si to s and another by s to si. this situation results in unnecessary message transfer and overhead in updating the two local wait for graphs and searching for cycles in both graphs. to reduce message traffic we assign to each process p a unique identifier which we denote id p . when site sk discovers that its local wait for graph contains a cycle involving node pex of the form