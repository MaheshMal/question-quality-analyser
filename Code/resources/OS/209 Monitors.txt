 do wait chopstick i wait chopstick i eat signal chopstick i signal chopstick i think while true figure . the structure of philosopher i. allow a philosopher to pick up her chopsticks only if both chopsticks are available to do this she must pick them up in a critical section . use an asymmetric solution that is an odd philosopher picks up first her left chopstick and then her right chopstick whereas an even philosopher picks up her right chopstick and then her left chopstick. finally any satisfactory solution to the dining philosophers problem must guard against the possibility that one of the philosophers will starve to death. a deadlock free solution does not necessarily eliminate the possibility of starvation. . monitors although semaphores provide a convenient and effective mechanism for process synchronization using them incorrectly can result in timing errors that are difficult to detect since these errors happen only if some particular execution sequences take place and these sequences do not always occur. we have seen an example of such errors in the use of counters in our solution to the producer consumer problem section . . in that example the timing problem happened only rarely and even then the counter value appeared to be reasonable off by only nevertheless the solution is obviously not an acceptable one. it is for this reason that semaphores were introduced in the first place. unfortunately such timing errors can still occur when semaphores are used. to illustrate how we review the semaphore solution to the criticalsection problem. all processes share a semaphore variable mutex which is. initialized to . each process must execute wait mutex before entering the critical section and s i g n a l mutex afterward. if this sequence is not observed two processes may be in their critical sections simultaneously. let us examine the various difficulties that may result. note that these difficulties will arise even if a single process is not well behaved. this situation may be caused by an honest programming error or an uncooperative programmer. chapter process synchronization suppose that a process interchanges the order in which the wait j and signal operations on the semaphore mutex are executed resulting in the following execution signal mutex critical section wait mutex in this situation several processes may be executing in their critical sections simultaneously violating the rmitual exclusion requirement. this error may be discovered only if several processes are simultaneously active in their critical sections. note that this situation may not always be reproducible. suppose that a process replaces signal mutex with wait mutex . that is it executes wait mutex critical section wait mutex in this case a deadlock will occur. suppose that a process omits the wait mutex or the signal mutex or both. in this case either mutual exclusion is violated or a deadlock will occur. these examples illustrate that various types of errors can be generated easily when programmers use semaphores incorrectly to solve the critical section problem. similar problems may arise in the other synchronization models that we discussed in section . . to deal with such errors researchers have developed high level language constructs. in this section we describe one fundamental high level synchronization construct the monitor type. . . usage a type or abstract data type encapsulates private data with public methods to operate on that data. a monitor type presents a set of programmer defined operations that are provided mutual exclusion within the monitor. the monitor type also contains the declaration of variables whose values define the state of an instance of that type along with the bodies of procedures or functions that operate on those variables. the syntax of a monitor is shown in figure . . the representation of a monitor type cannot be used directly by the various processes. thus a procedure defined within a monitor can access only those variables declared locally within the monitor and its formal parameters. similarly the local variables of a monitor can be accessed by only the local procedures. . monitors monitor monitor name f ii shared variable declarations procedure pi ... procedure p . . . procedure pn . . . initialization code . . . figure . syntax of a monitor. the monitor construct ensures that only one process at a time can be active within the monitor. consequently the programmer does not need to code this synchronization constraint explicitly figure . . however the monitor construct as defined so far is not sufficiently powerful for modeling some synchronization schemes. for this purpose we need to define additional synchronization mechanisms. these mechanisms are provided by the condition construct. a programmer who needs to write a tailor made synchronization scheme can define one or more variables of type condition condition x y the only operations that can be invoked on a condition variable are wait and s i g n a l . the operation x.waito means that the process invoking this operation is suspended until another process invokes x.signal the x. s i g n a l operation resumes exactly one suspended process. if no process is suspended then the signal operation has no effect that is the state of x is the same as if the operation had never been executed figure . . contrast this operation with the signal operation associated with semaphores which always affects the state of the semaphore. chapter process synchronization figure . schematic view of a monitor. now suppose that when the x. s ignal operation is invoked by a process p there is a suspended process q associated with condition x. clearly if the suspended process q is allowed to resume its execution the signaling process p must wait. otherwise both p and q would be active simultaneously within the monitor. note however that both processes can conceptually continue with their execution. two possibilities exist . signal and wait. p either waits until q leaves the monitor or waits for another condition. . signal and continue. q either waits until p leaves the monitor or waits for another condition. there are reasonable arguments in favor of adopting either option. on the one hand since p was already executing in the monitor the signal and continue method seems more reasonable. on the other hand if we allow thread p to continue then by the time q is resumed the logical condition for which q was waiting may no longer hold. a compromise between these two choices was adopted in the language concurrent pascal. when thread p executes the signal operation it immediately leaves the monitor. hence q is immediately resumed. . . dining philosophers solution using monitors we now illustrate monitor concepts by presenting a deadlock free solution to the dining philosophers problem. this solution imposes the restriction that a philosopher may pick up her chopsticks only if both of them are available. to . monitors queues associated with f x yconditions initialization code figure . monitor with condition variables. code this solution we need to distinguish among three states in which we may find a philosopher. for this purpose we introduce the following data structure enum thinking hungry eating s t a t e philosopher i can set the variable state i eating only if her two neighbors are not eating state i ! eating and state i ! eating . we also need to declare condition self where philosopher ' can delay herself when she is hungry but is unable to obtain the chopsticks she needs. we are now in a position to describe our solution to the diiiing philosophers problem. the distribution of the chopsticks is controlled by the monitor dp whose definition is shown in figure . . each philosopher before starting to eat must invoke the operation pi ckup . this may result in the suspension of the philosopher process. after the successful completion of the operation the philosopher may eat. following this the philosopher invokes the putdowno operation. thus philosopher i must invoke the operations pi ckup and putdowno in the following sequence dp.pickup i eat dp.putdown i chapter process synchronization monitor dp enum thinking hungry eating state condition self void pickup int i state i hungry test i if state i ! eating self i .wait void putdown int i state til thinking test i test i void test int i if state i ! eating state i hungry state i ! eating state i eating self i .signal initialization code for int i i i state i thinking figure . a monitor solution to the dining philosopher problem. it is easy to show that this solution ensures that no two neighbors are eating simultaneously and that no deadlocks will occur. we note however that it is possible for a philosopher to starve to death. we do not present a solution to this problem but rather leave it as an exercise for you. . . implementing a monitor using semaphores we now consider a possible implementation of the monitor mechanism using semaphores. for each monitor a semaphore mutex initialized to is provided. a process must execute wait mutex before entering the monitor and must execute signal mutex after leaving the monitor. since a signaling process must wait until the resumed process either leaves or waits an additional semaphore next is introduced initialized to on which the signaling processes may suspend themselves. an integer variable . monitors next count is also provided to count the number of processes suspended on next. thus each external procedure f is replaced by uait mutex body of f if next count signal next else signal mutex mutual exclusion within a monitor is ensured. we can now describe how condition variables are implemented. for each condition x we introduce a semaphore x sem and an integer variable x count both initialized to . the operation x. wait can now be implemented as x count if next count signal next else signal mutex wait x sem x count the operation x. signal can be implemented as if x count next count signal x sem wait next next count this implementation is applicable to the definitions of monitors given by both hoare and brinch hansen. in some cases however the generality of the implementation is unnecessary and a significant improvement in efficiency is possible. we leave this problem to you in exercise . . . . resuming processes within a monitor we turn now to the subject of process resumption order within a monitor. if several processes are suspended on condition x and an x. signal operation is executed by some process then how do we determine which of the suspended processes should be resumed next? one simple solution is to use an fcfs ordering so that the process waiting the longest is resumed first. in many circumstances however such a simple scheduling scheme is not adequate. for this purpose the conditional wait construct can be used it has the form x.wait c chapter process synchronization monitor resourceallocator boolean busy condition x void acquire int time if busy x.wait time busy true void release busy false x.signal initialization code busy false figure . a monitor to allocate a single resource. where c is an integer expression that is evaluated when the wait operation is executed. the value of c which is called a priority number is then stored with the name of the process that is suspended. when x. signal is executed the process with the smallest associated priority number is resumed next. to illustrate this new mechanism we consider the resourceallocator monitor shown in figure . which controls the allocation of a single resource among competing processes. each process when requesting an allocation of this resource specifies the maximum time it plans to use the resource. the monitor allocates the resource to the process that has the shortest timeallocation request. a process that needs to access the resource in question must observe the following sequence r.acquire t access the resource r. releaseo where r is an instance of type resourceallocator. unfortunately the monitor concept cannot guarantee that the preceding access sequence will be observed. in particular the following problems can occur a process might access a resource without first gaining access permission to the resource. a process might never release a resource once it has been granted access to the resource