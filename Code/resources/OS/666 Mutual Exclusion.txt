 in this section we present a number of different algorithms for implementing mutual exclusion in a distributed environment. we assume that the system consists of n processes each of which resides at a different processor. to simplify our discussion we assume that processes are numbered uniquely from to n and that a one to one mapping exists between processes and processors that is each process has its own processor . . . centralized approach in a centralized approach to providing mutual exclusion one of the processes in the system is chosen to coordinate the entry to the critical section. each process that wants to invoke mutual exclusion sends a request message to the coordinator. when the process receives a reply message from the coordinator it can proceed to enter its critical section. after exiting its critical section the process sends a release message to the coordinator and proceeds with its execution. on receiving a request message the coordinator checks to see whether some other process is in its critical section. if no process is in its critical section the coordinator immediately sends back a reply message. otherwise the request is queued. when the coordinator receives a release message it removes one of the request messages from the queue in accordance with some scheduling algorithm and sends a reply message to the requesting process. it should be clear that this algorithm ensures mutual exclusion. in addition if the scheduling policy within the coordinator is fair such as first come firstserved fcfs scheduling no starvation can occur. this scheme requires three messages per critical section entry a request a reply and a release. if the coordinator process fails then a new process must take its place. in section . we describe some algorithms for electing a unique new coordinator. once a new coordinator has been elected it must poll all the processes in the system to reconstruct its request queue. once the queue has been constructed the computation can resume. . . fully distributed approach if we want to distribute the decision making across the entire system then the solution is far more complicated. one approach described next uses an algorithm based on the event ordering scheme described in section . . when a process p wants to enter its critical section it generates a new timestamp ts and sends the message request pj ts to all processes in the system including itself . on receiving a request message a process may reply immediately that is send a reply message back to p or it may defer sending a reply back because it is already in its critical section for example . a process . mutual exclusion that has received a reply message from all other processes in the system can enter its critical section queueing incoming requests and deferring them. after exiting its critical section the process sends reply messages to all its deferred requests. the decision whether process p replies immediately to a requcst pj ts message or defers its reply is based on three factors . if process p is in its critical section then it defers its reply to p . . if process p does not want to enter its critical section then it sends a reply immediately to pj. . if process p wants to enter its critical section but has not yet entered it then it compares its own request timestamp with the timestamp of the incoming request made by process pj. if its own request timestamp is greater than that of the incoming request then it sends a reply immediately to pj pj asked first . otherwise the reply is deferred. this algorithm exhibits the following desirable behavior mutual exclusion is obtained. freedom from deadlock is ensured. freedom from starvation is ensured since entry to the critical section is scheduled according to the timestamp ordering. the timestamp ordering ensures that processes are served in fcfs order. the number of messages per critical section entry is x n . this number is the minimum number of required messages per critical section entry when processes act independently and concurrently. to illustrate how the algorithm functions we consider a system consisting of processes pi pz and p . suppose that processes pi and p want to enter their critical sections. process pi then sends a message request pi timestamp to processes p? and p while process p sends a message request p timestamp to processes p and pi. the timestamps and were obtained from the logical clocks described in section . . when process p receives these request messages it replies immediately. when process pi receives the request from process p it replies immediately since the timestamp on its own request message is greater than the timestamp for process p . when process p receives the request message from process p it defers its reply since the timestamp on its request message is less than the timestamp for the message from process pi. on receiving replies from both process pi and process p? process p can enter its critical section. after exiting its critical section process p sends a reply to process pi which can then enter its critical section. because this scheme requires the participation of all the processes in the system however it has three undesirable consequences . the processes need to know the identity of all other processes in the system. when a new process joins the group of processes participating in the mutual exclusion algorithm the following actions need to be taken chapter distributed coordination a. the process must receive the names of all the other processes n the group. b. the name of the new process must be distributed to all the other processes in the group. this task is not as trivial as it may seem since some request and reply messages may be circulating in the system when the new process joins the group. the interested reader is referred to the bibliographical notes for more details. . if one process fails then the entire scheme collapses. we can resolve this difficulty by continuously monitoring the state of all processes in the system. if one process fails then all other processes are notified so that they will no longer send request messages to the failed process. when a process recovers it must initiate the procedure that allows it to rejoin the group. . processes that have not entered their critical section must pause frequently to assure other processes that they intend to enter the critical section. because of these difficulties this protocol is best suited for small stable sets of cooperating processes. . . token passing approach another method of providing mutual exclusion is to circulate a token among the processes in the system. a token is a special type of message that is passed around the system. possession of the token entitles the holder to enter the critical section. since there is only a single token only one process can be in its critical section at a time. we assume that the processes in the system are logically organized in a ring structure. the physical communication network need not be a ring. as long as the processes are connected to one another it is possible to implement a logical ring. to implement mutual exclusion we pass the token around the ring. when a process receives the token it may enter its critical section keeping the token. after the process exits its critical section the token is passed around again. if the process receiving the token does not want to enter its critical section it passes the token to its neighbor. this scheme is similar to algorithm in chapter but a token is substituted for a shared variable. if the ring is unidirectional freedom from starvation is ensured. the number of messages required to implement mutual exclusion may vary from one message per entry in the case of high contention that is every process wants to enter its critical section to an infinite number of messages in the case of low contention that is no process wants to enter its critical section . two types of failure must be considered. first if the token is lost an election must be called to generate a new token. second if a process fails a new logical ring must be established. in section . we present an election algorithm others are possible. the development of an algorithm for reconstructing the ring is left to you in exercise . 