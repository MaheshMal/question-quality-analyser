 before we can explore the details of how computer systems operate we need a general knowledge of the structure of a computer system. in this section we look at several parts of this structure to round out our background knowledge. the section is mostly concerned with computer system organization so you can skim or skip it if you already understand the concepts. . . computer system operation a modern general purpose computer system consists of one or more cpus and a number of device controllers connected through a common bus that provides access to shared memory figure . . each device controller is in charge of a specific type of device for example disk drives audio devices and video displays . the cpu and the device controllers can execute concurrently competing for memory cycles. to ensure orderly access to the shared memory a memory controller is provided whose function is to synchronize access to the memory. for a computer to start running for instance when it is powered up or rebooted it needs to have an initial program to run. this initial program or bootstrap program tends to be simple. typically it is stored in read only memory rom or electrically erasable programmable read only memory eeprom known by the general term firmware within the computer hardware. it initializes all aspects of the system from cpu registers to device . computer system organization mouse keyboard printer monitor disks cpu ! disk usb cqhtrolfer controller adapter memory figure . a modern computer system. controllers to memory contents. the bootstrap program must know how to load the operating system and to start executing that system. to accomplish this goal the bootstrap program must locate and load into memory the operatingsystem kernel. the operating system then starts executing the first process such as init and waits for some event to occur. the occurrence of an event is usually signaled by an interrupt from either the hardware or the software. hardware may trigger an interrupt at any time by sending a signal to the cpu usually by way of the system bus. software may trigger an interrupt by executing a special operation called a system call also called a monitor call . when the cpu is interrupted it stops what it is doing and immediately transfers execution to a fixed location. the fixed location usually contains the starting address where the service routine for the interrupt is located. the interrupt service routine executes on completion the cpu resumes the interrupted computation. a time line of this operation is shown in figure . . interrupts are an important part of a computer architecture. each computer design has its own interrupt mechanism but several functions are common. the interrupt must transfer control to the appropriate interrupt service routine. cpu user process u i o interrupt u processing o idle device transferring i o transfer i o transfer request done request done figure . interrupt time line for a single process doing output. chapter introduction the straightforward method for handling this transfer would be to invoke a generic routine to examine the interrupt information the routine in turn would call the interrupt specific handler. however interrupts must be handled quickly. since only a predefined number of interrupts is possible a table of pointers to interrupt routines can be used instead to provide the necessary speed. the interrupt routine is called indirectly through the table with no intermediate routine needed. generally the table of pointers is stored in low memory the first or so locations . these locations hold the addresses of the interrupt service routines for the various devices. this array or interrupt vector of addresses is then indexed by a unique device number given with the interrupt request to provide the address of the interrupt service routine for the interrupting device. operating systems as different as windows and unix dispatch interrupts in this manner. the interrupt architecture must also save the address of the interrupted instruction. many old designs simply stored the interrupt address in a fixed location or in a location indexed by the device number. more recent architectures store the return address on the system stack. if the interrupt routine needs to modify the processor state for instance by modifying register values it must explicitly save the current state and then restore that state before returning. after the interrupt is serviced the saved return address is loaded into the program counter and the interrupted computation resumes as though the interrupt had not occurred. . . storage structure computer programs must be in main memory also called random access memory or ram to be executed. main memory is the only large storage area millions to billions of bytes that the processor can access directly. it commonly is implemented in a semiconductor technology called dynamic random access memory dram which forms an array of memory words. each word has its own address. interaction is achieved through a sequence of load or store instructions to specific memory addresses. the load instruction moves a word from main memory to an internal register within the cpu whereas the s t o r e instruction moves the content of a register to main memory. aside from explicit loads and stores the cpu automatically loads instructions from main memory for execution. a typical instruction execution cycle as executed on a system with a von neumann architecture first fetches an instruction from memory and stores that instruction in the instruction register. the instruction is then decoded and may cause operands to be fetched from memory and stored in some internal register. after the instruction on the operands has been executed the result may be stored back in memory. notice that the memory unit sees only a stream of memory addresses it does not know how they are generated by the instruction counter indexing indirection literal addresses or some other means or what they are for instructions or data . accordingly we can ignore hoio a memory address is generated by a program. we are interested only in the sequence of memory addresses generated by the running program. ideally we want the programs and data to reside in main memory permanently. this arrangement usually is not possible for the following two reasons . computer system organization . main memory is usually too small to store all needed programs and data permanently. . main memory is a volatile storage device that loses its contents when power is turned off or otherwise lost. thus most computer systems provide secondary storage as an extension of main memory. the main requirement for secondary storage is that it be able to hold large quantities of data permanently. the most common secondary storage device is a magnetic disk which provides storage for both programs and data. most programs web browsers compilers word processors spreadsheets and so on are stored on a disk until they are loaded into memory. many programs then use the disk as both a source and a destination of the information for their processing. hence the proper management of disk storage is of central importance to a computer system as we discuss in chapter . in a larger sense however the storage structure that we have described consisting of registers main memory and magnetic disks is only one of many possible storage systems. others include cache memory cd rom magnetic tapes and so on. each storage system provides the basic functions of storing a datum and of holding that datum until it is retrieved at a later time. the main differences among the various storage systems lie in speed cost size and volatility. the wide variety of storage systems in a computer system can be organized in a hierarchy figure . according to speed and cost. the higher levels are expensive but they are fast. as we move down the hierarchy the cost per bit leqislorr cache t mam niomory electronic disk magnetic disk oplic.il dink magnetic tapes figure . storage device hierarchy. chapter introduction generally decreases whereas the access time generally increases. this trade off is reasonable if a given storage system were both faster and less expensive than another other properties being the same then there would be no reason to use the slower more expensive memory. in fact many early storage devices including paper tape and core memories are relegated to museums now that magnetic tape and semiconductor memory have become faster and cheaper. the top four levels of memory in figure . may be constructed using semiconductor memory. in addition to differing in speed and cost the various storage systems are either volatile or nonvolatile. as mentioned earlier volatile storage loses its contents when the power to the device is removed. in the absence of expensive battery and generator backup systems data must be written to nonvolatile storage for safekeeping. in the hierarchy shown in figure . the storage systems above the electronic disk are volatile whereas those below are nonvolatile. an electronic disk can be designed to be either volatile or nonvolatile. during normal operation the electronic disk stores data in a large dram array which is volatile. but many electronic disk devices contain a hidden magnetic hard disk and a battery for backup power. if external power is interrupted the electronic disk controller copies the data from ram to the magnetic disk. when external power is restored the controller copies the data back into the ram. another form of electronic disk is flash memory which is popular in cameras and personal digital assistants pdas in robots and increasingly as removable storage on general purpose computers. flash memory is slower than dram but needs no power to retain its contents. another form of nonvolatile storage is nvram which is dram with battery backup power. this memory can be as fast as dram but has a limited duration in which it is nonvolatile. the design of a complete memory system must balance all the factors just discussed it must use only as much expensive memory as necessary while providing as much inexpensive nonvolatile memory as possible. caches can be installed to improve performance where a large access time or transfer rate disparity exists between two components. . . i o structure storage is only one of many types of i o devices within a computer. a large portion of operating system code is dedicated to managing i o both because of its importance to the reliability and performance of a system and because of the varying nature of the devices. therefore we now provide an overview of i o. a general purpose computer system consists of cpus and multiple device controllers that are connected through a common bus. each device controller is in charge of a specific type of device. depending on the controller there may be more than one attached device. for instance seven or more devices can be attached to the small computer systems interface scsi controller. a device controller maintains some local buffer storage and a set of special purpose registers. the device controller is responsible for moving the data between the peripheral devices that it controls and its local buffer storage. typically operating systems have a device driver for each device controller. this device . computer system organization instruction execution cycle instructions thread of execution data movement and ca data cpu n dma memory figure . how a modern computer system works. driver understands the device controller and presents a uniform interface to the device to the rest of the operating system. to start an i o operation the device driver loads the appropriate registers within the device controller. the device controller in turn examines the contents of these registers to determine what action to take such as read a character from the keyboard the controller starts the transfer of data from the device to its local buffer. once the transfer of data is complete the device controller informs the device driver via an interrupt that it has finished its operation. the device driver then returns control to the operating system possibly returning the data or a pointer to the data if the operation was a read. for other operations the device driver returns status information. this form of interrupt driven i o is fine for moving small amounts of data but can produce high overhead when used for bulk data movement such as disk i o. to solve this problem direct memory access dma is used. after setting up buffers pointers and counters for the i o device the device controller transfers an entire block of data directly to or from its own buffer storage to memory with no intervention by the cpu. only one interrupt is generated per block to tell the device driver that the operation has completed rather than the one interrupt per byte generated for low speed devices. while the device controller is performing these operations the cpu is available to accomplish other work. some high end systems use switch rather than bus architecture. on these systems multiple components can talk to other components concurrently rather than competing for cycles on a shared bus. in this case dma is even more effective. figure . shows the interplay of all components of a computer system. chapter introduction