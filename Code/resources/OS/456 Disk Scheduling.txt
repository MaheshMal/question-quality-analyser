 one of the responsibilities of the operating system is to use the hardware efficiently. for the disk drives meeting this responsibility entails having . disk scheduling figure . storage area network. fast access time and large disk bandwidth. the access time has two major components also see section . . . the seek time is the time for the disk arm to move the heads to the cylinder containing the desired sector. the rotational latency is the additional time for the disk to rotate the desired sector to the disk head. the disk bandwidth is the total number of bytes transferred divided by the total time between the first request for service and the completion of the last transfer. we can improve both the access time and the bandwidth by scheduling the servicing of disk i o requests in a good order. whenever a process needs i o to or from the disk it issues a system call to the operating system. the request specifies several pieces of information whether this operation is input or output what the disk address for the transfer is what the memory address for the transfer is what the number of sectors to be transferred is if the desired disk drive and controller are available the request can be serviced immediately. if the drive or controller is busy any new requests for service will be placed in the queue of pending requests for that drive. for a multiprogramming system with many processes the disk queue may often have several pending requests. thus when one request is completed the operating system chooses which pending request to service next. how does the operating system make this choice? any one of several disk scheduling algorithms can be used and we discuss them next. . . fcfs scheduling the simplest form of disk scheduling is of course the first come first served fcfs algorithm. this algorithm is intrinsically fair but it generally does not provide the fastest service. consider for example a disk queue with requests for i o to blocks on cylinders chapter mass storage structure queue head starts at ' . . . . . . i.i. .i i! i. . j figure . fcfs disk scheduling. in that order. if the disk head is initially at cylinder it will first move from to then to and finally to for a total head movement of cylinders. this schedule is diagrammed in figure . . the wild swing from to and then back to illustrates the problem with this schedule. if the requests for cylinders and could be serviced together before or after the requests at and the total head movement could be decreased substantially and performance could be thereby improved. . . sstf scheduling it seems reasonable to service all the requests close to the current head position before moving the head far away to service other requests. this assumption is the basis for the shortest seek time first sstf algorithm. the sstf algorithm selects the request with the minimum seek time from the current head position. since seek time increases with the number of cylinders traversed by the head sstf chooses the pending request closest to the current head position. for our example request queue the closest request to the initial head position is at cylinder . once we are at cylinder the next closest request is at cylinder . from there the request at cylinder is closer than the one at so is served next. continuing we service the request at cylinder then and finally figure . . this scheduling method results in a total head movement of only cylinders little more than one third of the distance needed for fcfs scheduling of this request queue. this algorithm gives a substantial improvement in performance. sstf scheduling is essentially a form of shortest job first sjf scheduling and like sjf scheduling it may cause starvation of some requests. remember that requests may arrive at any time. suppose that we have two requests in the queue for cylinders and and while servicing the request from a new request near arrives. this new request will be serviced next making the request at wait. while this request is being serviced another request close to could arrive. in theory a continual stream of requests near one another could arrive causing the request for cylinder to wait indefinitely. . disk scheduling queue . head starts at l figure . sstf disk scheduling. this scenario becomes increasingly likely if the pending request queue grows long. although the sstf algorithm is a substantial improvement over the fcfs algorithm it is not optimal. in the example we can do better by moving the head from to even though the latter is not closest and then to before turning around to service and . this strategy reduces the total head movement to cylinders. . . scan scheduling in the scan algorithm the disk arm starts at one end of the disk and moves toward the other end servicing requests as it reaches each cylinder until it gets to the other end of the disk. at the other end the direction of head movement is reversed and servicing continues. the head continuously scans back and forth across the disk. the scan algorithm is sometimes called the elevator algorithm since the disk arm behaves just like an elevator in a building first servicing all the requests going up and then reversing to service requests the other way. let's return to our example to illustrate. before applying scan to schedule the requests on cylinders and we need to know the direction of head movement in addition to the head's current position . if the disk arm is moving toward the head will service and then . at cylinder the arm will reverse and will move toward the other end of the disk servicing the requests at and figure . . if a request arrives in the queue just in front of the head it will be serviced almost immediately a request arriving just behind the head will have to wait until the arm moves to the end of the disk reverses direction and comes back. assuming a uniform distribution of requests for cylinders consider the density of requests when the head reaches one end and reverses direction. at this point relatively few requests are immediately in front of the head since these cylinders have recently been serviced. the heaviest density of requests is at the other end of the disk. these requests have also waited the longest so why not go there first? that is the idea of the next algorithm. chapter mass storage structure queue . head starts at figure . scan disk scheduling. . . c scan scheduling circular scan c scan scheduling is a variant of scan designed to provide a more uniform wait time. like scan c scan moves the head from one end of the disk to the other servicing requests along the way. when the head reaches the other end however it immediately returns to the beginning of the disk without servicing any requests on the return trip figure . . the c scan scheduling algorithm essentially treats the cylinders as a circular list that wraps around from the final cylinder to the first one. . . look scheduling as we described them both scan and c scak move the disk arm across the full width of the disk. in practice neither algorithm is often implemented this way. more commonly the arm goes only as far as the final request in each queue head starts at i j ljj j lj i i h figure . c scan disk scheduling. . disk scheduling queue head starts at figure . c look disk scheduling. direction. then it reverses direction immediately without going all the way to the end of the disk. versions of scan and c scan that follow this pattern are called look and c look scheduling because they look for a request before continuing to move in a given direction figure . . . . selection of a disk scheduling algorithm given so many disk scheduling algorithms how do we choose the best one? sstf is common and has a natural appeal because it increases performance over fcfs. scam and c scan perform better for systems that place a heavy load on the disk because they are less likely to cause a starvation problem.. for any particular list of requests we can define an optimal order of retrieval but the computation needed to find an optimal schedule may not justify the savings over sstf or scan. with any scheduling algorithm however performance depends heavily on the number and types of requests. for instance suppose that the queue usually has just one outstanding request. then all scheduling algorithms behave the same because they have only one choice for where to move the disk head they all behave like fcfs scheduling. requests for disk service can be greatly influenced by the file allocation method. a program reading a contiguously allocated file will generate several requests that are close together on the disk resulting in limited head movement. a linked or indexed file in contrast may include blocks that are widely scattered on the disk resulting in greater head movement. the location of directories and index blocks is also important. since every file must be opened to be used and opening a file requires searching the directory structure the directories will be accessed frequently. suppose that a directory entry is on the first cylinder and a file's data are on the final cylinder. in this case the disk head has to move the entire width of the disk. if the directory entry were on the middle cylinder the head would have to move at most one half the width. caching the directories and index blocks in main memory can also help to reduce the disk arm movement particularly for read requests. chapter mass storage structure because of these complexities the disk scheduling algorithm should be written as a separate module of the operating system so that it can be replaced with a different algorithm if necessary. either sstf or look is a reasonable choice for the default algorithm. the scheduling algorithms described here consider only the seek distances. for modern disks the rotational latency can be nearly as large as the average seek time. it is difficult for the operating system to schedule for improved rotational latency though because modern disks do not disclose the physical location of logical blocks. disk manufacturers have been alleviating this problem by implementing disk scheduling algorithms in the controller hardware built into the disk drive. if the operating system sends a batch of requests to the controller the controller can queue them and then schedule them to improve both the seek time and the rotational latency. if i o performance were the only consideration the operating system would gladly turn over the responsibility of disk scheduling to the disk hardware. in practice however the operating system may have other constraints on the service order for requests. for instance demand paging may take priority over application i o and writes are more urgent than reads if the cache is running out of free pages. also it may be desirable to guarantee the order of a set of disk writes to make the file system robust in the face of system crashes. consider what could happen if the operating system allocated a disk page to a file and the application wrote data into that page before the operating system had a chance to flush the modified inode and free space list back to disk. to accommodate such requirements an operating system may choose to do its own disk scheduling and to spoon feed the requests to the disk controller one by one for some types of f o