 note too that only pages that can be modified need be marked as copy onwrite. pages that cannot be modified pages containing executable code can be shared by the parent and child. copy on write is a common technique used by several operating systems including windows xp linux and solaris. when it is determined that a page is going to be duplicated using copyon write it is important to note the location from which the free page will be allocated. many operating systems provide a pool of free pages for such requests. these free pages are typically allocated when the stack or heap for a process must expand or when there are copy on write pages to be managed. operating systems typically allocate these pages using a technique known as zero fill on demand. zero fill on demand pages have been zeroed out before being allocated thus erasing the previous contents. several versions of unix including solaris and linux also provide a variation of the forkc system call vforko for virtual memory fork . vf ork operates differently from f ork with copy on write. with vf ork the parent process is suspended and the child process uses the address space of the parent. because vf ork does not use copy on write if the child process changes any pages of the parent's address space the altered pages will be visible to the parent once it resumes. therefore vf ork must be used with caution to ensure that the child process does not modify the address space of the parent vf ork is intended to be used when the child process calls execo immediately after creation. because no copying of pages takes place vf ork is an extremely efficient method of process creation and is sometimes used to implement unix command line shell interfaces. . page replacement in our earlier discussion of the page fault rate we assumed that each page faults at most once when it is first referenced. this representation is not strictlyaccurate however. if a process of ten pages actually uses only half of them then demand paging saves the i o necessary to load the five pages that are never used. we could also increase our degree of multiprogramming by running twice as many processes. thus if we had forty frames we could run eight processes rather than the four that could run if each required ten frames five of which were never used . if we increase our degree of multiprogramming we are over ajlocating memory. if we run six processes each of which is ten pages in size but actually uses only five pages we have higher cpu utilization and throughput with ten frames to spare. it is possible however that each of these processes for a particular data set may suddenly try to use all ten of its pages resulting in a need for sixty frames when only forty are available. further consider that system memory is not used only for holding program pages. buffers for i o also consume a significant amount of memory. this use can increase the strain on memory placement algorithms. deciding how much memory to allocate to i o and how much to program pages is a significant challenge. some systems allocate a fixed percentage of memory for i o buffers whereas others allow both user processes and the i o subsystem to compete for all system memory. chapter virtual memory valid invalid frame d h logical memory featrivr for user for user j a valid invalid e m frame bit physical memory i v v logical memory page table for user for user figure . need for page replacement. over allocation of memory manifests itself as follows. while a user process is executing a page fault occurs. the operating system determines where the desired page is residing on the disk but then finds that there are no free frames on the free frame list all memory is in use figure . . the operating system has several options at this point. it could terminate the user process. however demand paging is the operating system's attempt to improve the computer system's utilization and throughput. users should not be aware that their processes are running on a paged system paging should be logically transparent to the user. so this option is not the best choice. the operating system could instead swap out a process freeing all its frames and reducing the level of multiprogramming. this option is a good one in certain circumstances and we consider it further in section . . here we discuss the most common solution page replacement. . . basic page replacement page replacement takes the following approach. if no frame is free we find one that is not currently being used and free it. we can free a frame by writing its contents to swap space and changing the page table and all other tables to indicate that the page is no longer in memory figure . . we can now use the freed frame to hold the page for which the process faulted. we modify the page fault service routine to include page replacement . find the location of the desired page on the disk. . find a free frame a. if there is a free frame use it. . page replacement b. if there is no free frame use a page replacement algorithm toselect a victim frame. c. write the victim frame to the disk change the page and frame tables accordingly. . read the desired page into the newly freed frame change the page and frame tables. . restart the user process. notice that if no frames are free two page transfers one out and one in are required. this situation effectively doubles the page fault service time and increases the effective access time accordingly. we can reduce this overhead by using a modify bit or dirty bit . when this scheme is used each page or frame has a modify bit associated with it in the hardware. the modify bit for a page is set by the hardware whenever any word or byte in the page is written into indicating that the page has been modified. when we select a page for replacement we examine its modify bit. if the bit is set we know that the page has been modified since it was read in from the disk. in this case we must write that page to the disk. if the modify bit is not set however the page has not been modified since it was read into memory. therefore if the copy of the page on the disk has not been overwritten by some other page for example then we need not write the memory page to the disk it is already there. this technique also applies to read only pages for example pages of binary code . such pages cannot be modified thus they may be discarded when desired. this scheme can significantly reduce the time required to service a page fault since it reduces i o time by one halfif the page has not been modified. frame valid invalid bit swap out tnj change victim i vfyto invalid page f v . fi victim reset page page table table for new page physical memory figure . page replacement. chapter virtual memory page replacement is basic to demand paging. it completes the separation between logical memory and physical memory with this mechanism an enormous virtual memory can be provided for programmers on a smaller physical memory. with no demand paging user addresses are mapped into physical addresses so the two sets of addresses can be different. all the pages of a process still must be in physical memory however. with demand paging the size of the logical address space is no longer constrained by physical memory. if we have a user process of twenty pages we can execute it in ten frames simply by using demand paging and using a replacement algorithm to find a free frame whenever necessary. if a page that has been modified is to be replaced its contents are copied to the disk. a later reference to that page will cause a page fault. at that time the page will be brought back into memory perhaps replacing some other page in the process. we must solve two major problems to implement demand paging we must develop a frame allocation algorithm and a page replacement algorithm. if we have multiple processes in memory we must decide how many frames to allocate to each process. further when page replacement is required we must select the frames that are to be replaced. designing appropriate algorithms to solve these problems is an important task because disk i o is so expensive. even slight improvements in demand paging methods yield large gains in system performance. there are many different page replacement algorithms. every operating system probably has its own replacement scheme. how do we select a particular replacement algorithm? in general we want the one with the lowest page fault rate. wte evaluate an algorithm by running it on a particular string of memory references and computing the number of page faults. the string of memory references is called a reference string. we can generate reference strings artificially by using a random number generator for example or we can trace a given system and record the address of each memory reference. the latter choice produces a large number of data on the order of million addresses per second . to reduce the number of data we use two facts. first for a given page size and the page size is generally fixed by the hardware or system we need to consider only the page number rather than the entire address. second if we have a reference to a page p then any immediately following references to page p will never cause a page fault. page p will be in memory after the first reference so the immediately following references will not fault. for example if we trace a particular process we might record the following address sequence at bytes per page this sequence is reduced to the following reference string . page replacement b h m ! a cg o cd number of frames figure . graph of page faults versus number of frames. to determine the number of page faults for a particular reference string and page replacement algorithm we also need to know the number of page frames available. obviously as the number of frames available increases the number of page faults decreases. for the reference string considered previously for example if we had three or more frames we would have only three faults one fault for the first reference to each page. in contrast with only one frame available we would have a replacement with every reference resulting in eleven faults. in general we expect a curve such as that in figure . . as the number of frames increases the number of page faults drops to some minimal level. of course adding physical memory increases the number of frames. we next illustrate several page replacement algorithms. in doing so we use the reference string for a memory with three frames. . . fifo page replacement the simplest page replacement algorithm is a first in first out fifo algorithm. a fifo replacement algorithm associates with each page the time when that page was brought into memory. when a page must be replaced the oldest page is chosen. notice that it is not strictly necessary to record the time when a page is brought in. we can. create a fifo queue to hold all pages in memory. we replace the page at the head of the queue. when a page is brought into memory we insert it at the tail of the queue. for our example reference string our three frames are initially empty. the first three references cause page faults and are brought into these empty frames. the next reference replaces page because page was brought in first. since is the next reference and is already in memory we have no fault for this reference. the first reference to results in replacement of page since chapter virtual memory' reference string j p ' if p i io ' i i ll til e j i page frames figure . fifo page replacement algorithm. it is now first in line. because of this replacement the next reference to will fault. page is then replaced by page . this process continues as shown in figure . . every time a fault occurs we show which pages are in our three frames. there are faults altogether. the fifo page replacement algorithm is easy to understand and program. however its performance is not always good. on the one hand the page replaced may be an initialization module that was used a long time ago and is no longer needed. on the other hand it could contain a heavily used variable that was initialized early and is in constant use. notice that even if we select for replacement a page that is in active use everything still works correctly. after we replace an active page with a new one a fault occurs almost immediately to retrieve the active page. some other page will need to be replaced to bring the active page back into memory. thus a bad replacement choice increases the page fault rate and slows process execution. it does not however cause incorrect execution. to illustrate the problems that are possible with a fifo page replacement algorithm. wte consider the following reference string figure . shows the curve of page faults for this reference string versus the number of available frames. notice that the number of faults for four frames ten is greater than the number of faults for three frames nine ! this most unexpected result is known as belady's anomaly for some page replacement algorithms the page fault rate may increase as the number of allocated frames increases. we would expect that giving more memory to a process would improve its performance. in some early research investigators noticed that this assumption was not always true. belady's anomaly was discovered as a result. . . optimal page replacement one result of the discovery of belady's anomaly was the search for an optimal page replacement algorithm. an optimal page replacement algorithm has the lowest page fault rate of all algorithms and will never suffer from belady's anomaly. such an algorithm does exist and has been called opt or mik. it is simply this . page replacement m j! co cd e number of frames figure . page fault curve for fifo replacement on a reference string. replace the page that will not be used for the longest period of time. use of this page replacement algorithm guarantees the lowest possible pagefault rate for a fixed number of frames. for example on our sample reference string the optimal page replacement algorithm would yield nine page faults as shown in figure . . the first three references cause faults that fill the three empty frames. the reference to page replaces page because will not be used until reference whereas page will be used at and page at . the reference to page replaces page as page will be the last of the three pages in memory to be referenced again. with only nine page faults optimal replacement is much better than a fifo algorithm which resulted in fifteen faults. if we ignore the first three which all algorithms must suffer then optimal replacement is twice as good as fifo replacement. in fact no replacement algorithm can process this reference string in three frames with fewer than nine faults. unfortunately the optimal page replacement algorithm is difficult to implement because it requires future knowledge of the reference string. we encountered a similar situation with the sjf cpu scheduling algorithm in reference string o page frames figure . optimal page replacement algorithm. chapter virtual memory section . . . as a result the optimal algorithm is used mainly for comparison studies. for instance it may be useful to know that although a new algorithm is not optimal it is within . percent of optimal at worst and within . percent on average. . . lru page replacement if the optimal algorithm is not feasible perhaps an approximation of the optima algorithm is possible. the key distinction between the fifo and opt algorithms other than looking backward versus forward in time is that the fifo algorithm uses the time when a page was brought into memory whereas the opt algorithm uses the time when a page is to be used. if we use the recent past as an approximation of the near future then we can replace the page that has not been used for the longest period of time figure . . this approach is the least recently used lru algorithm. lru replacement associates with each page the time of that page's last use. when a page must be replaced lru chooses the page that has not been used for the longest period of time. we can think of this strategy as the optimal page replacement algorithm looking backward in time rather than forward. strangely if we let s be the reverse of a reference string s then the page fault rate for the opt algorithm on is the same as the page fault rate for the opt algorithm on r. similarly the page fault rate for the lru algorithm on s is the same as the page fault rate for the lru algorithm on sr. the result of applying lru replacement to our example reference string is shown in figure . . the lru algorithm produces faults. notice that the first faults are the same as those for optimal replacement. when the reference to page occurs however lru replacement sees that of the three frames in memory page was used least recently. thus the lru algorithm replaces page not knowing that page is about to be used. when it then faults for page the lru algorithm replaces page since it is now the least recently used of the three pages in memory. despite these problems lru replacement with faults is much better than fifo replacement with . the lru policy is often used as a page replacement algorithm and is considered to be good. the major problem is how to implement lru replacement. an lru page replacement algorithm may require substantial hardware assistance. the problem is to determine an order for the frames defined by the time of last use. two implementations are feasible reference string a i a i i ' t page frames figure . lru page replacement algorithm. . page replacement counters. in the simplest case we associate with each page table entry a time of use field and add to the cpu a logical clock or counter. the clock is incremented for every memory reference. whenever a reference to a page is made the contents of the clock register are copied to the time of use field in the page table entry for that page. in this way we always have the time of the last reference to each page. we replace the page with the smallest time value. this scheme requires a search of the page table to find the lru page and a write to memory to the time of use field in the page table for each memory access. the times must also be maintained when page tables are changed due to cpu scheduling . overflow of the clock must be considered. stack. another approach to implementing lru replacement is to keep a stack of page numbers. whenever a page is referenced it is removed from the stack and put on the top. in this way the most recently used page is always at the top of the stack and the least recently used page is always at the bottom figure . . because entries must be removed from the middle of the stack it is best to implement this approach by using a doubly linked list with a head and tail pointer. removing a page and putting it on the top of the stack then requires changing six pointers at worst. each update is a little more expensive but there is no search for a replacement the tail pointer points to the bottom of the stack which is the lru page. this approach is particularly appropriate for software or microcode implementations of lru replacement. like optimal replacement lrl replacement does not suffer from belady's anomaly. both belong to a class of page replacement algorithms called stack algorithms that can never exhibit belady's anomaly. a stack algorithm is an algorithm for which it can be shown that the set of pages in memory for n frames is always a subset of the set of pages that would be in memory with n frames. for lrl replacement the set of pages in memory would be the n most recently referenced pages. if the number of frames is increased these n pages will still be the most recently referenced and so will still be in memory. reference string t t a b d l ' j stack stack before after a b figure . use of a stack to record the most recent page references. chapter virtual memory note that neither implementation of lru would be conceivable without hardware assistance beyond the standard tlb registers. the updating of the clock fields or stack must be done for every memory reference. if we were to use an interrupt for every reference to allow software to update such data structures it would slow every memory reference by a factor of at least ten hence slowing every user process by a factor of ten. few systems could tolerate that level of overhead for memory management. . . lru approximation page replacement few computer systems provide sufficient hardware support for true lru page replacement. some systems provide no hardware support and other pagereplacement algorithms such as a fifo algorithm must be used. many systems provide some help however in the form of a reference bit. the reference bit for a page is set by the hardware whenever that page is referenced either a read or a write to any byte in the page . reference bits are associated with each entry in the page table. initially all bits are cleared to by the operating system. as a user process executes the bit associated with each page referenced is set to by the hardware. after some time we can determine which pages have been used and which have not been used by examining the reference bits although we do not know the order of use. this information is the basis for many page replacement algorithms that approximate lru replacement. . . . additional reference bits algorithm we can gain additional ordering information by recording the reference bits at regular intervals. we can keep an bit byte for each page in a table in memory. at regular intervals say every milliseconds a timer interrupt transfers control to the operating system. the operating system shifts the reference bit for each page into the high order bit of its bit byte shifting the other bits right by bit and discarding the low order bit. these bit shift registers contain the history of page use for the last eight time periods. if the shift register contains for example then the page has not been used for eight time periods a page that is used at least once in each period has a shift register value of . a page with a history register value of has been used more recently than one with a value of . if we interpret these bit bytes as unsigned integers the page with the lowest number is the lru page and it can be replaced. notice that the numbers are not guaranteed to be unique however. we can either replace swap out all pages with the smallest value or use the fifo method to choose among them. the number of bits of history can be varied of course and is selected depending on the hardware available to make the updating as fast as possible. in the extreme case the number can be reduced to zero leaving only the reference bit itself. this algorithm is called the second chance pagereplacement algorithm. . . . second chance algorithm the basic algorithm of second chance replacement is a fifo replacement algorithm. when a page has been selected however we inspect its reference . page replacement reference pages reference pages bits bits i v next victim circular queue of pages circular queue of pages a b figure . second chance clock page replacement algorithm. bit. if the value is we proceed to replace this page but if the reference bit is set to we give the page a second chance and move on to select the next fifo page. when a page gets a second chance its reference bit is cleared and its arrival time is reset to the current time. thus a page that is given a second chance will not be replaced until all other pages have been replaced or given second chances . in addition if a page is used often enough to keep its reference bit set it will never be replaced. one way to implement the second chance algorithm sometimes referred to as the dock algorithm is as a circular queue. a pointer that is a hand on the clock indicates which page is to be replaced next. when a frame is needed the pointer advances until it finds a page with a reference bit. as it advances it clears the reference bits figure . . once a victim page is found the page is replaced and the new page is inserted in the circular queue in that position. notice that in the worst case when all bits are set the pointer cycles through the whole queue giving each page a second chance. tt clears all the reference bits before selecting the next page for replacement. second chance replacement degenerates to fifo replacement if all bits are set. . . . enhanced second chance algorithm we can enhance the second chance algorithm by considering the reference bit and the modify bit described in section . . as an ordered pair. with these two bits we have the following four possible classes chapter virtual memory . neither recently used nor modified best page to replace . not recently used but modified not quite as good because the page will need to be written out before replacement . . recently used but clean probably will be used again soon . recently used and modified probably will be used again soon and the page will be need to be written out to disk before it can be replaced each page is in one of these four classes. when page replacement is called for we use the same scheme as in the clock algorithm but instead of examining whether the page to which we are pointing has the reference bit set to we examine the class to which that page belongs. we replace the first page encountered in the lowest nonempty class. notice that we may have to scan the circular queue several times before we find a page to be replaced. the major difference between this algorithm and the simpler clock algorithm is that here we give preference to those pages that have been modified to reduce the number of os required. . . counting based page replacement there are many other algorithms that can be used for page replacement. for example we can keep a counter of the number of references that have been made to each page and develop the following two schemes. the least frequently used lfu page replacement algorithm requires that the page with the smallest count be replaced. the reason for this selection is that an actively used page should have a large reference count. a problem arises however when a page is used heavily during the initial phase of a process but then is never used again. since it was used heavily it has a large count and remains in memory even though it is no longer needed. one solution is to shift the counts right by bit at regular intervals forming an exponentially decaying average usage count. the most frequently used mfu page replacement algorithm is based on the argument that the page with the smallest count was probably just brought in and has yet to be used. as you might expect neither mfu nor lfu replacement is common. the implementation of these algorithms is expensive and they do not approximate opt replacement well. . . page buffering algorithms other procedures are often used in addition to a specific page replacement algorithm . for example systems commonly keep a pool of free frames. when a page fault occurs a victim frame is chosen as before. however the desired page is read into a free frame from the pool before the victim is written out. this procedure allows the process to restart as soon as possible without waiting . page replacement for the victim page to be written out. when the victim is later written put its frame is added to the free frame pool. an expansion of this idea is to maintain a list of modified pages. whenever the paging device is idle a modified page is selected and is written to the disk. its modify bit is then reset. this scheme increases the probability that a page will be clean when it is selected for replacement and will not need to be written out. another modification is to keep a pool of free frames but to remember which page was in each frame. since the frame contents are not modified when a frame is written to the disk the old page can be reused directly from the free frame pool if it is needed before that frame is reused. no i o is needed in this case. when a page fault occurs we first check whether the desired page is in the free frame pool if it is not we must select a free frame and read into it. this technique is used in the vax vms system along with a fifo replacement algorithm. when the fifo replacement algorithm mistakenly replaces a page that is still in active use that page is quickly retrieved from the free frame pool and no i o is necessary. the free frame buffer provides protection against the relatively poor but simple fifo replacement algorithm. this method is necessary because the early versions of vax did not implement the reference bit correctly. some versions of the unix system use this method in conjunction with the second chance algorithm. it can be a useful augmentation to any pagereplacement algorithm to reduce the penalty incurred if the wrong victim page is selected. . . applications and page replacement in certain cases applications accessing data through the operating system's virtual memory perform worse than if the operating system provided no buffering at all. a typical example is a database which provides its own memory management and i o buffering. applications like this understand their memory use and disk use better than does an operating system that is implementing algorithms for general purpose use. if the operating system is buffering i o and the application is doing so as well then twice the memory is being used for a set of i o. in another example data warehouses frequently perform massive sequential disk reads followed by computations and writes. the lru algorithm would be removing old pages and preserving new ones while the application would more likely be reading older pages than newer ones as it starts its sequential reads again . here mfu would actually be more efficient than lru. because of such problems some operating systems give special programs the ability to use a disk partition as a large sequential array of logical blocks without any file system data structures. this array is sometimes called the raw disk and i o to this array is termed raw i o. raw i o bypasses all the filesystem services such as file i o demand paging file locking prefetchmg space allocation file names and directories. note that although certain applications are more efficient when implementing their own special purpose storage services on a raw partition most applications perform better when they use the regular file system services. chapter virtual memory