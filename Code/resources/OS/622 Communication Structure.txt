 now that we have discussed the physical aspects of networking we turn to the internal workings. the designer of a communication network must address five basic issues naming and name resolution. how do two processes locate each other to communicate? routing strategies. how are messages sent through the network? packet strategies. are packets sent individually or as a sequence? connection strategies. how do two processes send a sequence of messages? contention. how do we resolve conflicting demands for the network's use given that it is a shared resource? in the following sections we elaborate on each of these issues. . . naming and name resolution the first component of network communication is the naming of the systems in the network. for a process at site a to exchange information with a process at site b each must be able to specify the other. within a computer system each process has a process identifier and messages may be addressed with the process identifier. because networked systems share no memory a host within the system initially has no knowledge about the processes on other hosts. . communication structure to solve this problem processes on remote systems are generally identified by the pair host name identifiers where iwst name is a name unique within the network and identifier may be a process identifier or other unique number within that host. a host name is usually an alphanumeric identifier rather than a number to make it easier for users to specify. for instance site a might have hosts named homer marge bart and lisa. bart is certainly easier to remember than is . names are convenient for humans to use but computers prefer numbers for speed and simplicity. for this reason there must be a mechanism to resolve the host name into a host id that describes the destination system to the networking hardware. this resolve mechanism is similar to the nameto address binding that occurs during program compilation linking loading and execution chapter . in the case of host names two possibilities exist. first every host may have a data file containing the names and addresses of all the other hosts reachable on the network similar to binding at compile time . the problem with this model is that adding or removing a host from the network requires updating the data files on all the hosts. the alternative is to distribute the information among systems on the network. the network must then use a protocol to distribute and retrieve the information. this scheme is like execution time binding. the first method was the original method vised on the internet as the internet grew however it became untenable so the second method the domain name system dns is now in use. dns specifies the naming structure of the hosts as well as name to address resolution. hosts on the internet are logically addressed with a multipart name. names progress from the most specific to the most general part of the address with periods separating the fields. for instance bob.cs.brown.edu refers to host bob in the department of computer science at brown university within the domain edit. other top level domains include com for commercial sites and org for organizations as well as a domain for each country connected to the network for systems specified by country rather than organization type. generally the system resolves addresses by examining the host name components in reverse order. each component has a name server simply a process on a system that accepts a name and returns the address of the name server responsible for that name. as the final step the name server for the host in question is contacted and a host id is returned. for our example system bob.cs.brown.edu the following steps would be taken as result of a request made by a process on system a to communicate with bob.cs.broion.edu . the kernel of system a issues a request to the name server for the edu domain asking for the address of the name server for broum.edu. the name server for the edu domain must be at a known address so that it can be queried. . the edit name server returns the address of the host on which the brown.edu name server resides. . the kernel on system a then queries the name server at this address and asks abovit cs.brown.edu . an address is returned and a request to that address for bob.cs.brozon.edu now finally returns an internet address host id for that host for example . . l . chapter distributed system structures this protocol may seem inefficient but local caches are usually kept at? each name server to speed the process. for example the edu name server would have brown.edu in its cache and would inform system a that it could resolve two portions of the name returning a pointer to the cs.broum.edu name server. of course the contents of these caches must be refreshed over time in case the name server is moved or its address changes. in fact this service is so important that many optimizations have occurred in the protocol as well as many safeguards. consider what would happen if the primary edu name server crashed. it is possible that no edu hosts would be able to have their addresses resolved making them all unreachable! the solution is to use secondary back up name servers that duplicate the contents of the primary servers. before the domain name service was introduced all hosts on the internet needed to have copies of a file that contained the names and addresses of each host on the network. all changes to this file had to be registered at one site host sri nic and periodically all hosts had to copy the updated file from sri nic to be able to contact new systems or find hosts whose addresses had changed. under the domain name service each name server site is responsible for updating the host information for that domain. for instance any host changes at brown university are the responsibility of the name server for brown.edu and do not have to be reported anywhere else. dns lookups will automatically retrieve the updated information because brotvn.edu is contacted directly. within domains there can be autonomous subdomains to distribute further the responsibility for host name and host id changes. java provides the necessary api to design a program that maps ip names to ip addresses. the program shown in figure . is passed an ip name such as bob.cs.brown.edu on the command line and either outputs the ip address of the host or returns a message indicating that the host name could not be resolved. an inetaddress is a java class representing an ip name or address. the static method getbynameo belonging to the inetaddress class usage java dnslookup ip name i.e. java dnslookup www.wiley.com public class dnslookup public static void main string args inetaddress hostaddress try hostaddress inetaddress.getbyname args system.out.printin hostaddress.gethostaddress catch unknownhostexception uhe system.err.println unknown host args figure . java program illustrating a dns lookup. . communication structure is passed a string representation of an ip name and it returns the corresponding inetaddress. the program then invokes the gethostaddressq method which internally uses divs to look up the ip address of the designated host. generally the operating system is responsible for accepting from its processes a message destined for host name identifier and for transferring that message to the appropriate host. the kernel on the destination host is then responsible for transferring the message to the process named by the identifier. this exchange is by no means trivial it is described in section . . . . . routing strategies when a process at site a wants to communicate with a process at site b how is the message sent? if there is only one physical path from a to b such as in a star or tree structured network the message must be sent through that path. however if there are multiple physical paths from a to b then several routing options exist. each site has a routing table indicating the alternative paths that can be used to send a message to other sites. the table may include information about the speed and cost of the various communication paths and it may be updated as necessary either manually or via programs that exchange routing information. the three most common routing schemes are fixed routing virtual routing and dynamic routing. fixed routing. a path from a to b is specified in advance and does not change unless a hardware failure disables it. usually the shortest path is chosen so that communication costs are minimized. virtual routing. a path from a to b is fixed for the duration of one session. different sessions involving messages from a to b may use different paths. a session could be as short as a file transfer or as long as a remote login period. dynamic routing. the path used to send a message from site a to site b is chosen only when a message is sent. because the decision is made dynamically separate messages may be assigned different paths. site a will make a decision to send the message to site c c in turn will decide to send it to site d and so on. eventually a site will deliver the message to b. usually a site sends a message to another site on whatever link is the least used at that particular time. there are tradeoffs among these three schemes. fixed routing cannot adapt to link failures or load changes. in other words if a path has been established between a and b the messages must be sent along this path even if the path is down or is used more heavily than another possible path. we can partially remedy this problem by using virtual routing and can avoid it completely by using dynamic routing. fixed routing and virtual routing ensure that messages from a to b will be delivered in the order in which they were sent. in dynamic routing messages may arrive out of order. we can remedy this problem by appending a sequence number to each message. dynamic routing is the most complicated to set up and run however it is the best way to manage routing in complicated environments. unix provides both fixed routing for use on hosts within simple networks and dynamic chapter distributed system structures routing for complicated network environments. it is also possible to mix the two. within a site the hosts may just need to know how to reach the system that connects the local network to other networks such as company wide networks or the internet . such a node is known as a gateway. each individual host has a static route to the gateway although the gateway itself uses dynamic routing to reach any host on the rest of the network. a router is the entity within the computer network responsible for routing messages. a router can be a host computer with routing software or a special purpose device. either way a router must have at least two network connections or else it would have nowhere to route messages. a router decides whether any given message needs to be passed from the network on which it is received to any other network connected to the router. it makes this determination by examining the destination internet address of the message. the router checks its tables to determine the location of the destination host or at least of the network to which it will send the message toward the destination host. in the case of static routing this table is changed only by manual update a new file is loaded onto the router . with dynamic routing a routing protocol is used between routers to inform them of network changes and to allow them to update their routing tables automatically gateways and routers typically are dedicated hardware devices that run code out of firmware. . . packet strategies messages are generally of variable length. to simplify the system design we commonly implement communication with fixed length messages called packets frames or datagrams. a communication implemented in one packet can be sent to its destination in a connectionless message. a connectionless message can be unreliable in which case the sender has no guarantee that and cannot tell whether the packet reached its destination. alternatively the packet can be reliable usually in this case a packet is returned from the destination indicating that the packet arrived. of course the return packet could be lost along the way. if a message is too long to fit within one packet or if the packets need to flow back and forth between the two communicators a connection is established to allow the reliable exchange of multiple packets. . . connection strategies once messages are able to reach their destinations processes can institute communications sessions to exchange information. pairs of processes that want to communicate over the network can be connected in a number of ways. the three most common schemes are circuit switching message switching and packet switching. circuit switching. if two processes want to communicate a permanent physical link is established between them. this link is allocated for the duration of the communication session and no other process can use that link during this period even if the two processes are not actively communicating for a while . this scheme is similar to that used in the telephone system. once a communication line has been opened between two parties that is party a calls party b no one else can use this circuit . communication structure until the communication is terminated explicitly for example when the parties hang up . message switching. if two processes want to communicate a temporary link is established for the duration of one message transfer. physical links are allocated dynamically among correspondents as needed and are allocated for only short periods. each message is a block of data with system information such as the source the destination and errorcorrection codes ecc that allows the communication network to deliver the message to the destination correctly. this scheme is similar to the post office mailing system. each letter is a message that contains both the destination address and source return address. many messages from different users can be shipped over the same link. packet switching. one logical message may have to be divided into a number of packets. each packet may be sent to its destination separately and each therefore must include a source and destination address with its data. furthermore the various packets may take different paths through the network. the packets must be reassembled into messages as they arrive. note that it is not harmful for data to be broken into packets possibly routed separately and reassembled at the destination. breaking up an audio signal say a telephone communication in contrast could cause great confusion if it was not done carefully. there are obvious tradeoffs among these schemes. circuit switching requires substantial set up time and may waste network bandwidth but it incurs less overhead for shipping each message. conversely message and packet switching require less set up time but incur more overhead per message. also in packet switching each message must be divided into packets and later reassembled. packet switching is the method most commonly used on data networks because it makes the best use of network bandwidth. . . contention depending on the network topology a link may connect more than two sites in the computer network and several of these sites may want to transmit information over a link simultaneously. this situation occurs mainly in a ring or multiaccess bus network. in this case the transmitted information may become scrambled. if it does it must be discarded and the sites must be notified about the problem so that they can retransmit the information. if no special provisions are made this situation may be repeated resulting in degraded performance. several techniques have been developed to avoid repeated collisions including collision detection and token passing. csma cd. before transmitting a message over a link a site must listen to determine whether another message is currently being transmitted over that link this technique is called carrier sense with multiple access csma . if the link is free the site can start transmitting. otherwise it must wait and continue to listen until the link is free. if two or more sites begin transmitting at exactly the same time each thinking that no other site is using the link then they will register a collision detection cd and will chapter distributed system structures stop transmitting. each site will try again after some random time interval. the main problem with this approach is that when the system is very busy many collisions may occur and thus performance may be degraded. nevertheless csma cd has been used successfully in the ethernet system the most common local area network system. one strategy for limiting the number of collisions is to limit the number of hosts per ethernet network. adding more hosts to a congested network could result in poor network throughput. as systems get faster they are able to send more packets per time segment. as a result the number of systems per ethernet network generally is decreasing so that networking performance is kept reasonable. token passing. a unique message type known as a token continuously circulates in the system usually a ring structure . a site that wants to transmit information must wait until the token arrives. it removes the token from the ring and begins to transmit its messages. when the site completes its round of message passing it retransmits the token. this action in turn allows another site to receive and remove the token and to start its message transmission. if the token gets lost the system must then detect the loss and generate a new token. it usually does that by declaring an election to choose a unique site where a new token will be generated. later in section . we present one election algorithm. a token passing scheme has been adopted by the ibm and hp apollo systems. the benefit of a token passing network is that performance is constant. adding new sites to a network may lengthen the waiting time for a token but it will not cause a large performance decrease as may happen on ethernet. on lightly loaded networks however ethernet is more efficient because systems can send messages at any time