 to the degree that protection is provided in existing computer systems it is usually achieved through an operating system kernel which acts as a security agent to inspect and validate each attempt to access a protected resource. since comprehensive access validation is potentially a source of considerable overhead either we must give it hardware support to reduce the cost of each validation or we must accept that the system designer may compromise the goals of protection. satisfying all these goals is difficult if the flexibility to implement protection policies is restricted by the support mechanisms provided or if protection environments are made larger than necessary to secure greater operational efficiency. as operating systems have become more complex and particularly as they have attempted to provide higher level user interfaces the goals of protection have become much more refined. the designers of protection systems have drawn heavily on ideas that originated in programming languages and especially on the concepts of abstract data types and objects. protection systems are now concerned not only with the identity of a resource to which access is attempted but also with the functional nature of that access in the newest protection systems concern for the function to be invoked extends beyond a set of system defined functions such as standard file access methods to include functions that may be user defined as well. policies for resource use may also vary depending on the application and they may be subject to change over time. for these reasons protection can no longer be considered a matter of concern to only the designer of an operating system. it should also be available as a tool for use by the application designer so that resources of an applications subsystem can be guarded against tampering or the influence of an error. . . compiler based enforcement at this point programming languages enter the picture. specifying the desired control of access to a shared resource in a system is making a declarative statement about the resource. this kind of statement can be integrated into a language by an extension of its typing facility. when protection is declared along with data typing the designer of each subsystem can specify its requirements for protection as well as its need for use of other resources in a system. such a specification should be given directly as a program is composed and in the language in which the program itself is stated.. this approach has several significant advantages . language based protection . protection needs are simply declared rather than programmed as a sequence of calls on procedures of an operating system. . protection requirements can be stated independently of the facilities provided by a particular operating system. . the means for enforcement need not be provided by the designer of a subsystem. . a declarative notation is natural because access privileges are closely related to the linguistic concept of data type. a variety of techniques can be provided by a programming language implementation to enforce protection but any of these must depend on some degree of support from an underlying machine and its operating system. for example suppose a language is used to generate code to run on the cambridge cap system. on this system every storage reference made on the underlying hardware occurs indirectly through a capability. this restriction prevents any process from accessing a resource outside of its protection environment at any time. however a program may impose arbitrary restrictions on how a resource can be used during execution of a particular code segment. we can implement such restrictions most readily by using the software capabilities provided by cap. a language implementation might provide standard protected procedures to interpret software capabilities that would realize the protection policies that could be specified in the language. this scheme puts policy specification at the disposal of the programmers while freeing them from implementing its enforcement. even if a system does not provide a protection kernel as powerful as those of hydra or cap mechanisms are still available for implementing protection specifications given in a programming language. the principal distinction is that the security of this protection will not be as great as that supported by a protection kernel because the mechanism must rely on more assumptions about the operational state of the system. a compiler can separate references for which it can certify that no protection violation could occur from those for which a violation might be possible and it can treat them differently. the security provided by this form of protection rests on the assumption that the code generated by the compiler will not be modified prior to or during its execution. what then are the relative merits of enforcement based solely on a kernel as opposed to enforcement provided largely by a compiler? security. enforcement by a kernel provides a greater degree of security of the protection system itself than does the generation of protectionchecking code by a compiler. in a compiler supported scheme security rests on correctness of the translator on some underlying mechanism of storage management that protects the segments from which compiled code is executed and ultimately on'the security of files from which a program is loaded. some of these considerations also apply to a softwaresupported protection kernel but to a lesser degree since the kernel may reside in fixed physical storage segments and may be loaded from only a designated file. with a tagged capability system in which all address . chapter protection computation is performed either by hardware or by a fixed microprogram even greater security is possible. hardware supported protection is also relatively immune to protection violations that might occur as a result of either hardware or system software malfunction. flexibility. there are limits to the flexibility of a protection kernel in implementing a user defined policy although it may supply adequate facilities for the system to provide enforcement of its own policies. with a programming language protection policy can be declared and enforcement provided as needed by an implementation. if a language does not provide sufficient flexibility it can be extended or replaced with less disturbance of a system in service than would be caused by the modification of an operating system kernel. efficiency. the greatest efficiency is obtained wrhen enforcement of protection is supported directly by hardware or microcode . insofar as software support is required language based enforcement has the advantage that static access enforcement can be verified off line at compile time. also since an intelligent compiler can tailor the enforcement mechanism to meet the specified need the fixed overhead of kernel calls can often be avoided. in summary the specification of protection in a programming language allows the high level description of policies for the allocation and use of resources. a language implementation can provide software for protection enforcement when automatic hardware supported checking is unavailable. in addition it can interpret protection specifications to generate calls on whatever protection system is provided by the hardware and the operating system. one way of making protection available to the application program is through the use of a software capability that could be used as an object of computation. inherent in this concept is the idea that certain program components might have the privilege of creating or examining these software capabilities. a capability creating program would be able to execute a primitive operation that would seal a data structure rendering the latter's contents inaccessible to any program components that did not hold either the seal or the unseal privilege. they might copy the data structure or pass its address to other program components but they could not gain access to its contents. the reason for introducing such software capabilities is to bring a protection mechanism into the programming language. the only problem with the concept as proposed is that the use of the seal and unseal operations takes a procedural approach to specifying protection. a nonprocedural or declarative notation seems a preferable way to make protection available to the application programmer. what is needed is a safe dynamic access control mechanism for distributing capabilities to system resources among user processes. to contribute to the overall reliability of a system the access control mechanism should be safe to use. to be useful in practice it should also be reasonably efficient. this requirement has led to the development of a number of language constructs that allow the programmer to declare various restrictions on the use of a specific managed resource. see the bibliographical notes for appropriate references. these constructs provide mechanisms for three functions . language based protection . distributing capabilities safely and efficiently among customer processes in particular mechanisms ensure that a user process will use the managed resource only if it was granted a capability to that resource . specifying the type of operations that a particular process may invoke on an allocated resource for example a reader of a file should be allowed only to read the file whereas a writer should be able both to read and to write it should not be necessary to grant the same set of rights to every user process and it should be impossible for a process to enlarge its set of access rights except with the authorization of the access control mechanism. . specifying the order in which a particular process may invoke the various operations of a resource for example a file must be opened before it can be read it should be possible to give two processes different restrictions on the order in which they can invoke the operations of the allocated resource. the incorporation of protection concepts into programming languages as a practical tool for system design is in its infancy. protection will likely become a matter of greater concern to the designers of new systems with distributed architectures and increasingly stringent requirements on data security. then the importance of suitable language notations in which to express protection requirements will be recognized more widely. . . protection in java because java was designed to run in a distributed environment the java virtual machine or jvm has many built in protecion mechanisms. java programs are composed of classes each of which is a collection of data fields and functions called methods that operate on those fields. the jvm loads a class in response to a request to create instances or objects of that class. one of the most novel and useful features of java is its support for dynamically loading untrusted classes over a network and for executing mutually distrusting classes within the same vm. because of these capabilities of java protection is a paramount concern. classes running in the same jvm may be from different sources and may not be equally trusted. as a result enforcing protection at the granularity of the jvm process is insufficient. intuitively whether a request to open a file should be allowed will generally depend on which class has requested the open. the operating system lacks this knowledge. thus such protection decisions are handled within the jvm. when the jvm loads a class it assigns the class to a protection domain that gives the permissions of that class. the protection domain to which the class is assigned depends on the url from which the class was loaded and any digital signatures on the class file. digital signatures are covered in section . . . . a configurable policy file determines the permissions granted to the domain and its classes . for example classes loaded from a trusted server might be placed in a protection domain that allows them to access files in the user's home directory whereas classes loaded from an untrusted server might have no file access permissions at all. s chapter protection it can be complicated for the jvm to determine what class is responsible for a request to access a protected resource. accesses are often performed indirectly through system libraries or other classes. for example consider a class that is not allowed to open network connections. it could call a system library to request the load of the contents of a url. the jvm must decide whether or not to open a network connection for this request. but which class should be used to determine if the connection should be allowed the application or the system library? the philosophy adopted in java is to require the library class to explicitly permit the network connection to load the requested url. more generally in order to access a protected resource some method in the calling sequence that resulted in the request must explicitly assert the privilege to access the resource. by doing so this method takes responsibility for the request presumably it will also perform whatever checks are necessary to ensure the safety of the request. of course not every method is allowed to assert a privilege a method can assert a privilege only if its class is in a protection domain that is itself allowed to exercise the privilege. this implementation approach is called stack inspection. every thread in the jvm has an associated stack of its ongoing method invocations. when its caller may not be trusted a method executes an access request within a doprivileged block to perform the access to a protected resource directly or indirectly. doprivileged is a static method in the accesscontroller class that is passed a class with a run method to invoke. when the doprivileged block is entered the stack frame for this method is annotated to indicate this fact. then the contents of the block are executed. when an access to a protected resource is subsequently requested either by this method or a method it calls a call to checkpermissionso is used to invoke stack inspection to determine if the request should be allowed. the inspection examines stack frames on the calling thread's stack starting from the most recently added frame and working toward the oldest. if a stack frame is first found that has the doprivileged annotation then checkpermissionso returns immediately and silently allowing the access. if a stack frame is first found for which access is disallowed based on the protection domain of the method's class then checkpermissionso throws an accesscontrolexception. if the stack inspection exhausts the stack without finding either type of frame then whether access is allowed depends on the implementation for example some implementations of the jvm may allow access other implementations may disallow it . stack inspection is illustrated in figure . . here the gui method of a class in the tmtrusted applet protection domain performs two operations first a get o and then an open . the former is an invocation of the get method of a class in the url loader protection domain which is permitted to openo sessions to sites in the l u c e n t . com domain in particular a proxy server proxy.lucent.com for retrieving urls. for this reason the untrusted applet's get invocation will succeed the checkpermissionso call in the networking library encounters the stack frame of the get method which performed its openo in a doprivileged block. however the untrusted applet's openo invocation will result in an exception because the checkpermissionso call finds no doprivileged annotation before encountering the stack frame of the gui method