 to the user the i o system in linux looks much like that in any unix system. that is to the extent possible all device drivers appear as normal files. a user can open an access channel to a device in the same way she opens any . input and output user application i file system j . b!ock.. character network device file device file socket i o scheduler . . .. i i . ij protocol ji. .. . . i j driver l block scsi manager device s c s device character network dnver device device driver driver driver figure . device driver block structure. other file devices can appear as objects within the file system. the system administrator can create special files within a file system that contain references to a specific device driver and a user opening such a file will be able to read from and write to the device referenced. by using the normal file protection system which determines who can access which file the administrator can set access permissions for each device. linux splits all devices into three classes block devices character devices and network devices. figure . illustrates the overall structure of the device driver system. block devices include all devices that allow random access to completely independent fixed sized blocks of data including hard disks and floppy disks cd roms and flash memory. block devices are typically used to store file systems but direct access to a block device is also allowed so that programs can create and repair the file system that the device contains. applications can also access these block devices directly if they wish for example a database application may prefer to perform its own fine tuned laying out of data onto the disk rather than using the general purpose file system. character devices include most other devices such as mice and keyboards. the fundamental difference between block and character devices is random access block devices may be accessed randomly while character devices are only accessed serially. for example seeking to a certain position in a file might be supported for a dvd but makes no sense to a pointing device such as a mouse. network devices are dealt with differently from block and character devices. users cannot directly transfer data to network devices instead they must communicate indirectly by opening a connection to the kernel's networking subsystem. we discuss the interface to network devices separately in section . . . . block devices block devices provide the main interface to all disk devices in a system. performance is particularly important for disks and the block device system must provide functionality to ensure that disk access is as fast as possible. this functionality is achieved through the scheduling of i o operations. chapter the linux system in the context of block devices a block represents the unit with which the kernel performs i o. when a block is read into memory it is stored in a buffer. the request manager is the layer of software that manages the reading and writing of buffer contents to and from a block device driver. a separate list of requests is kept for each block device driver. traditionally these requests have been scheduled according to a unidirectional elevator c scan algorithm that exploits the order in which requests are inserted in and removed from the per device lists. the request lists are maintained in sorted order of increasing starting sector number. when a request is accepted for processing by a block device driver it is not removed from the list. it is removed only after the i o is complete at which point the driver continues with the next request in the list even if new requests have been inserted into the list before the active request. as new i o requests are made the request manager attempts to merge requests in the per device lists. the scheduling of i o operations changed somewhat with version . of the kernel. the fundamental problem with the elevator algorithm is that i o operations concentrated in a specific region of the disk can result in starvation of requests that need to occur in other regions of the disk. the deadline i o scheduler used in version . works similarly to the elevator algorithm except that it also associates a deadline with each request thus addressing the starvation issue. by default the deadline for read requests is . second and that for write requests is seconds. the deadline scheduler maintains a sorted queue of pending i o operations sorted by sector number. however it also maintains two other queues a read queue for read operations and a write queue for write operations. these two queues are ordered according to deadline. every i o request is placed in both the sorted queue and either the read or the write queue as appropriate. ordinarily i o operations occur from the sorted queue. however if a deadline expires for a request in either the read or the write queue i o operations are scheduled from the queue containing the expired request. this policy ensures that an i o operation will wait no longer than its expiration time. . . character devices a character device driver can be almost any device driver that does not offer random access to fixed blocks of data. any character device drivers registered to the linux kernel must also register a set of functions that implement the file i o operations that the driver can handle. the kernel performs almost no preprocessing of a file read or write request to a character device it simply passes the request to the device in question and lets the device deal with the request. the main exception to this rule is the special subset of character device drivers that implement terminal devices. the kernel maintains a standard interface to these drivers by means of a set of t t y s t r u c t structures. each of these structures provides buffering and flow control on the data stream from the terminal device and feeds those data to a line discipline. a line discipline is an interpreter for the information from the terminal device. the most common line discipline is the t t y discipline which glues the terminal's data stream onto the standard input and output streams of a user's running processes allowing those processes to communicate directly with the