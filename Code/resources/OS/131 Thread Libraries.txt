 user thread kernel thread figure . many to many model. application may be allocated more kernel threads on a multiprocessor than on a uniprocessor . whereas the many to one model allows the developer to create as many user threads as she wishes true concurrency is not gained because the kernel can schedule only one thread at a time. the one to one model allows for greater concurrency but the developer has to be careful not to create too many threads within an application and in some instances may be limited in the number of threads she can create . the many to many model suffers from neither of these shortcomings developers can create as many user threads as necessary and the corresponding kernel threads can run in parallel on a multiprocessor. also when a thread performs a blocking system call the kernel can schedule another thread for execution. one popular variation on the many to many model still multiplexes many user level threads to a smaller or equal number of kernel threads but also allows a user level thread to be bound to a kernel thread. this variation sometimes referred to as the tivo level model figure . is supported by operating systems such as irix hp ux and tru unix. the solaris operating system supported the two level model in versions older than solaris . however beginning with solaris this system uses the one to one model. . thread libraries a thread library provides the programmer an api for creating and managing threads. there are two primary ways of implementing a thread library. the first approach is to provide a library entirely in user space with no kernel support. all code and data structures for the library exist in user space. this means that invoking a function in the library results in a local function call in user space and not a system call. the second approach is to implement a kernel level library supported directly by the operating system. in this case code and data structures for the library exist in kernel space. invoking a function in the api for the library typically results in a system call to the kernel. three main thread libraries are in use today posix pthreads win and java. pthreads the threads extension of the posix standard may be chapter threads user thread kernel thread figure . two level model. provided as either a user or kernel level library. the win thread library is a kernel level library available on windows systems. the java thread api allows thread creation and management directly in java programs. however because in most instances the jvm is running on top of a host operating system the java thread api is typically implemented using a thread library available on the host system. this means that on windows systems java threads are typically implemented using the win api unix and linux systems often use pthreads. in the remainder of this section we describe basic thread creation using these three thread libraries. as an illustrative example we design a multithreaded program that performs the summation of a non negative integer in a separate thread using the well known summation function sum o for example if n were this function would represent the summation from to which is . each of the three programs will be run with the upper bounds of the summation entered on the command line thus if the user enters the summation of the integer values from to will be output. . . pthreads pthreads refers to the posix standard ieee . c defining an api for thread creation and synchronization. this is a specification for thread behavior not an implementation. operating system designers may implement the specification in any way they wish. numerous systems implement the pthreads specification including solaris linux mac os x and tru unix. shareware implementations are available in the public domain for the various windows operating systems as well. the c program shown in figure . demonstrates the basic pthreads api for constructing a multithreaded program that calculates the summation of a nonnegative integer in a separate thread. in a pthreads program separate threads begin execution in a specified function. in figure . this is the runner function. when this program begins a single thread of control begins in . thread libraries include pthread.h include stdio.h int sum this data is shared by the thread s void runner void param the thread int main int argc char argv pthread t tid the thread identifier pthread.attr t attr set of thread attributes if argc ! fprintf stderr usage a.out integer value n return if atoi argv fprintf stderr d must be n atoi argv return get the default attributes pthread.attr.init attr create the thread pthread create tid attr runner argv wait for the thread to exit pthread join tid null printf sum d n sum the thread will begin control in this function void runner void param int i upper atoi param sum for i i upper i sum i pthread exit figure . multithreaded c program using the pthreads api. maino. after some initialization maino creates a second thread that begins control in the runner function. both threads share the global data sum. let's look more closely at this program. all pthreads programs must include the pthread.h header file. the statement pthreadjt t i d declares the identifier for the thread we will create. each thread has a set of attributes including stack size and scheduling information. the pthread attr t attr chapter threads declaration represents the attributes for the thread. we set the attributes in the function call pthread attr init c attr . because we did not explicitly set any attributes we use the default attributes provided. in chapter we will discuss some of the scheduling attributes provided by the pthreads api. a separate thread is created with the pthread creat e function call. in addition to passing the thread identifier and the attributes for the thread we also pass the name of the function where the new thread will begin execution in this case the runner function. last we pass the integer parameter that was provided on the command line argv . at this point the program has two threads the initial or parent thread in maino and the summation or child thread performing the summation operation in the runner function. after creating the summation thread the parent thread will wait for it to complete by calling the pthread join function. the summation thread will complete when it calls the function pthread.exit . once the summation thread has returned the parent thread will output the value of the shared data sum. . . win threads the technique for creating threads using the win thread library is similar to the pthreads technique in several ways. we illustrate the win thread api in the c program shown in figure . . notice that we must include the windows. h header file when using the win api. just as in the pthreads version shown in figure . data shared by the separate threads in this case sum are declared globally the dword data type is an unsigned bit integer. we also define the summationo function that is to be performed in a separate thread. this function is passed a pointer to a void which win defines as lpvoid. the thread performing this function sets the global data sum to the value of the summation from to the parameter passed to summationo. threads are created in the win api using the createthreado function and just as in pthreads a set of attributes for the thread is passed to this function. these attributes include security information the size of the stack and a flag that can be set to indicate if the thread is to start in a suspended state. in this program we use the default values for these attributes which do not initially set the thread to a suspended state and instead make it eligible to be run by the cpu scheduler . once the summation thread is created the parent must wait for it to complete before outputting the value of sum as the value is set by the summation thread. recall that the pthread program figure . had the parent thread wait for the summation thread using the pthread j oin statement. we perform the equivalent of this in the win api using the waitforsingleobj ect function which causes the creating thread to block until the summation thread has exited. we will cover synchronization objects in more detail in chapter . . . java threads threads are the fundamental model of program execution in a java program and the java language and its api provide a rich set of features for the creation and management of threads. all java programs comprise at least a single thread . thread libraries inciude windows.h include stdio.h dword sum data is shared by the thread s the thread runs in this separate function dword winapi summation lpvoid param dword upper dword param for dword i i upper i sum i return int main int argc char argv dword threadld handle threadhandle int param perform some basic error checking if argc ! fprintf stderr an integer parameter is required n return param atoi argv l if param fprintf stderr an integer is required n return create the thread threadhandle createthread null default security attributes default stack size summation thread function param parameter to thread function default creation flags sthreadld returns the thread identifier if threadhandle ! null now wait for the thread to finish waitforsingleobject threadhandle infinite close the thread handle closehandle threadhandle printfc'sum d n sum figure . multithreaded c program using the win api. chapter threads of control even a simple java program consisting of only a main. method runs as a single thread in the jvm. there are two techniques for creating threads in a java program. one approach is to create a new class that is derived from the thread class and to override its run method. an alternative and more commonly used technique is to define a class that implements the runnable interface. the runnable interface is defined as follows public interface runnable public abstract void run when a class implements runnable it must define a run method. the code implementing the run method is what runs as a separate thread. figure . shows the java version of a multithreaded program that determines the summation of a non negative integer. the summation class implements the runnable interface. thread creation is performed by creating an object instance of the thread class and passing the constructor a runnable object. creating a thread object does not specifically create the new thread rather it is the s t a r t method that actually creates the new thread. calling the s t a r t method for the new object does two things . it allocates memory and initializes a new thread in the jvm. . it calls the run method making the thread eligible to be run by the jvm. note that we never call the run method directly. rather we call the s t a r t method and it calls the run method on our behalf. when the summation program runs two threads are created by the jvm. the first is the parent thread which starts execution in the main method. the second thread is created when the s t a r t method on the thread object is invoked. this child thread begins execution in the run method of the summation class. after outputting the value of the summation this thread terminates when it exits from its run method. sharing of data between threads occurs easily in win and pthreads as shared data are simply declared globally. as a pure object oriented language java has no such notion of global data if two or more threads are to share data in a java program the sharing occurs by passing reference to the shared object to the appropriate threads. in the java program shown in figure . the main thread and the summation thread share the the object instance of the sum class. this shared object is referenced through the appropriate getsumo and setsumo methods. you might wonder why we don't use an integer object rather than designing a new sum class. the reason is that the integer class is immutable that is once its value is set it cannot change. recall that the parent threads in the pthreads and win libraries use pthreacljoino and waitforsingleobject respectively to wait for the summation threads to finish before proceeding. the joino method in java provides similar functionality. notice that joino can throw an interruptedexception which we choose to ignore. . thread libraries lass sura private int sum public int getsumo return sum public void setsum ir.t sum this.sum sum class summation implements runnable private int upper private suit. sumvalue public summation int upper sum sumvalue this.upper upper this.sumvalue sumvalue public void run int sum for int i i upper i sum i sumvalue.setsum sum public class driver public static void main string args if args.length if integer.parseint args system.err.println args must be . else create the object to be shared sum sumobject new sum int upper integer.parseint args thread thrd new thread new summation upper sumobject thrd.start try thrd.join system.out.println the sum of upper is sumobject.getsum catch interruptedexception ie else system.err.println usage summation integer value figure . java program for the summation of a non negative integer. chapter threads the jvm and host operating system the jvm is typically implemented on top of a host operating system see pigure . . this setup allows the jvm to bide the implementation details of the underlying operating system and to provide a consistent abstract environment that allows java programs to operate on any platform that supports a jvm. the specification for the jvm does not indicate how java 'threads are to be mapped to the underlying operating system instead leaving that decision to the particular implementation.of the jvm. for example the windows xp operating system uses the one to one model therefore each java thread for a' jvvi running on such a system maps to a kernel thread. on operating systems that use the m.any to many model. such as tru unix a java thread is mapped according to the many to many model. solaris ini tially implemented the jvm using the many to one model the green thre'adslibrary ' mentioned earlier . later releases of the jvm were implemented using the many to many model. beginning with solaris java threads were mapped using the one to one model. in addition there may be a relationship between the java thread library and the thread library on the host operating system. for example implementations of a. jvm for the windows family of operating systems might use the win api when creating java threads linux and solaris systems might use the pthreads apl