 maximum privileges and access to the entire system as happens too often today . such an operating system also provides system calls and services that allow applications to be written with fine grained access controls. it provides mechanisms to enable privileges when they are needed and to disable them when they are not needed. also beneficial is the creation of audit trails for all privileged function access. the audit trail allows the programmer systems administrator or law enforcement officer to trace all protection and security activities on the system. managing users with the principle of least privilege entails creating a separate account for each user with just the privileges that the user needs. an operator who needs to mount tapes and backup files on the system has access to just those commands and files needed to accomplish the job. some systems implement role based access control rbac to provide this functionality. computers implemented in a computing facility under the principle of least privilege can be limited to running specific services accessing specific remote hosts via specific services and doing so during specific times. typically these restrictions are implemented through enabling or disabling each service and through access control lists as described in section . . and . . the principle of least privilege can help produce a more secure computing environment. unfortunately it frequently does not. for example windows has a complex protection scheme at its core and yet has many security holes. by comparison solaris is considered relatively secure even though it is a variant of unix which historically was designed with little protection in mind. one reason for the difference may be that windows has more lines of code and more services than solaris and thus has more to secure and protect. another reason could be that the protection scheme in windows is incomplete or protects the wrong aspects of the operating system leaving other areas vulnerable. . domain of protection a computer system is a collection of processes and objects. by objects we mean both hardware objects such as the cpu memory segments printers disks and tape drives and software objects such as files programs and semaphores . each object has a unique name that differentiates it from all other objects in the system and each can be accessed only through well defined and meaningful operations. objects are essentially abstract data types. the operations that are possible may depend on the object. for example a cpu can only be executed on. memory segments can be read and written whereas a cd rom or dvd rom can only be read. tape drives can be read written and rewound. data files can be created opened read written closed and deleted program files can be read written executed and deleted. a process should be allowed to access only those resources for which it has authorization. furthermore at any time a process should be able to access only those resources that it currently requires to complete its task. this second requirement commonly referred to as the need to knozv principle is useful in limiting the amount of damage a faulty process can cause in the system. for example when process p invokes procedure a the procedure should be chapter protection allowed to access only its own variables and the formal parameters passed to it it should not be able to access all the variables of process p. similarly consider the case where process p invokes a compiler to compile a particular file. the compiler should not be able to access files arbitrarily but should have access only to a well defined subset of files such as the source file listing file and so on related to the file to be compiled. conversely the compiler may have private files used for accounting or optimization purposes that process p should not be able to access. the need to know principle is similar to the principle of least privilege discussed in section . in that the goals of protection are to minimize the risks of possible security violations. . . domain structure to facilitate this scheme a process operates within a protection domain which specifies the resources that the process may access. each domain defines a set of objects and the types of operations that may be invoked on each object. the ability to execute an operation on an object is an access right. a domain is a collection of access rights each of which is an ordered pair object iiame rights set . for example if domain d has the access right file f read write then a process executing in domain d can both read and write file f it cannot however perform any other operation on that object. domains do not need to be disjoint they may share access rights. for example in figure . we have three domains dir d and d . the access right oi print is shared by d? and d implying that a process executing in either of these two domains can print object o . note that a process must be executing in domain d to read and write object o while only processes in domain d may execute object o . the association between a process and a domain may be either static if the set of resources available to the process is fixed throughout the process's lifetime or dynamic. as might be expected establishing dynamic protection domains is more complicated than establishing static protection domains. if the association between processes and domains is fixed and we want to adhere to the need to know principle then a mechanism must be available to change the content of a domain. the reason stems from the fact that a process may execute in two different phases and may for example need read access in one phase and write access in another. if a domain is static. we must define the domain to include both read and write access. however this arrangement provides more rights than are needed in each of the two phases since we have read access in the phase where we need only write access and vice versa. thus d figure . system with three protection domains. . domain of protection the need to know principle is violated. we must allow the contents of a domain to be modified so that it always reflects the minimum necessary access rights. if the association is dynamic a mechanism is available to allow domain switching enabling the process to switch from one domain to another. we may also want to allow the content of a domain to be changed. if we cannot change the content of a domain we can provide the same effect by creating a new domain with the changed content and switching to that new domain when we want to change the domain content. a domain can be realized in a variety of ways each user may be a domain. in this case the set of objects that can be accessed depends on the identity of the user. domain switching occurs when the user is changed generally when one user logs out and another user logs in. each process may be a domain. in this case the set of objects that can be accessed depends on the identity of the process. domain switching occurs when one process sends a message to another process and then waits for a response. each procedure may be a domain. in this case the set of objects that can be accessed corresponds to the local variables defined within the procedure. domain switching occurs when a procedure call is made. we discuss domain switching in greater detail in section . . consider the standard dual mode monitor user mode model of operating system execution. when a process executes in monitor mode it can execute privileged instructions and thus gain complete control of the computer system. in contrast when a process executes in user mode it can invoke only nonprivileged instructions. consequently it can execute only within its predefined memory space. these two modes protect the operating system executing in monitor domain from the user processes executing in user domain . in a multiprogrammed operating system two protection domains are insufficient since users also want to be protected from one another. therefore a more elaborate scheme is needed. we illustrate such a scheme by examining two influential operating systems unix and mult cs to see how these concepts have been implemented there. . . an example unix in the unix operating system a domain is associated with the user. switching the domain corresponds to changing the user identification temporarily. this change is accomplished through the file system as follows. an owner identification and a domain bit known as the setuid bit are associated with each file. when the setuid bit is on and a user executes that file the user id is set to that of the owner of the file when the bit is off however the user id does not change. for example when a user a that is a user with userld a starts executing a file owned by b whose associated domain bit is off the uscrld of the process is set to a. when the setuid bit is on the userld is set to that of the owner of the file b. when the process exits this temporary userld change ends. chapter protection other methods are used to change domains in operating systems in which user ids are used for domain definition because almost all systems need to provide such a mechanism. this mechanism is used when an otherwise privileged facility needs to be made available to the general user population. for instance it might be desirable to allow users to access a network without letting them write their own networking programs. in such a case on a unix system the setuid bit on a networking program would be set causing the user id to change when the program was run. the user id would change to that of a user with network access privilege such as root the most powerful user id . one problem with this method is that if a user manages to create a file with user id root and with its setuid bit on that user can become root and do anything and everything on the system. the setuid mechanism is discussed further in appendix a. an alternative to this method used in other operating systems is to place privileged programs in a special directory. the operating system would be designed to change the user id of any program run from this directory either to the equivalent of root or to the user id of the owner of the directory. this eliminates one security problem with setuid programs in which crackers create and hide using obscure file or directory names them for later use. this method is less flexible than that used in unix however. even more restrictive and thus more protective are systems that simply do not allow a change of user id. in these instances special techniques must be used to allow users access to privileged facilities. for instance a daemon process may be started at boot time and run as a special user id. users then run a separate program which sends requests to this process whenever they need to use the facility this method is used by the tops operating system. in any of these systems great care must be taken in writing privileged programs. any oversight can result in a total lack of protection on the system. generally these programs are the first to be attacked by people trying to break into a system unfortunately the attackers are frequently successful. for example security has been breached on many unix systems because of the setuid feature. we discuss security in chapter . . . an example multics in the multics system the protection domains are organized hierarchically into a ring structure. each ring corresponds to a single domain figure . . the rings are numbered from to . let d and d be any two domain rings. if then d is a subset of d . that is a process executing in domain d has more privileges than does a process executing in domain d a process executing in domain do has the most privileges. if only two rings exist this scheme is equivalent to the monitor user mode of execution where monitor mode corresponds to do and user mode corresponds to d . multics has a segmented address space each segment is a file and each segment is associated with one of the rings. a segment description includes an entry that identifies the ring number. in addition it includes three access bits to control reading writing and execution. the association between segments and rings is a policy decision with which we are not concerned here. a cuirent ring mtmber counter is associated with each process identifying the ring in which the process is executing currently. when a process is executing . domain of protection s ring ring n figure . multics ring structure. in ring ' it cannot access a segment associated with ring i . it can access a segment associated with ring k k . the type of access however is restricted according to the access bits associated with that segment. domain switching in multics occurs when a process crosses from one ring to another by calling a procedure in a different ring. obviously this switch must be done in a controlled manner otherwise a process could start executing in ring and no protection would be provided. to allow controlled domain switching we modify the ring field of the segment descriptor to include the following access bracket. a pair of integers bl and bl such that bl bl. limit. an integer b such that b bl. list of gates. identifies the entry points or gates at which the segments may be called. if a process executing in ring ' calls a procedure or segment with access bracket bl bl then the call is allowed if bl s ' bl and the current ring number of the process remains '. otherwise a trap to the operating system occurs and the situation is handled as follows if bl then the call is allowed to occur because we have a transfer to a ring or domain with fewer privileges. however if parameters are passed that refer to segments in a lower ring that is segments not accessible to the called procedure then these segments must be copied into an area that can be accessed by the called procedure. if bl then the call is allowed to occur only if b is greater than or equal to and the call has been directed to one of the designated entry points in the list of gates. this scheme allows processes with limited access rights to call procedures in lower rings that have more access rights but only in a carefully controlled manner. chapter protection the main disadvantage of the ring or hierarchical structure is that it ctoes not allow us to enforce the need to know principle. in particular if an object must be accessible in domain d but not accessible in domain du then we must have i. but this requirement means that every segment accessible in d is also accessible in d . the mult cs protection system is generally more complex and less efficient than are those used in current operating systems. if protection interferes with the ease of use of the system or significantly decreases system performance then its use must be weighed carefully against the purpose of the system. for instance we would want to have a complex protection system on a computer used by a university to process students' grades and also used by students for classwork. a similar protection system would notbe suited to a computer being used for number crunching in which performance is of utmost importance. we would prefer to separate the mechanism from the protection policy allowing the same system to have complex or simple protection depending on the needs of its users. to separate mechanism from policy we require a more general model of protection