 commercial versions of unix such as solaris and ibm's aix system. however there has been significant development in gui designs from various opensource projects such as k desktop environment or kde and the gnome desktop by the gnu project. both the kde and gnome desktops rim on linux and various unix systems and are available under open source licenses which means their source code is in the public domain. the choice of whether to use a command line or gui interface is mostly one of personal preference. as a very general rule many unix users prefer a command line interface as they often provide powerful shell interfaces. alternatively most windows users are pleased to use the windows gui environment and almost never use the ms dos shell interface. the various changes undergone by the macintosh operating systems provides a nice study in contrast. historically mac os has not provided a command line interface always requiring its users to interface with the operating system using its gui. however with the release of mac os x which is in part implemented using a unix kernel the operating system now provides both a new aqua interface and command line interface as well. the user interface can vary from system to system and even from user to user within a system. it typically is substantially removed from the actual system structure. the design of a useful and friendly user interface is therefore not a direct function of the operating system. in this book we concentrate on the fundamental problems of providing adequate service to user programs. from the point of view of the operating system we do not distinguish between user programs and system programs. . system calls system calls provide an interface to the services made available by an operating system. these calls are generally available as routines written in c and c although certain low level tasks for example tasks where hardware must be accessed directly may need to be written using assembly language instructions. before we discuss how an operating system makes system calls available let's first use an example to illustrate how system calls are used writing a simple program to read data from one file and copy them to another file. the first input that the program will need is the names of the two files the input file and the output file. these names can be specified in many ways depending on the operating system design. one approach is for the program to ask the user for the names of the two files. in an interactive system this approach will require a sequence of system calls first to write a prompting message on the screen and then to read from the keyboard the characters that define the two files. on mouse based and icon based systems a menu of file names is usually displayed in a window. the user can then use the mouse to select the source name and a window can be opened for the destination name to be specified. this sequence requires many i o system calls. once the two file names are obtained the program must open the input file and create the output file. each of these operations requires another system call. there are also possible error conditions for each operation. when the program tries to open the input file it may find that there is no file of that name or that chapter operating system structures the file is protected against access. in these cases the program should print a message on the console another sequence of system calls and then terminate abnormally another system call . if the input file exists then we must create a new output file. we may find that there is already an output file with the same name. this situation may cause the program to abort a system call or we may delete the existing file another system call and create a new one another system call . another option in an interactive system is to ask the user via a sequence of system calls to output the prompting message and to read the response from the terminal whether to replace the existing file or to abort the program. now that both files are set up we enter a loop that reads from the input file a system call and writes to the output file another system call . each read and write must return status information regarding various possible error conditions. on input the program may find that the end of the file has been reached or that there was a hardware failure in the read such as a parity error . the write operation may encounter various errors depending on the output device no more disk space printer out of paper and so on . finally after the entire file is copied the program may close both files another system call write a message to the console or window more system calls and finally terminate normally the final system call . as we can see even simple programs may make heavy use of the operating system. frequently systems execute thousands of system calls per second. this systemcall sequence is shown in figure . . most programmers never see this level of detail however. typically application developers design programs according to an application programming interface api . the api specifies a set of functions that are available to an application programmer including the parameters that are passed to each source file destination file example system call sequence acquire input file name write prompt to screen accept input acquire output file name write prompt to screen accept input open the input file if file doesn't exist abort create output file if file exists abort loop read from input file write to output file until read fails close output file write completion message to screen terminate normally figure . example of how system calls are used. . system calls example of standard api as an example of a standard api consider the readfileq function in the win api a function for reading from a file. the api for this function appears ln figure . . return value i bool readfile c handle file lpvoid buffer t dwwoorrd bbyytteess ttoo rreeaadd parameters lpdword bytec read function name lpoverlapped ov . figure . the api for the readfileo function. a description of the parameters passed to readfileo is as follows 'handle file the file to be read. lpvoid buffer a buffer where the data will be read into and written from. dword bytestoread the number of bytes to be read into the buffer. lpdword bytesread the number of bytes read during the last read. lpoverlapped ovl i ndicates if overlapped i o is being used. function and the return values the programmer can expect. three of the most common apis available to application programmers are the win api for windows systems the posix api for posix based systems which includes virtually all versions of unix linux and mac os x and the java api for designing programs that run on the java virtual machine. note that the system call names used throughout this text are generic examples. each operating system has its own name for each system call. behind the scenes the functions that make up an api typically invoke the actual system calls on behalf of the application programmer. for example the win function createprocess which unsurprisingly is used to create a new process actually calls the ntcreateprocess system call in the windows kernel. why would an application programmer prefer programming according to an api rather than invoking actual system calls? there are several reasons for doing so. one benefit of programming according to an api concerns program portability an application programmer designing a program using an api can expect her program to compile and run on any system that supports the same api although in reality architectural differences often make this more difficult than it may appear . furthermore actual system calls can often be more detailed chapter operating system structures and difficult to work with than the api available to an application programmer. regardless there often exists a strong correlation between invoking a function in the api and its associated system call within the kernel. in fact many of the posix and win apis are similar to the native system calls provided by the unix linux and windows operating systems. the run time support system a set of functions built into libraries included with a compiler for most programming languages provides a system call interface that serves as the link to system calls made available by the operating system. the system call interface intercepts function calls in the api and invokes the necessary system call within the operating system. typically a number is associated with each system call and the system call interface maintains a table indexed according to these numbers. the system call interface then invokes the intended system call in the operating system kernel and returns the status of the system call and any return values. the caller needs to know nothing about how the system call is implemented or what it does during execution. rather it just needs to obey the api and understand what the operating system will do as a result of the execution of that system call. thus most of the details of the operating system interface are hidden from the programmer by the api and are managed by the run time support library. the relationship between an api the system call interface and the operating system is shown in figure . which illustrates how the operating system handles a user application invoking the open system call. system calls occur in different ways depending on the computer in use. often more information is required than simply the identity of the desired system call. the exact type and amount of information vary according to the particular operating system and call. for example to get input we may need to specify the file or device to use as the source as well as the address and open user mode system call interface kernel mode open implementation of open system call return figure . the handling of a user application invoking the openq system call