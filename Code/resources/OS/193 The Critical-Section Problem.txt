 that the contents of this register will be saved and restored by the interrupt handler section . . . the concurrent execution of counter and counter is equivalent to a sequential execution where the lower level statements presented previously are interleaved in some arbitrary order but the order within each high level statement is preserved . one such interleaving is to producer execute registeri counter registeri ti producer execute register i register registeri tr. consumer execute register . counter register ty consumer execute register registeri register t producer execute counter registeri counter t consumer execute counter register counter notice that we have arrived at the incorrect state counter indicating that four buffers are full when in fact five buffers are full. if we reversed the order of the statements at t and t we would arrive at the incorrect state counter . we would arrive at this incorrect state because we allowed both processes to manipulate the variable counter concurrently. a situation like this where several processes access and manipulate the same data concurrently and the outcome of the execution depends on the particular order in which the access takes place is called a race condition. to guard against the race condition above we need to ensure that only one process at a time can be manipulating the variable counter. to make such a guarantee we require that the processes be synchronized in some way. situations such as the one just described occur frequently in operating systems as different parts of the system manipulate resources. clearly we want the resulting changes not to interfere with one another. because of the importance of this issue a major portion of this chapter is concerned with process synchronization and coordination. . the critical section problem consider a system consisting of n processes pq pi ... p . each process has a segment of code called a critical section in which the process may be changing common variables updating a table writing a file and so on. the important feature of the system is that when one process is executing in its critical section no other process is to be allowed to execute in its critical section. that is no two processes are executing in their critical sections at the same time. the critical section problem is to design a protocol that the processes can use to cooperate. each process must request permission to enter its critical section. the section of code implementing this request is the entry section. the critical section may be followed by an exit section. the remaining code is the remainder section. the general structure of a typical process p is shown in figure . . the entry section and exit section are enclosed in boxes to highlight these important segments of code. chapter process synchronization do entry section critical section exitsection remainder section while true figure . general structure of a typical process p . a solution to the critical section problem must satisfy the following three requirements . mutual exclusion. if process p is executing in its critical section then no other processes can be executing in their critical sections. . progress. if no process is executing in its critical section and some processes wish to enter their critical sections then only those processes that are not executing in their remainder sections can participate in the decision on which will enter its critical section next and this selection cannot be postponed indefinitely. . bounded waiting. there exists a bound or limit on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted. we assume that each process is executing at a nonzero speed. however we can make no assumption concerning the relative speed of the n processes. at a given point in time many kernel mode processes may be active in the operating system. as a result the code implementing an operating system kernel code is subject to several possible race conditions. consider as an example a kernel data structure that maintains a list of all open files in the system. this list must be modified when a new file is opened or closed adding the file to the list or removing it from the list . if two processes were to open files simultaneously the separate updates to this list could result in a race condition. other kernel data structures that are prone to possible race conditions include structures for maintaining memory allocation for maintaining process lists and for interrupt handling. it is up to kernel developers to ensure that the operating system is free from such race conditions. two general approaches are used to handle critical sections in operating systems preemptive kernels and nonpreemptive kernels. a preemptive kernel allows a process to be preempted while it is running in kernel mode. a nonpreemptive kernel does not allow a process running in kernel mode to be preempted a kernel mode process will run until it exits kernel mode blocks or voluntarily yields control of the cpu. obviously a nonpreemptive kernel is essentially free from race conditions on kernel data structures as . peterson's solution only one process is active in the kernel at a time. we cannot say the same about nonpreemptive kernels so they must be carefully designed to ensure that shared kernel data are free from race conditions. preemptive kernels are especially difficult to design for mp architectures since in these environments it is possible for two kernel mode processes to run simultaneously on different processors. why then would anyone favor a preemptive kernel over a nonpreemptive one? a preemptive kernel is more suitable for real time programming as it will allow a real time process to preempt a process currently running in the kernel. furthermore a preemptive kernel may be more responsive since there is less risk that a kernel mode process will run for an arbitrarily long period before relinquishing the processor to waiting processes. of course this effect can be minimized by designing kernel code that does not behave in this way. windows xp and windows are nonpreemptive kernels as is the traditional unix kernel. prior to linux . the linux kernel was nonpreemptive as well. however with the release of the . kernel linux changed to the preemptive model. several commercial versions of unix are preemptive including solaris and irix. . peterson's solution next we illustrate a classic software based solution to the critical section problem known as peterson's solution. because of the way modern computer architectures perform basic machine language instructions such as load and store there are no guarantees that peterson's solution will work correctly on such architectures. however we present the solution because it provides a good algorithmic description of solving the critical section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion progress and bounded waiting requirements. peterson's solution is restricted to two processes that alternate execution between their critical sections and remainder sections. the processes are numbered po and pi. for convenience when presenting p we use pj to denote the other process that is j equals i. peterson's solution requires two data items to be shared between the two processes int turn boolean f l a g the variable turn indicates whose turn it is to enter its critical section. that is if turn i then process p is allowed to execute in its critical section. the flag array is used to indicate if a process is ready to enter its critical section. for example if f lag i is true this value indicates that p is ready to enter its critical section. with an explanation of these data structures complete we are now ready to describe the algorithm shown in figure . to enter the critical section process p first sets flag i to be true and then sets turn to the value j thereby asserting that if the other process wishes to enter the critical section it can do so. if both processes try to enter at the same time turn will be set to both i and j at roughly the same time. only chapter process synchronization do flag i true turn j while flag j turn j critical section flag i false remainder section while true figure . the structure of process p in peterson's solution. one of these assignments will last the other will occur but will be overwritten immediately. the eventual value of turn decides which of the two processes is allowed to enter its critical section first. we now prove that this solution is correct. we need to show that . mutual exclusion is preserved. . the progress requirement is satisfied. . the bounded waiting requirement is met. to prove property we note that each p enters its critical section only if either f l a g j false or turn i. also note that if both processes can be executing in their critical sections at the same time then flag flag true. these two observations imply that po and pi could not have successfully executed their while statements at about the same time since the value of turn can be either or but cannot be both. hence one of the processes say pj must have successfully executed the while statement whereas p had to execute at least one additional statement turn j . however since at that time f l a g j true and turn j and this condition will persist as long as pj is in its critical section the result follows mutual exclusion is preserved. to prove properties and we note that a process p can be prevented from entering the critical section only if it is stuck in the while loop with the condition flag j true and turn j this loop is the only one possible. if p is not ready to enter the critical section then flag j false and p can enter its critical section. if pj has set flag j to t r u e and is also executing in its while statement then either turn i or turn j . if turn i then p will enter the critical section. if turn j then pj will enter the critical section. however once p exits its critical section it will reset f l a g j to false allowing p to enter its critical section. if pj resets flag j to true it must also set turn to i. thus since p does not change the value of the variable turn while executing the while statement p will enter the critical section progress after at most one entry by p bounded waiting 