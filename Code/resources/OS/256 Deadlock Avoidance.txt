 deadlock prevention algorithms as discussed in section . prevent deadlocks by restraining how requests can be made. the restraints ensure that at least one of the necessary conditions for deadlock cannot occur and hence that deadlocks cannot hold. possible side effects of preventing deadlocks by this method however are low device utilization and reduced system throughput. an alternative method for avoiding deadlocks is to require additional information about how resources are to be requested. for example in a system with one tape drive and one printer the system might need to know that process p will request first the tape drive and then the printer before releasing both resources whereas process q will request first the printer and then the tape drive. with this knowledge of the complete sequence of requests and releases for each process the system can decide for each request whether or not the process should wait in order to avoid a possible future deadlock. each request requires that in making this decision the system consider the resources currently available the resources currently allocated to each process and the future requests and releases of each process. the various algorithms that use this approach differ in the amount and type of information required. the simplest and most useful model requires that each process declare the maximum number of resources of each type that it may need. given this a priori information it is possible to construct an algorithm that ensures that the system will never enter a deadlocked state. such an algorithm defines the deadlock avoidance approach. a deadlock avoidance algorithm dynamically examines the resource allocation state to ensure that a circularwait condition can never exist. the resource allocation state is defined by the number of available and allocated resources and the maximum demands of the processes. in the following sections we explore two deadlock avoidance algorithms. . . safe state a state is safe if the system can allocate resources to each process up to its maximum in some order and still avoid a deadlock. more formally a system is in a safe state only if there exists a safe sequence. a sequence of processes p p? ... pn is a safe sequence for the current allocation state if for each pi the resource requests that p can still make can be satisfied by the currently available resources plus the resources held by all pi with . in this situation if the resources that pi needs are not immediately available then p can wait until all pj have finished. when they have finished p can obtain all of its needed resources complete its designated task return its allocated resources and terminate. when p terminates p l can obtain its needed resources and so on. if no such sequence exists then the system state is said to be unsafe. deadlock avoidance j deadlock. safe figure . safe unsafe and deadlock state spaces. a safe state is not a deadlocked state. conversely a deadlocked state is an unsafe state. not all unsafe states are deadlocks however figure . . an unsafe state may lead to a deadlock. as long as the state is safe the operating system can avoid unsafe and deadlocked states. in an unsafe state the operating system cannot prevent processes from requesting resources such that a deadlock occurs the behavior of the processes controls unsafe states. to illustrate we consider a system with magnetic tape drives and three processes pll p and p . process pq requires tape drives process pi may need as many as tape drives and process p? may need up to tape drives. suppose that at time to process pq is holding tape drives process p is holding tape drives and process p is holding tape drives. thus there are free tape drives. maximum needs current needs po pi p at time fo the system is in a safe state. the sequence pi po ? satisfies the safety condition. process pj can immediately be allocated all its tape drives and then return them the system will then have available tape drives then process pl can get all its tape drives and return them the system will then have available tape drives and finally process p can get all its tape drives and return them the system will then have all tape drives available . a system can go from a safe state to an unsafe state. suppose that at time t process pz requests and is allocated one more tape drive. the system is no longer in a safe state. at this point only process p can be allocated all its tape drives. when it returns them the system will have only available tape drives. since process pp is allocated tape drives but has a maximum of it may request more tape drives. since they are unavailable process po must wait. similarly process p? may request an additional tape drives and have to wait resulting in a deadlock. our mistake was in granting the request from process pi for one more tape drive. if we had made p wait until either of the other chapter deadlocks processes had finished and released its resources then we could have avoided the deadlock. given the concept of a safe state we can define avoidance algorithms that ensure that the system will never deadlock. the idea is simply to ensure that the system will always remain in a safe state. initially the system is in a safe state. whenever a process requests a resource that is currently available the system must decide whether the resource can be allocated immediately or whether the process must wait. the request is granted only if the allocation leaves the system in a safe state. in this scheme if a process requests a resource that is currently available it may still have to wait. thus resource utilization may be lower than it would otherwise be. . . resource allocation graph algorithm if we have a resource allocation system with only one instance of each resource type a variant of the resource allocation graph defined in section . . can be used for deadlock avoidance. in addition to the request and assignment edges already described we introduce a new type of edge called a claim edge. a claim edge p rj indicates that process p may request resource r at some time in the future. this edge resembles a request edge in direction but is represented in the graph by a dashed line. when process p. requests resource rj the claim edge p rj is converted to a request edge. similarly when a resource rj is released by pj the assignment edge rj p is reconverted to a claim edge p rj. we note that the resources must be claimed a priori in the system. that is before process p starts executing all its claim edges must already appear in the resource allocation graph. we can relax this condition by allowing a claim edge p r to be added to the graph only if all the edges associated with process p are claim edges. suppose that process p requests resource rj. the request can be granted only if converting the request edge p rj to an assignment edge rj p does not result in the formation of a cycle in the resource allocation graph. note that we check for safety by using a cycle detection algorithm. an algorithm for detecting a cycle in this graph requires an order of n operations where n is the number of processes in the system. if no cycle exists then the allocation of the resource will leave the system in a safe state. if a cycle is found then the allocation will put the system in figure . resource allocation graph for deadlock avoidance. . deadlock avoidance figure . an unsafe state in a resource allocation graph. an unsafe state. therefore process p will have to wait for its requests to be satisfied. to illustrate this algorithm we consider the resource allocation graph of figure . . suppose that pi requests r?. although ri is currently free we cannot allocate it to p since this action will create a cycle in the graph figure . . a cycle indicates that the system is in an unsafe state. if pi requests r and po requests r then a deadlock will occur. . . banker's algorithm the resource allocation graph algorithm is not applicable to a resourceallocation system with multiple instances of each resource type. the deadlockavoidance algorithm that we describe next is applicable to such a system but is less efficient than the resource allocation graph scheme. this algorithm is commonly known as the banker's algorithm. the name was chosen because the algorithm could be used in a banking system to ensure that the bank never allocated its available cash in such a way that it could no longer satisfy the needs of all its customers. when a new process enters the system it must declare the maximum number of instances of each resource type that it may need. this number may not exceed the total number of resources in the system. when a user requests a set of resources the system must determine whether the allocation of these resources will leave the system in a safe state. if it will the resources are allocated otherwise the process must wait until some other process releases enough resources. several data structures must be maintained to implement the banker's algorithm. these data structures encode the state of the resource allocation system. let n be the number of processes in the system and m be the number of resource types. we need the following data structures available. a vector of length m indicates the number of available resources of each type. if availab!c f equals k there are k instances of resource type ri available. max. an n x m matrix defines the maximum demand of each process. if m .t equals k then process p may request at most k instances of resource type ? . chapter deadlocks allocation. an n x in matrix defines the number of resources of each type currently allocated to each process. if allocation i j equals k then process pi is currently allocated k instances of resource type ? . need. an n x m matrix indicates the remaining resource need of each process. if need i j equals k then process p may need k more instances of resource type r to complete its task. note that need equals max i j allocntion i j . these data structures vary over time in both size and value. to simplify the presentation of the banker's algorithm we next establish some notation. let x and y be vectors of length n. we say that x y if and only if x i y for all ... n. for example if x and y then y x. y x if y x and y x. we can treat each row in the matrices allocation and need as vectors and refer to them as allocation and need . the vector allocation specifies the resources currently allocated to process p the vector needi specifies the additional resources that process p may still request to complete its task. . . . safety algorithm we can now present the algorithm for finding out whether or not a system is in a safe state. this algorithm can be described as follows . let work and finish be vectors of length in and n respectively. initialize work available and fiiush i false for ... n l. . find an such that both a. finish i false b. need work if no such exists go to step . . work work allocation finish i true go to step . . if finisli i true for all. then the system is in a safe state. this algorithm may require an order of m x it operations to determine whether a state is safe. . . . resource request algorithm we now describe the algorithm which determines if requests can be safely granted. let request be the request vector for process p . if request ' k then process p wants k instances of resource type r . when a request for resources is made by process p the following actions are taken . if request need go to step . otherwise raise an error condition since the process has exceeded its maximum claim. . deadlock avoidance . if request available go to step . otherwise ps must wait since the resources are not available. . have the system pretend to have allocated the requested resources to process p by modifying the state as follows available available request allocation allocation request need necdj request if the resulting resource allocation state is safe the transaction is completed and process p is allocated its resources. however if the new state is unsafe then p must wait for request and the old resource allocation state is restored. . . . an illustrative example finally to illustrate the use of the banker's algorithm consider a system with five processes pq through p and three resource types a b and c. resource type a has instances resource type b has instances and resource type c has instances. suppose that at time to the following snapshot of the system has been taken allocation max available abc abc abc po p pi pj pi the content of the matrix need is defined to be max allocation and is as follows need abc pi pi p p we claim that the system is currently in a safe state. indeed the sequence p p pa pi po satisfies the safety criteria. suppose now that process p requests one additional instance of resource type a and two instances of resource type c so request . to decide whether this request can be immediately granted we first check that request available that is that which is true. we then pretend that this request has been fulfilled and we arrive at the following new state chapter deadlocks allocation need av abc abc abc p ! pi p p pi we must determine whether this new system state is safe. to do so we execute our safety algorithm and find that the sequence p pj pi po pi satisfies the safety requirement. hence we can immediately grant the request of process p . you should be able to see however that when the system is in this state a request for by p cannot be granted since the resources are not available. furthermore a request for by po cannot be granted even though the resources are available since the resulting state is unsafe. we leave it as a programming exercise to implement the banker's algorithm