 the main memory must accommodate both the operating system and the various user processes. we therefore need to allocate the parts of the main memory in the most efficient way possible. this section explains one common method contiguous memory allocation. the memory is usually divided into two partitions one for the resident operating system and one for the user processes. we can place the operating system in either low memory or high memory. the major factor affecting this decision is the location of the interrupt vector. since the interrupt vector is often in low memory programmers usually place the operating system in low memory as well. thus in this text we discuss only the situation where . contiguous memory allocation the operating system resides in low memory. the development of the? other situation is similar. we usually want several user processes to reside in memory at the same time. we therefore need to consider how to allocate available memory to the processes that are in the input queue waiting to be brought into memory. in this contiguous memory allocation each process is contained in a single contiguous section of memory. . . memory mapping and protection before discussing memory allocation further we must discuss the issue of memory mapping and protection. we can provide these features by using a relocation register as discussed in section . . with a limit register as discussed in section . . . the relocation register contains the value of the smallest physical address the limit register contains the range of logical addresses for example relocation and limit . with relocation and limit registers each logical address must be less than the limit register the vimu maps the logical address dynamically by adding the value in the relocation register. this mapped address is sent to memory figure . . when the cpu scheduler selects a process for execution the dispatcher loads the relocation and limit registers with the correct values as part of the context switch. because every address generated by the cpu is checked against these registers we can protect both the operating system and the other users' programs and data from being modified by this running process. the relocation register scheme provides an effective way to allow the operating system size to change dynamically. this flexibility is desirable in many situations. for example the operating system contains code and buffer space for device drivers. if a device driver or other operating system service is not commonly used we do not want to keep the code and data in memory as we might be able to use that space for other purposes. such code is sometimes called transient operating system code it comes and goes as needed. thus using this code changes the size of the operating system during program execution. limit relocation register registelogical physical address yes y n address cpu no trap addressing error figure . hardware support for relocation and limit registers. chapter main memory . . memory ahocation now we are ready to turn to memory allocation. one of the simplest methods for allocating memory is to divide memory into several fixed sized partitions. each partition may contain exactly one process. thus the degree of multiprogramming is bound by the number of partitions. in this multiplepartition method when a partition is free a process is selected from the input queue and is loaded into the free partition. when the process terminates the partition becomes available for another process. this method was originally used by the ibm os operating system called mft it is no longer in use. the method described next is a generalization of the fixed partition scheme called mvt it is used primarily in batch environments. many of the ideas presented here are also applicable to a time sharing environment in which pure segmentation is used for memory management section . . in the fixed partition scheme the operating system keeps a table indicating which parts of memory are available and which are occupied. initially all memory is available for user processes and is considered one large block of available memory a hole. when a process arrives and needs memory we search for a hole large enough for this process. if we find one we allocate only as much memory as is needed keeping the rest available to satisfy future requests. as processes enter the system they are put into an input queue. the operating system takes into account the memory requirements of each process and the amount of available memory space in determining which processes are allocated memory. when a process is allocated space it is loaded into memory and it can then compete for the cpu. when a process terminates it releases its memory which the operating system may then fill with another process from the input queue. at any given time we have a list of available block sizes and the input queue. the operating system can order the input queue according to a scheduling algorithm. memory is allocated to processes until finally the memory requirements of the next process cannot be satisfied that is no available block of memory or hole is large enough to hold that process. the operating system can then wait until a large enough block is available or it can skip down the input queue to see whether the smaller memory requirements of some other process can be met. in general at any given time we have a set of holes of various sizes scattered throughout memory. when a process arrives and needs memory the system searches the set for a hole that is large enough for this process. if the hole is too large it is split into two parts. one part is allocated to the arriving process the other is returned to the set of holes. when a process terminates it releases its block of memory which is then placed back in the set of holes. if the new hole is adjacent to other holes these adjacent holes are merged to form one larger hole. at this point the system may need to check whether there are processes waiting for memory and whether this newly freed and recombined memory could satisfy the demands of any of these waiting processes. this procedure is a particular instance of the general dynamic storageallocation problem which concerns how to satisfy a request of size n from a list of free holes. there are many solutions to this problem. the first fit best fit and worst fit strategies are the ones most commonly used to select a free hole from the set of available holes. . contiguous memory allocation first fit. allocate the first hole that is big enough. searching can start either at the beginning of the set of holes or where the previous first fit search ended. we can stop searching as soon as we find a free hole that is large enough. best fit. allocate the smallest hole that is big enough. we must search the entire list unless the list is ordered by size. this strategy produces the smallest leftover hole. worst fit. allocate the largest hole. again we must search the entire list unless it is sorted by size. this strategy produces the largest leftover hole which may be more useful than the smaller leftover hole from a best fit approach. simulations have shown that both first fit and best fit are better than worst fit in terms of decreasing time and storage utilization. neither first fit nor best fit is clearly better than the other in terms of storage utilization but first fit is generally faster. . . fragmentation both the first fit and best fit strategies for memory allocation suffer from external fragmentation. as processes are loaded and removed from memory the free memory space is broken into little pieces. external fragmentation exists when there is enough total memory space to satisfy a request but the available spaces are not contiguous storage is fragmented into a large number of small holes. this fragmentation problem can be severe. in the worst case we could have a block of free or wasted memory between every two processes. if all these small pieces of memory were in one big free block instead we might be able to run several more processes. whether we are using the first fit or best fit strategy can affect the amount of fragmentation. first fit is better for some systems whereas best fit is better for others. another factor is which end of a free block is allocated. which is the leftover piece the one on the top or the one on the bottom? no matter which algorithm is used external fragmentation will be a problem. depending on the total amount of memory storage and the average process size external fragmentation may be a .minor or a major problem. statistical analysis of first fit for instance reveals that even with some optimization given n allocated blocks another . n blocks will be lost to fragmentation. that is one third of memory may be unusable! this property is known as the percent rule. memory fragmentation can be internal as well as external. consider a multiple partition allocation scheme with a hole of bytes. suppose that the next process requests bytes. if we allocate exactly the requested block we are left with a hole of bytes. the overhead to keep track of this hole will be substantially larger than the hole itself. the general approach to avoiding this problem is to break the physical memory into fixed sized blocks and allocate memory in units based on block size. with this approach the memory allocated to a process may be slightly larger than the requested memory. the difference between these two numbers is internal fragmentation memory that is internal to a partition but is not being used. chapter main memory one solution to the problem of external fragmentation is compaction. the goal is to shuffle the memory contents so as to place all free memory together in one large block. compaction is not always possible however. if relocation is static and is done at assembly or load time compaction cannot be done compaction is possible only if relocation is dynamic and is done at execution time. if addresses are relocated dynamically relocation requires only moving the program and data and then changing the base register to reflect the new base address. when compaction is possible we must determine its cost. the simplest compaction algorithm is to move all processes toward one end of memory all holes move in the other direction producing one large hole of available memory. this scheme can be expensive. another possible solution to the external fragmentation problem is to permit the logical address space of the processes to be noncontiguous thus allowing a process to be allocated physical memory wherever the latter is available. two complementary techniques achieve this solution paging section . and segmentation section . . these techniques can also be combined section . 