 on systems implementing the many to many model section . . the pthread scope process policy schedules user level threads onto available lvvps. the number of lwfs is maintained by the thread library perhaps using scheduler activations section . . . the pthread scope system scheduling policy will create and bind an lwp for each user level thread on many to many systems effectively mapping threads using the one to one policy section '. . . the pthread ipc provides the following two functions for getting and setting the contention scope policy pthread attr setscope pthread attr t attr int scope pthread attr getscope pthread attr t attr int scope the first parameter for both functions contains a pointer to the attri ite set for the thread. the second parameter for the pthread attr setscope function is passed either the pthread.scope..system or pthread cope process value indicating how the contention scope is to be set. in the case of pthread attr getscope this second parameter contains a pointer to an i n t value that is set to the current value of the contention scope. if an error occurs each of these functions returns non zero values. in figure . we illustrate a pthread program that first determines the existing contention scope and sets it to pthread.scope.process. it then creates five separate threads that will run using the scs scheduling policy. note that on some systems only certain contention scope values are allowed. for example linux and mac os x systems allow only pthread scope system. . operating system examples we turn next to a description of the scheduling policies of the solaris windows xp and linux operating systems. it is important to remember that we are describing the scheduling of kernel threads with solaris and linux. recall that linux does not distinguish between processes and threads thus we use the term task when discussing the linux scheduler. . . example solaris scheduling solaris uses priority based thread scheduling. it has defined four classes of scheduling which are in order of priority . real time . system . time sharing . interactive within each class there are different priorities and different scheduling algorithms. solaris scheduling is illustrated in figure . . chapter cpu scheduling include pthread.h ? tinclude stdio.h define num.threads int main int argc char argv int i scope pthread t tid numjthreads pthread attr t attr get the default attributes pthread attr init attr first inquire on the current scope if pthread attr getscope fcattr kscope ! fprintf stderr unable to get scheduling scope n else if scope pthread.scope.process printf pthread scope process else if scope pthread.scope.system printf pthread scope system else fprintf stderr illegal scope value. n set the scheduling algorithm to pcs or scs pthread attr setscope attr pthread scope.system create the threads for i i num threads i pthread create tid i attr runner null now join on each thread for i i numjthreads i pthread join tid i null each thread will begin control in this function void runner void param do some work ... dthread exit fo figure . pthread scheduling api. . operating system examples classglobal scheduling specific scheduler run priority order priorities classes queue highest first real time kernel threads of real time lwps system kernel q service threads o interactive kernel time sharing q threads of interactive time sharing lwps o lowest last figure . solaris scheduling. the default scheduling class for a process is time sharing. the scheduling policy for time sharing dynamically alters priorities and assigns time slices of different lengths using a multilevel feedback queue. by default there is an inverse relationship between priorities and time slices the higher the priority the smaller the time slice and the lower the priority the larger the time slice. interactive processes typically have a higher priority cpu bound processes a lower priority. this scheduling policy gives good response time for interactive processes and good throughput for cpu bound processes. the interactive class uses the same scheduling policy as the time sharing class but it gives windowing applications a higher priority for better performance. figure . shows the dispatch table for scheduling interactive and timesharing threads. these two scheduling classes include priority levels but for brevity we display only a handful. the dispatch table shown in figure . contains the following fields priority. the class dependent priority for the time sharing and interactive classes. a higher number indicates a higher priority. time quantum. the time quantum for the associated priority. this illustrates the inverse relationship between priorities and time quanta chapter cpu scheduling . . v i . . w i . iiilkllmil ill i te. i!k . ..... . . . .. .. f i j . . . .. ? . . . .. r. r. .. . r. vt . .. . . .. .. .. . . .. igii . . . .!. . . . ii . .. . . .. . . . . .. i! . .. . . .. .. . o. . o. .o ... .. f. . . . . .. .. .. .. . ...... ... . . . ...... ...... isiisi ! ijiilil. .t ifei ii iii i llliii.ii l illfil'lil li i.imi t!i iisiiri . . f m i. im!i i if m il !. ii! iw l iij m i liiiiirii ! ii i if i l l ii lllpli l i. hi !i ii! m ih ! liillli.l !! n h s i k . l i ! l l i ! v j . q i i ! in lo i .! i iiitm ii ... .l . . v . .. jj . f . . k. . i. . r. .. .... .m ..i ' ' '!' ' ' !' olq ' ' ' ' ' ' !' . i . . i. rtiri . i figure . solaris dispatch table for interactive and time sharing threads. the lowest priority priority has the highest time quantum milliseconds and the highest priority priority has the lowest time quantum milliseconds . time quantum expired. the new priority of a thread that has used its entire time quantum without blocking. such threads are considered cpu intensive. as shown in the table these threads have their priorities lowered. return from sleep. the priority of a thread that is returning from sleeping such as waiting for i o . as the table illustrates when i o is available for a waiting thread its priority is boosted to between and thus supporting the scheduling policy of providing good response time for interactive processes. solaris introduced two new scheduling classes fixed priority and fair share. threads in the fixed priority class have the same priority range as those in the time sharing class however their priorities are not dynamically adjusted. the fair share scheduling class uses cpu shares instead of priorities to make scheduling decisions. cpu shares indicate entitlement to available cpu resources and are allocated to a set of processes known as a project . solaris uses the system class to run kernel processes such as the scheduler and paging daemon. once established the priority of a system process does not change. the system class is reserved for kernel use user processes running in kernel mode are not in the systems class . . operating system examples threads in the real time class are given the highest priority. this assignment allows a real time process to have a guaranteed response from the system within a bounded period of time. a real time process will run before a process in any other class. in general however few processes belong to the real time class. each scheduling class includes a set of priorities. however the scheduler converts the class specific priorities into global priorities and selects the thread with the highest global priority to run. the selected thread runs on the cpu until it blocks uses its time slice or is preempted by a higher priority thread. if there are multiple threads with the same priority the scheduler uses a round robin queue. as mentioned solaris has traditionally used the manyto many model . . but with solaris switched to the one to one model . . . . . example windows xp scheduling windows xp schedules threads using a priority based preemptive scheduling algorithm. the windows xp scheduler ensures that the highest priority thread will always run. the portion of the windows xp kernel that handles scheduling is called the dispatcher. a thread selected to run by the dispatcher will run until it is preempted by a higher priority thread until it terminates until its time quantum ends or until it calls a blocking system call such as for i o. if a higher priority real time thread becomes ready while a lower priority thread is running the lower priority thread will be preempted. this preemption gives a real time thread preferential access to the cpu when the thread needs such access. the dispatcher uses a level priority scheme to determine the order of thread execution. priorities are divided into two classes. the variable class contains threads having priorities from to and the real time class contains threads with priorities ranging from to . there is also a thread running at priority that is used for memory management. the dispatcher uses a queue for each scheduling priority and traverses the set of queues from highest to lowest until it finds a thread that is ready to run. if no ready thread is found the dispatcher will execute a special thread called the idle thread. there is a relationship between the numeric priorities of the windows xp kernel and the win api. the win api identifies several priority classes to which a process can belong. these include realtime priority class high priority class above normal.priority class normal priority class below.normal priority class idle priority class priorities in all classes except the realtime priority class are variable meaning that the priority of a thread belonging to one of these classes can change. chapter cpu scheduling . . ?. i . . iii i i isi i iii iiils iii iii iii ii ii..iiii z isi iii iiii iii i ii ' . . . . . . . . f i timlli . iii ii iiiiii .iii r iii iiisi iii fcw. . . . i ' ' i ' f fif!j f'ff iiiii iiiii hotft m ii .' ''.i s .ii! iii..ii iii iii iii i iifj i i ilj iii ii iisiii.iiiiii iii iii iii iii iiiiii iii ii ii iii . iiifijiij mi!' i iii ii iii.iii iiijj iiii iii iii iiisjiiiii niuiisii ii iii i t i iii .. ..i i.. f i . . il i y ' . . . ' ' . ' . ' . ' . ' ' . ' ' . ' . ' .'' ' ' ' ' iii i iiiii' iii i ! i iii idle i i i t ' ii . iiti ii figure . windows xp priorities. within each of the priority classes is a relative priority. the values for relative priority include timejzritical highest above normal normal below normal lowest idle the priority of each thread is based on the priority class it belongs to and its relative priority within that class. this relationship is shown in figure . . the values of the priority classes appear in the top row. the left column contains the values for the relative priorities. for example if the relative priority of a thread in the above.normal priority class is normal the numeric priority of that thread is . furthermore each thread has a base priority representing a value in the priority range for the class the thread belongs to. by default the base priority is the value of the normal relative priority for that specific class. the base priorities for each priority class are realtime priortty class high priority class above norm al.priorjty class normal priority.class below.normal priority class idle priority class . operating system examples processes are typically members of the normal.priority class. a process will belong to this class unless the parent of the process was of the idle priority class or unless another class was specified when the process was created. the initial priority of a thread is typically the base priority of the process the thread belongs to. when a thread's time quantum runs out that thread is interrupted if the thread is in the variable priority class its priority is lowered. the priority is never lowered below the base priority however. lowering the thread's priority tends to limit the cpu consumption of compute bound threads. when a variable priority thread is released from a wait operation the dispatcher boosts the priority. the amount of the boost depends on what the thread was waiting for for example a thread that was waiting for keyboard i o would get a large increase whereas a thread waiting for a disk operation would get a moderate one. this strategy tends to give good response times to interactive threads that are using the mouse and windows. it also enables i o bound threads to keep the i o devices busy while permitting compute bound threads to use spare cpu cycles in the background. this strategy is used by several time sharing operating systems including unix. in addition the window with which the user is currently interacting receives a priority boost to enhance its response time. when a user is running an interactive program the system needs to provide especially good performance for that process. for this reason windows xp has a special scheduling rule for processes in the normal pr ority class. windows xp distinguishes between the foreground process that is currently selected on the screen and the background processes that are not currently selected. when a process moves into the foreground windows xp increases the scheduling quantum by some factor typically by . this increase gives the foreground process three times longer to run before a time sharing preemption occurs. . . example linux scheduling prior to version . the linux kernel ran a variation of the traditional unix scheduling algorithm. two problems with the traditional unix scheduler are that it does not provide adequate support for smp systems and that it does not scale well as the number of tasks on the system grows. with version . the scheduler was overhauled and the kernel now provides a scheduling algorithm that runs in constant time known as o l regardless of the number of tasks on the system. the new scheduler also provides increased support for smp including processor affinity and load balancing as well as providing fairness and support for interactive tasks. the linux scheduler is a preemptive priority based algorithm with two separate priority ranges a real time range from to and a nice value ranging from to . these two ranges map into a global priority scheme whereby numerically lower values indicate higher priorities. unlike schedulers for many other systems including solaris . . and windows xp . . linux assigns higher priority tasks longer time quanta and lower priority tasks shorter time quanta. the relationship between priorities and time slice length is shown in figure . . chapter cpu scheduling numeric relative time priority priority quantum highest ms real time tasks other ft tasks lowest ms figure . the relationship between priorities and time slice length. a runnable task is considered eligible for execution on the cpu as long as it has time remaining in its time slice. when a task has exhausted its time slice it is considered expired and is not eligible for execution again until all other tasks have also exhausted their time quanta. the kernel maintains a list of all runnable tasks in a runqueue data structure. because of its support for smp each processor maintains its own runqueue and schedules itself independently. each runqueue contains two priority arrays active and expired. the active array contains all tasks with time remaining in their time slices and the expired array contains all expired tasks. each of these priority arrays contains a list of tasks indexed according to priority figure . . the scheduler chooses the task with the highest priority from the active array for execution on the cpu. on multiprocessor machines this means that each processor is scheduling the highest priority task from its own runqueue structure. when all tasks have exhausted their time slices that is the active array is empty the two priority arrays are exchanged the expired array becomes the active array and vice versa. linux implements real time scheduling as defined by posix.lb which is fully described in section . . . real time tasks are assigned static priorities. all other tasks have dynamic priorities that are based on their nice values plus or minus the value . the interactivity of a task determines whether the value will be added to or subtracted from the nice value. a task's interactivity is determined by how long it has been sleeping while waiting for i o. tasks active expired array array priority task lists priority task lists o o o figure . list of tasks indexed according to priority