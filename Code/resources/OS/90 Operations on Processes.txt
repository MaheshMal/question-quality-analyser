 the processes in most systems can execute concurrently and they may be created and deleted dynamically. thus these systems must provide a mechanism for process creation and termination. in this section we explore the mechanisms involved in creating processes and illustrate process creation on unix and windows systems. . . process creation a process may create several new processes via a create process system call during the course of execution. the creating process is called a parent process and the new processes are called the children of that process. each of these new processes may in turn create other processes forming a tree of processes. most operating systems including unix and the windows family of operating systems identify processes according to a unique process identifier or pid which is typically an integer number. figure . illustrates a typical process tree for the solaris operating system showing the name of each process and its pid. in solaris the process at the top of the tree is the sched process with pid of . the sched process creates several children processes including pageout and f sf lush. these processes are responsible for managing memory and file systems. the sched process also creates the i n i t process which serves as the root parent process for all user processes. in figure . we see two children of init inetd and dtlogin. inetd is responsible for networking services such as t e l n e t and ftp d t l o g i n is the process representing a user login screen. when a user logs in dtlogin creates an x windows session xsession which in turns creates the sdt shel process. below sdt shel a . operations on processes user's command line shell the c shell or csh is created. it is this commandline interface where the user then invokes various child processes such as the i s and cat commands. we also see a csh process with pid of representing a user who has logged onto the system using t e l n e t . this user has started the netscape browser pid of and the emacs editor pid of . on unix a listing of processes can be obtained using the ps command. for example entering the command ps e l will list complete information for all processes currently active in the system. it is easy to construct a process tree similar to what is shown in figure . by recursively tracing parent processes all the way to the i n i t process. in general a process will need certain resources cpu time memory files i o devices to accomplish its task. when a process creates a subprocess that subprocess may be able to obtain its resources directly from the operatiiig system or it may be constrained to a subset of the resources of the parent process. the parent may have to partition its resources among its children or it may be able to share some resources such as memory or files among several of its children. restricting a child process to a subset of the parent's resources prevents any process from overloading the system by creating too many subprocesses. in addition to the various physical and logical resources that a process obtains when it is created initialization data input may be passed along by the parent process to the child process. for example consider a process whose function is to display the contents of a file say img.jpg on the screen of a figure . a tree of processes on a typical solaris system. chapter processes terminal. when it is created it will get as an input from its parent process the name of the file img.jpg and it will use that file name open the file and write the contents out. it may also get the name of the output device. some operating systems pass resources to child processes. on such a system the new process may get two open files img.jpg and the terminal device and may simply transfer the datum between the two. when a process creates a new process two possibilities exist in terms of execution . the parent continues to execute concurrently with its children. . the parent waits until some or all of its children have terminated. there are also two possibilities in terms of the address space of the new process . the child process is a duplicate of the parent process it has the same program and data as the parent . . the child process has a new program loaded into it. to illustrate these differences let's first consider the unix operating system. in unix as we've seen each process is identified by its process identifier include sys types.h include stdio.h include unistd.h int main pid t pid fork a child process pid fork if pid error occurred fprintf stderr fork failed exit else if pid child process execlpf bin is is null else parent process parent will wait for the child to complete wait null printf child complete exit figure . c program forking a separate process. . operations on processes which is a unique integer. a new process is created by the forko system call. the new process consists of a copy of the address space of the original process. this mechanism allows the parent process to communicate easily with its child process. both processes the parent and the child continue execution at the instruction after the f o r k with one difference the return code for the forko is zero for the new child process whereas the nonzero process identifier of the child is returned to the parent. typically the execo system call is used after a forko system call by one of the two processes to replace the process's memory space with a new program. the exec system call loads a binary file into memory destroying the memory image of the program containing the execo system call and starts its execution. in this manner the two processes are able to communicate and then go their separate ways. the parent can then create more children or if it has nothing else to do while the child runs it can issue a wait system call to move itself off the ready queue until the termination of the child. the c program shown in figure . illustrates the unix system calls previously described. we now have two different processes running a copy of the same program. the value of pid for the child process is zero that for the parent is an integer value greater than zero. the child process overlays its address space with the unix command b i n i s used to get a directory listing using the execlpo system call execlpo is a version of the execo system call . the parent waits for the child process to complete with the wait system call. when the child process completes by either implicitly or explicitly invoking e x i t the parent process resumes from the call to wait where it completes using the e x i t system call. this is also illustrated in figure . . as an alternative example we next consider process creation in windows. processes are created in the win api using the createprocesso function which is similar to f ork in that a parent creates a new child process. however whereas f ork has the child process inheriting the address space of its parent createprocess requires loading a specified program into the address space of the child process at process creation. furthermore whereas f ork is passed no parameters createprocess expects no fewer than ten parameters. the c program shown in figure . illustrates the createprocesso function which creates a child process that loads the application mspaint. exe. we opt for many of the default values of the ten parameters passed to createprocesso. readers interested in pursuing the details on process creation and management in the win api are encouraged to consult the bibliographical notes at the end of this chapter. figure . process creation. chapter processes include stdio.h i include windows.h int main void startupinfo si process information pi allocate memory zeromemory si sizeof si si.cb sizeof si zeromemory pi sizeof pi create child process if !createprocess null use command line c windows system mspaint.exe command line null don't inherit process handle null don't inherit thread handle false disable handle inheritance no creation flags null use parent's environment block null use parent's existing directory si fprintf stderr create process failed return parent will wait for the child to complete waitforsingleobject pi.hprocess infinite printf child complete close handles closehandle pi.hprocess closehandle pi.hthread figure . creating a separate process using the win api. two parameters passed to createprocess are instances of the startupinfo and processjnformation structures. startupinfo specifies many properties of the new process such as window size and appearance and handles to standard input and output files. the processjnformation structure contains a handle and the identifiers to the newly created process and its thread. we invoke the zeromemoryo function to allocate memory for each of these structures before proceeding with createprocess . the first two parameters passed to createprocess are the application name and command line parameters. if the application name is null which in this case it is the command line parameter specifies the application to load. in this instance we are loading the microsoft windows mspaint.exe . operations on processes application. beyond these two initial parameters we use the default parameters for inheriting process and thread handles as well as specifying no creation flags. we also use the parent's existing environment block and starting directory. last we provide two pointers to the startupinfo and process information structures created at the beginning of the program. in figure . the parent process waits for the child to complete by invoking the w a i t o system call. the equivalent of this in win is waitforsingleobj ect which is passed a handle of the child process pi . hprocess that it is waiting for to complete. once the child process exits control returns from the waitforsingleob j ect function in the parent process. . . process termination a process terminates when it finishes executing its final statement and asks the operating system to delete it by using the e x i t system call. at that point the process may return a status value typically an integer to its parent process via the wait system call . all the resources of the process including physical and virtual memory open files and i o buffers are deallocated by the operating system. termination can occur in other circumstances as well. a process can cause the termination of another process via an appropriate system call for example terminateprocesso in win . usually such a system call can be invoked only by the parent of the process that is to be terminated. otherwise users could arbitrarily kill each other's jobs. note that a parent needs to know the identities of its children. thus when one process creates a new process the identity of the newly created process is passed to the parent. a parent may terminate the execution of one of its children for a variety of reasons such as these the child has exceeded its usage of some of the resources that it has been allocated. to determine whether this has occurred the parent must have a mechanism to inspect the state of its children. the task assigned to the child is no longer required. the parent is exiting and the operating system does not allow a child to continue if its parent terminates. some systems including vms do not allow a child to exist if its parent has terminated. in such systems if a process terminates either normally or abnormally then all its children must also be terminated. this phenomenon referred to as cascading termination is normally initiated by the operating system. to illustrate process execution and termination consider that in unix we can terminate a process by using the exitq system call its parent process may wait for the termination of a child process by using the waito system call. the wait system call returns the process identifier of a terminated child so that the parent can tell which of its possibly many children has terminated. if the parent terminates however all its children have assigned as their new parent the i n i t process. thus the children still have a parent to collect their status and execution statistics. chapter processes