 the memory management algorithms outlined in chapter are necessary because of one basic requirement the instructions being executed must be in physical memory. the first approach to meeting this requirement is to place the entire logical address space in physical memory. dynamic loading can help to ease this restriction but it generally requires special precautions and extra work by the programmer. chapter virtual memory the requirement that instructions must be in physical memory te be executed seems both necessary and reasonable but it is also unfortunate since it limits the size of a program to the size of physical memory. in fact an examination of real programs shows us that in many cases the entire program is not needed. for instance consider the following programs often have code to handle unusual error conditions. since these errors seldom if ever occur in practice this code is almost never executed. arrays lists and tables are often allocated more memory than they actually need. an array may be declared bv elements even though it is seldom larger than by elements. an assembler symbol table may have room for symbols although the average program has less than symbols. certain options and features of a program may be used rarely. for instance the routines on u.s. government computers that balance the budget are only rarely used. even in those cases where the entire program is needed it may not all be needed at the same time. the ability to execute a program that is only partially in memory would confer many benefits a program would no longer be constrained by the amount of physical memory that is available. users would be able to write programs for an extremely large virtual address space simplifying the programming task. page page page . memory a map page v physica virtual memory memory figure . diagram showing virtual memory that is larger than physical memory. . background because each user program could take less physical memory ?inore programs could be run at the same time with a corresponding increase in cpu utilization and throughput but with no increase in response time or turnaround time. less i o would be needed to load or swap each user program into memory so each user program would run faster. thus running a program that is not entirely in memory would benefit both the system and the user. virtual memory involves the separation of logical memory as perceived by users from physical memory. this separation allows an extremely large virtual memory to be provided for programmers when only a smaller physical memory is available figure . . virtual memory makes the task of programming much easier because the programmer no longer needs to worry about the amount of physical memory available she can concentrate instead on the problem to be programmed. the virtual address space of a process refers to the logical or virtual view of how a process is stored in memory. typically this view is that a process begins at a certain logical address say address and exists in contiguous memory as shown in figure . . recall from chapter though that in fact physical memory may be organized in page frames arid that the physical page frames assigned to a process may not be contiguous. tt is up to the memorymanagement unit mmu to map logical pages to physical page frames in memory. note in figure . that we allow for the heap to grow upward hi memory as it is used for dynamic memory allocation. similarly we allow for the stack to grow downward in memory through successive function calls. the large blank space or hole between the heap and the stack is part of the virtual address max heap figure . virtual address space. chapter virtual memory space but will require actual physical pages only if the heap or stack grcfvvs. virtual address spaces that include holes are known as sparse address spaces. using a sparse address space is beneficial because the holes can be filled as the stack or heap segments grow or if we wish to dynamically link libraries or possibly other shared objects during program execution. in addition to separating logical memory from physical memory virtual memory also allows files and memory to be shared by two or more processes through page sharing section . . . this leads to the following benefits system libraries can be shared by several processes through mapping of the shared object into a virtual address space. although each process considers the shared libraries to be part of its virtual address space the actual pages where the libraries reside in physical memory are shared by all the processes figure . . typically a library is mapped read only into the space of each process that is linked with it. similarly virtual memory enables processes to share memory. recall from chapter that two or more processes can communicate through the use of shared memory. virtual memory allows one process to create a region of memory that it can share with another process. processes sharing this region consider it part of their virtual address space yet the actual physical pages of memory are shared much as is illustrated in figure . . virtual memory can allow pages to be shared during process creation with the forko system call thus speeding up process creation. we will further explore these and other benefits of virtual memory later in this chapter. first we begin with a discussion of implementing virtual memorythrough demand paging. stack '. stack shared hbrary shared shared library pages heap data code code figure . shared library using virtual memory