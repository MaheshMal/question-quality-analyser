 memory and executing is called a process. when a process executes it typically executes for only a short time before it either finishes or needs to perform i o. i o may be interactive that is output goes to a display for the user and input comes from a user keyboard mouse or other device. since interactive i o typically runs at people speeds it may take a long time to complete. input for example may be bounded by the user's typing speed seven characters per second is fast for people but incredibly slow for computers. rather than let the cpu sit idle as this interactive input takes place the operating system will rapidly switch the cpu to the program of some other user. time sharing and multiprogramming require several jobs to be kept simultaneously in memory. since in general main memory is too small to accommodate all jobs the jobs are kept initially on the disk in the job pool. this pool consists of all processes residing on disk awaiting allocation of main memory. if several jobs are ready to be brought into memory and if there is not enough room for all of them then the system must choose among them. making this decision is job scheduling which is discussed in chapter . when the operating system selects a job from the job pool it loads that job into memory for execution. having several programs in memory at the same time requires some form of memory management which is covered in chapters and . in addition if several jobs are ready to run at the same time the system must choose among them. making this decision is cpu scheduling which is discussed in chapter . finally running multiple jobs concurrently requires that their ability to affect one another be limited in all phases of the operating system including process scheduling disk storage and memory management. these considerations are discussed throughout the text. in a time sharing system the operating system must ensure reasonable response time which is sometimes accomplished through swapping where processes are swapped in and out of main memory to the disk. a more common method for achieving this goal is virtual memory a technique that allows the execution of a process that is not completely in memory chapter . the main advantage of the virtual memory scheme is that it enables users to run programs that are larger than actual physical memory. further it abstracts main memory into a large uniform array of storage separating logical memory as viewed by the user from physical memory. this arrangement frees programmers from concern over memory storage limitations. time sharing systems must also provide a file system chapters and . the file system resides on a collection of disks hence disk management must be provided chapter . also time sharing systems provide a mechanism for protecting resources from inappropriate use chapter . to ensure orderly execution the system must provide mechanisms for job synchronization and communication chapter and it may ensure that jobs do not get stuck in a deadlock forever waiting for one another chapter . . operating system operations as mentioned earlier modern operating systems are interrupt driven. if there are no processes to execute no i o devices to service and no users to whom to respond an operating system will sit quietly waiting for something to happen. events are almost always signaled by the occurrence of an interrupt chapter introduction or a trap. a trap or an exception is a software generated interrupt caused either by an error for example division by zero or invalid memory access or by a specific request from a user program that an operating system service be performed. the interrupt driven nature of an operating system defines that system's general structure. for each type of interrupt separate segments of code in the operating system determine what action should be taken. an interrupt service routine is provided that is responsible for dealing with the interrupt. since the operating system and the users share the hardware and software resources of the computer system we need to make sure that an error in a user program could cause problems only for the one program that was running. with sharing many processes could be adversely affected by a bug in one program. for example if a process gets stuck in an infinite loop this loop could prevent the correct operation of many other processes. more subtle errors can occur in a multiprogramming system where one erroneous program might modify another program the data of another program or even the operating system itself. without protection against these sorts of errors either the computer must execute only one process at a time or all output must be suspect. a properly designed operating system must ensure that an incorrect or malicious program cannot cause other programs to execute incorrectly. . . dual mode operation in order to ensure the proper execution of the operating system we must be able to distinguish between the execution of operating system code and userdefined code. the approach taken by most computer systems is to provide hardware support that allows us to differentiate among various modes of execution. at the very least we need two separate modes of operation user mode and kernel mode also called supervisor mode system mode or privileged mode . a bit called the mode bit is added to the hardware of the computer to indicate the current mode kernel or user . with the mode bit we are able to distinguish between a task that is executed on behalf of the operating system and one that is executed on behalf of the user. when the computer system is executing on behalf of a user application the system is in user mode. however when a user application requests a service from the operating system via a system call it must transition from user to kernel mode to fulfill the request. this is shown in figure . . as we shall see this architectural enhancement is useful for many other aspects of system operation as well. at system boot time the hardware starts in kernel mode. the operating system is then loaded and starts user applications in user mode. whenever a trap or interrupt occurs the hardware switches from user mode to kernel mode that is changes the state of the mode bit to . thus whenever the operating system gains control of the computer it is in kernel mode. the system always switches to user mode by setting the mode bit to before passing control to a user program. the dual mode of operation provides us with the means for protecting the operating system from errant users and errant users from one another. we accomplish this protection by designating some of the machine instructions that . operating system operations user mode user process executing calls system call return from system call mode bit kemel mode bit mode bit kernel mode execute system call i mode bit figure . transition from user to kernel mode. may cause harm as privileged instructions. the hardware allows privileged instructions to be executed only in kernel mode. if an attempt is made to execute a privileged instruction in user mode the hardware does not execute the instruction but rather treats it as illegal and traps it to the operating system. the instruction to switch to user mode is an example of a privileged instruction. some other examples include i o control timer management and interrupt management. as we shall see throughout the text there are many additional privileged instructions. we can now see the life cycle of instruction execution in a computer system. initial control is within the operating system where instructions are executed in kernel mode. when control is given to a user application the mode is set to user mode. eventually control is switched back to the operating system via an interrupt a trap or a system call. system calls provide the means for a user program to ask the operating system to perform tasks reserved for the operating system on the user program's behalf. a system call is invoked in a variety of ways depending on the functionality provided by the underlying processor. in all forms it is the method used by a process to request action by the operating system. a system call usually takes the form of a trap to a specific location in the interrupt vector. this trap can be executed by a generic t r a p instruction although some systems such as the mips r family have a specific s y s c a l l instruction. when a system call is executed it is treated by the hardware as a software interrupt. control passes through the interrupt vector to a service routine in the operating system and the mode bit is set to kernel mode. the systemcall service routine is a part of the operating system. the kernel examines the interrupting instruction to determine what system call has occurred a parameter indicates what type of service the user program is requesting. additional information needed for the request may be passed in registers on the stack or in memory with pointers to the memory locations passed in registers . the kernel verifies that the parameters are correct and legal executes the request and returns control to the instruction following the system call. we describe system calls more fully in section . . the lack of a hardware supported dual mode can cause serious shortcomings in an operating system. for instance ms dos was written for the intel architecture which has no mode bit and therefore no dual mode. a user program running awry can wipe out the operating system by writing over it with data and multiple programs are able to write to a device at the same time chapter introduction with possibly disastrous results. recent versions of the intel cpu such is the pentium do provide dual mode operation. accordingly most contemporary operating systems such as microsoft windows and windows xp and linux and solaris for x systems take advantage of this feature and provide greater protection for the operating system. once hardware protection is in place errors violating modes are detected by the hardware. these errors are normally handled by the operating system. if a user program fails in some way such as by making an attempt either to execute an illegal instruction or to access memory that is not in the user's address space then the hardware will trap to the operating system. the trap transfers control through the interrupt vector to the operating system just as an interrupt does. when a program error occurs the operating system must terminate the program abnormally. this situation is handled by the same code as is a user requested abnormal termination. an appropriate error message is given and the memory of the program may be dumped. the memory dump is usually written to a file so that the user or programmer can examine it and perhaps correct it and restart the program. . . timer we must ensure that the operating system maintains control over the cpu. we must prevent a user program from getting stuck in an infinite loop or not calling system services and never returning control to the operating system. to accomplish this goal we can use a timer. a timer can be set to interrupt the computer after a specified period. the period may be fixed for example second or variable for example from millisecond to second . a variable timer is generally implemented by a fixed rate clock and a counter. the operating system sets the counter. every time the clock ticks the counter is decremented. when the counter reaches an interrupt occurs. for instance a bit counter with a millisecond clock allows interrupts at intervals from millisecond to milliseconds in steps of millisecond. before turning over control to the user the operating system ensures that the timer is set to interrupt. if the timer interrupts control transfers automatically to the operating system which may treat the interrupt as a fatal error or may give the program more time. clearly instructions that modify the content of the timer are privileged. thus we can use the timer to prevent a user program from running too long. a simple technique is to initialize a counter with the amount of time that a program is allowed to run. a program with a minute time limit for example would have its counter initialized to . every second the timer interrupts and the counter is decremented by . as long as the counter is positive control is returned to the user program. when the counter becomes negative the operating system terminates the program for exceeding the assigned time limit