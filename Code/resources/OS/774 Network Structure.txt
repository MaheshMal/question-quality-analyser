 networking is a key area of functionality for linux. not only does linux support the standard internet protocols used for most unix to unix communications but it also implements a number of protocols native to other non unix operating systems. in particular since linux was originally implemented primarily on pcs rather than on large workstations or on server class systems it supports many of the protocols typically used on pc networks such as appletalk and ipx. . network structure internally networking in the linux kernel is implemented by three layers of software . the socket interface . protocol drivers . network device drivers user applications perform all networking requests through the socket interface. this interface is designed to look like the . bsd socket layer so that any programs designed to make use of berkeley sockets will run on linux without any source code changes. this interface is described in section a. . . the bsd socket interface is sufficiently general to represent network addresses for a wide range of networking protocols. this single interface is used in linux to access not just those protocols implemented on standard bsd systems but all the protocols supported by the system. the next layer of software is the protocol stack which is similar in organization to bsd's own framework. whenever any networking data arrive at this layer either from an application's socket or from a network device driver the data are expected to have been tagged with an identifier specifying which network protocol they contain. protocols can communicate with one another if they desire for example within the internet protocol set separate protocols manage routing error reporting and reliable retransmission of lost data. the protocol layer may rewrite packets create new packets split or reassemble packets into fragments or simply discard incoming data. ultimately once it has finished processing a set of packets it passes them on up to the socket interface if the data are destined for a local connection or downward to a device driver if the packet needs to be transmitted remotely. the protocol layer decides to which socket or device to send the packet. all communication between the layers of the networking stack is performed by passing single skbuff structures. an skbuff contains a set of pointers into a single continuous area of memory representing a buffer inside which network packets can be constructed. the valid data in an skbuff do not need to start at the beginning of the skbuf f's buffer and they do not need to run to the end. the networking code can add data to or trim data from either end of the packet as long as the result still fits into the skbuff. this capacity is especially important on modern microprocessors where improvements in cpu speed have far outstripped the performance of main memory. the skbuff architecture allows flexibility in manipulating packet headers and checksums while avoiding any unnecessary data copying. the most important set of protocols in the linux networking system is the tcp ip protocol suite. this suite comprises a number of separate protocols. the ip protocol implements routing between different hosts anywhere on the network. on top of the routing protocol are built the udp tcp and icmp protocols. the udp protocol carries arbitrary individual datagrams between hosts. the tcp protocol implements reliable connections between hosts with guaranteed in order delivery of packets and automatic retransmission of lost data. the icmp protocol is used to carry various error and status messages between hosts. chapter the linux system packets skbuf fs arriving at the networking stack's protocol software are expected to be already tagged with an internal identifier indicating to which protocol the packet is relevant. different networking device drivers encode the protocol type in different ways over their communications media thus the protocol for incoming data must be identified in the device driver. the device driver uses a hash table of known networking protocol identifiers to look up the appropriate protocol and passes the packet to that protocol. new protocols can be added to the hash table as kernel loadable modules. incoming ip packets are delivered to the ip driver. the job of this layer is to perform routing. after deciding where the packet is destined it forwards the packet to the appropriate internal protocol driver to be delivered locally or injects it back into a selected network device driver queue to be forwarded to another host. it performs the routing decision using two tables the persistent forwarding information base fib and a cache of recent routing decisions. the fib holds routing configuration information and can specify routes based either on a specific destination address or on a wildcard representing multiple destinations. the fib is organized as a set of hash tables indexed by destination address the tables representing the most specific routes are always searched first. successful lookups from this table are added to the route caching table which caches routes only by specific destination no wildcards are stored in the cache so lookups can be made quickly. an entry in the route cache expires after a fixed period with no hits. at various stages the ip software passes packets to a separate section of code for firewall management selective filtering of packets according to arbitrary criteria usually for security purposes. the firewall manager maintains a number of separate firewall chains and allows an skbuf f to be matched against any chain. chains are reserved for separate purposes one is used for forwarded packets one for packets being input to this host and one for data generated at this host. each chain is held as an ordered list of rules where a rule specifies one of a number of possible firewall decision functions plus some arbitrary data to match against. two other functions performed by the ip driver are disassembly and reassembly of large packets. if an outgoing packet is too large to be queued to a device it is simply split up into smaller fragments which are all queued to the driver. at the receiving host these fragments must be reassembled. the ip driver maintains an ipf rag object for each fragment awaiting reassembly and an ipq for each datagram being assembled. incoming fragments are matched against each known ipq. if a match is found the fragment is added to it otherwise a new ipq is created. once the final fragment has arrived for a ipq a completely new skbuf f is constructed to hold the new packet and this packet is passed back into the ip driver. packets identified by the ip as destined for this host are passed on to one of the other protocol drivers. the udp and tcp protocols share a means of associating packets with source and destination sockets each connected pair of sockets is uniquely identified by its source and destination addresses and by the source and destination port numbers. the socket lists are linked onto hash tables keyed on these four address port values for socket lookup on incoming packets. the tcp protocol has to deal with unreliable connections so it maintains ordered lists of unacknowledged outgoing packets to retransmit