 in a dynamic protection system we may sometimes need to revoke access rights to objects shared by different users. various questions about revocation may arise immediate versus delayed. does revocation occur immediately or is it delayed? if revocation is delayed can we find out when it will take place? selective versus general. when an access right to an object is revoked does it affect all the users who have an access right to that object or can we specify a select group of users whose access rights should be revoked? partial versus total. can a subset of the rights associated with an object be revoked or must we revoke all access rights for this object? temporary versus permanent. can access be revoked permanently that is the revoked access right will never again be available or can access be revoked and later be obtained again? with an access list scheme revocation is easy. the access list is searched for any access rights to be revoked and they are deleted from the list. revocation is immediate and can be general or selective total or partial and permanent or temporary. capabilities however present a much more difficult revocation problem. since the capabilities are distributed throughout the system we must find them before we can revoke them. schemes that implement revocation for capabilities include the following reacquisition. periodically capabilities are deleted from each domain. if a process wants to use a capability it may find that that capability has been deleted. the process may then try to reacquire the capability. if access has been revoked the process will not be able to reacquire the capability. back pointers. a list of pointers is maintained with each object pointing to all capabilities associated with that object. when revocation is required we can follow these pointers changing the capabilities as necessary. this scheme was adopted in the multics system. it is quite general but its implementation is costly. indirection. the capabilities point indirectly not directly to the objects. each capability points to a unique entry in a global table which in turn points to the object. we implement revocation by searching the global table for the desired entry and deleting it. then when an access is attempted the capability is found to point to an illegal table entry. table entries can be reused for other capabilities without difficulty since both the capability and the table entry contain the unique name of the object. the object for a