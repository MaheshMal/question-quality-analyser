 only by one of the other waiting processes. this example illustrates a deadlock involving the same resource type. deadlocks may also involve different resource types. for example consider a system with one printer and one dvd d rive. suppose that process p. is holding the dvd and process p is holding the printer. if p requests the printer and p. requests the dvd drive a deadlock occurs. a programmer who is developing multithreaded applications must pay particular attention to this problem. multithreaded programs are good candidates for deadlock because multiple threads can. compete for shared resources. . deadlock characterization in a deadlock processes never finish executing and system resources are tied up preventing other jobs from starting. before we discuss the various methods for dealing with the deadlock problem we look more closely at features that characterize deadlocks. . . necessary conditions a deadlock situation can arise if the following four conditions hold simultaneously in a system . mutual exclusion. at least one resource must be held in a nonsharable mode that is only one process at a time can use the resource. if another process requests that resource the requesting process must be delayed until the resource has been released. deadlock with mutex locks let's see how deadlock can occur in a multithreaded pthread program using mutex locks. the pthreadjnutex iaitd function initializes an unlocked mutex. mutex locks are acquired and released using ptiar ead.b'u i ex. ldclc a nd p thre adjmitex. unlock x ' respec ' tively. if a th raad .attempts to acquire a . locked niutex . ihg . call ita x.. ptiireati.inviubx lacikio blocks the thready until the ovvner of the rnufiex ieok invokes pt jire ad. iinjitexi uril c k . locks are createci inihe following cad? example . i .. .. . . create and .initialize .the .mut ex locks 'xx . p trire.adjmitex..t i i.r.st.jjiiitez . . .. l. !i.. i ....!...i .. dthread.ifflitex t secon d miitex 'm l i pthread mitex. init.c f.i.rst.mutfix. ..elill . . .. ... .. . ... . next two threads thread one and thxead.twp are crea ed and both tliese threads have access to both mutex locks thrfac cine and t h r e a d ..two run in the functions do..work oneo and do.work twc respectively as shown in figure . . s chapter deadlocks eli rsa d .on riirfs ici siife gij i t igii s sofaej dhirsaeiiimia sjsiufl. jcitr i if . ' tliread .t wo ruris in tti veld gto wqrk j wo !ydid jparanj do scbtrie work k if f r s t jmit ex pthread rnubek unlock i sec figure deadlock example. i .. in this example threaclpne aherripts toagquiire' sie iixvupx iilocks an the ordex first jnutex seeandjmiltbx i h ! e ttesadltwo'aiiteniipfento acgujre the rriutex locks in the order tq secbn m l p j i r l nites tspossibfcjif tliread q ne acquires mote that even though dead lock is pfossi ble i twill riot eeeuhiifirie a t o is able to acquire and release the rrvutex locks lor fiest utex ahd secoiid.mutex before threkd fwo atteiiipfe to acquire tke ibcks this example tllustratey a probiem with handjing deadlocks i t is c!i!tieult ts identify and test for deadlocks thai mav occttr omly tinder certain ckfetims teiinces. . . hold and wait. a process must be holding at least one resource and waiting to acquire additional resources that are currently being held by other processes. . no preemption. resources cannot be preempted. that is a resource can be released only voluntarily by the process holding it after that process has completed its task. . deadlock characterization . circular wait. a set p pi ... pn of waiting processes must exist such that p is waiting for a resource held by p p is waiting for a resource held by p? p. i is waiting for a resource held by pn and p is waiting for a resource held by pn. we emphasize that all four conditions must hold for a deadlock to occur. the circular wait condition implies the hold and wait condition so the four conditions are not completely independent. we shall see in section . however that it is useful to consider each condition separately . . resource allocation graph deadlocks can be described more precisely in terms of a directed graph called a system resource allocation graph. this graph consists of a set of vertices v and a set of edges e. the set of vertices v is partitioned into two different types of nodes p pi pi .. p the set consisting of all the active processes in the system and r r r? rm the set consisting of all resource types in the system. a directed edge from process p to resource type rj is denoted by p r it signifies that process p has requested an instance of resource type r and is currently waiting for that resource. a directed edge from resource type rj to process p is denoted by rj p it signifies that an instance of resource type rj has been allocated to process p . a directed edge p rj is called a request edge a directed edge rj p is called an assignment edge. pictorially we represent each process p as a circle and each resource type ri as a rectangle. since resource type rj may have more than one instance we represent each such instance as a dot within the rectangle. note that a request edge points to only the rectangle r whereas an assignment edge must also designate one of the dots in the rectangle. when process p requests an instance of resource type rj a request edge is inserted in the resource allocation graph. when this request can be fulfilled the request edge is instantaneously transformed to an assignment edge. when the process no longer needs access to the resource it releases the resource as a result the assignment edge is deleted. the resource allocation graph shown in figure . depicts the following situation. the sets p r and o p php p? o r ?! rz r r o p ru p r r p f r p r p. r p resource instances o one instance of resource type r o two instances of resource type i?? ' one instance of resource type rj r three instances of resource type r chapter deadloc s figure . resource allocation graph. process states o process p is holding an instance of resource type r and is waiting for an instance of resource type r . o process pn is holding an instance of r and an instance of r and is waiting for an instance of r . o process p is holding an instance of r . given the definition of a resource allocation graph it can be shown that if the graph contains no cycles then no process in the system is deadlocked. if the graph does contain a cycle then a deadlock may exist. if each resource type has exactly one instance then a cycle implies that a deadlock has occurred. if the cycle involves only a set of resource types each of which has only a single instance then a deadlock has occurred. each process involved in the cycle is deadlocked. in this case a cycle in the graph is both a necessary and a sufficient condition for the existence of deadlock. if each resource type has several instances then a cycle does not necessarily imply that a deadlock has occurred. in this case a cycle in the graph is a necessary but not a sufficient condition for the existence of deadlock. to illustrate this concept we return to the resource allocation graph depicted in figure . . suppose that process p requests an instance of resource type rt. since no resource instance is currently available a request edge p r? is added to the graph figure . . at this point two minimal cycles exist in the svstem pi p. r pt pi processes p p and p are deadlocked. process p is waiting for the resource r which is held by process p . process p is waiting for either process p or . deadlock characterization r figure . resource allocation graph with a deadlock. process pi to release resource ri. in addition process pi is waiting for process p? to release resource ri. now consider the resource allocation graph in figure . . in this example we also have a cycle however there is no deadlock. observe that process p may release its instance of resource type r?. that resource can then be allocated to p breaking the cycle in sunimary if a resource allocation graph does not have a cycle then the system is not in a deadlocked state. if there is a cycle then the system may or may not be in a deadlocked state. this observation is important when we deal with the deadlock problem. figure . resource allocation graph with a cycle but no deadlock. chapter? deadlocks