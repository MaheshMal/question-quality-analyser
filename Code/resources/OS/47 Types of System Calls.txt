 fc y register it 'parameters i code for t 'from tefe x i i system systern eailt call ' ' user program operating system figure . passing of parameters as a table. length of the memory buffer into which the input should be read. of course the device or file and length may be implicit in the call. three general methods are used to pass parameters to the operating system. the simplest approach is to pass the parameters in registers. in some cases however there may be more parameters than registers. in these cases the parameters are generally stored in a block or table in memory and the address of the block is passed as a parameter in a register figure . . this is the approach taken by linux and solaris. parameters also can be placed or pushed onto the stack by the program and popped off the stack by the operating system. some operating systems prefer the block or stack method because those approaches do not limit the number or length of parameters being passed. . types of system calls system calls can be grouped roughly into five major categories process control file manipulation device manipulation information maintenance and communications. in sections . . through . . we discuss briefly the types of system calls that may be provided by an operating system. most of these system calls support or are supported by concepts and functions that are discussed in later chapters. figure . summarizes the types of system calls normally provided by an operating system. . . process control a running program needs to be able to halt its execution either normally end or abnormally abort . if a system call is made to terminate the currently running program abnormally or if the program runs into a problem and causes an error trap a dump of memory is sometimes taken and an error message generated. the dump is written to disk and may be examined by a debugger a system program designed to aid the programmer in finding and correcting bugs to determine the cause of the problem. under either normal or abnormal circumstances the operating system must transfer control to the chapter operating system structures process control o end abort o load execute o create process terminate process o get process attributes set process attributes o wait for time o wait event signal event o allocate and free memory file management create file delete file o open close read write reposition o get file attributes set file attributes device management o request device release device read write reposition o get device attributes set device attributes logically attach or detach devices information maintenance o get time or date set time or date o get system data set system data o get process file or device attributes o set process file or device attributes communications create delete communication connection send receive messages o transfer status information o attach or detach remote devices figure . types of system calls. invoking command interpreter. the command interpreter then reads the next command. in an interactive system the command interpreter simply continues with the next command it is assumed that the user will issue an appropriate command to respond to any error. in a gui system a pop up window might alert the user to the error and ask for guidance. in a batch system the command interpreter usually terminates the entire job and continues with the next job. . types of system calls example of standard c library the standard c library provides a portion of the system call interface for many versions of unix and linux. as an example lot's assume a c program invokes the p r i n t f statement. the c library intercepts this call and invokes the necessary system call s in the operating system in this instance the write system call. the c library takes the value returned by w r i t e and passes it back to the user program. this is shown in figure . . include stdio.h int main printf greetings i return o user mode standard c library kernel mode figure . c library handling of w r i t e . some systems allow control cards to indicate special recovery actions in case an error occurs. a control card is a batch system concept. it is a command to manage the execution of a process. if the program discovers an error in its input and wants to terminate abnormally it may also want to define an error level. more severe errors can be indicated by a higher level error parameter. it is then possible to combine normal and abnormal termination by defining a normal termination as an error at level . the command interpreter or a following program can use this error level to determine the next action automatically. a process or job executing one program may want to load and execute another program. this feature allows the command interpreter to execute a program as directed by for example a user command the click of a mouse or a batch command. an interesting question is where to return control when the loaded program terminates. this question is related to the problem of whether the existing program is lost saved or allowed to continue execution concurrently with the new program. chapter operating system structures if control returns to the existing program when the new program terminates we must save the memory image of the existing program thus we have effectively created a mechanism for one program to call another program. if both programs continue concurrently we have created a new job or process to be multiprogrammed. often there is a system call specifically for this purpose create process or submit job . if we create a new job or process or perhaps even a set of jobs or processes we should be able to control its execution. this control requires the ability to determine and reset the attributes of a job or process including the job's priority its maximum allowable execution time and so on get process attributes and set process attributes . we may also want to terminate a job or process that we created terminate process if we find that it is incorrect or is no longer needed. having created new jobs or processes we may need to wait for them to finish their execution. we may want to wait for a certain amount of time to pass wait time more probably we will want to wait for a specific event to occur wait event . the jobs or processes should then signal when that event has occurred signal event . system calls of this type dealing with the coordination of concurrent processes are discussed in great detail in chapter . another set of system calls is helpful in debugging a program. many systems provide system calls to dump memory. this provision is useful for debugging. a program trace lists each instruction as it is executed it is provided by fewer systems. even microprocessors provide a cpu mode known as single step in which a trap is executed by the cpu after every instruction. the trap is usually caught by a debugger. many operating systems provide a time profile of a program to indicate the amount of time that the program executes at a particular location or set of locations. a time profile requires either a tracing facility or regular timer interrupts. at every occurrence of the timer interrupt the value of the program free memory free memory process iinterpfefer jrrterfjre er kernel kernel a b figure . ms dos execution a at system startup b running a program. . types of system calls counter is recorded. with sufficiently frequent timer interrupts a statistical picture of the time spent on various parts of the program can be obtained. there are so many facets of and variations in process and job control that we next use two examples one involving a single tasking system and the other a multitasking system to clarify these concepts. the ms dos operating system is an example of a single tasking system. it has a command interpreter that is invoked when the computer is started figure . a . because ms dos is single tasking it uses a simple method to run a program and does not create a new process. it loads the program into memory writing over most of itself to give the program as much memory as possible figure . b . next it sets the instruction pointer to the first instruction of the program. the program then runs and either an error causes a trap or the program executes a system call to terminate. in either case the error code is saved in the system memory for later use. following this action the small portion of the command interpreter that was not overwritten resumes execution. its first task is to reload the rest of the command interpreter from disk. then the command interpreter makes the previous error code available to the user or to the next program. freebsd derived from berkeley unix is an example of a multitasking system. when a user logs on to the system the shell of the user's choice is run. this shell is similar to the ms dos shell in that it accepts commands and executes programs that the user requests. however since freebsd is a multitasking system the command interpreter may continue running while another program is executed figure . . to start a new process the shell executes a fork system call. then the selected program is loaded into memory via an exec system call and the program is executed. depending on the way the command was issued the shell then either waits for the process to finish or runs the process in the background. in the latter case the shell immediately reqviests another command. when a process is running in the background it cannot receive input directly from the keyboard because the shell is using this resource. i o is therefore done through files or through a gui interface. meanwhile the user is free to ask the shell to run other programs to monitor the progress of the running process to change that program's priority process d free memory process c interpreter process b kernel figure . freebsd running multiple programs. chapter operating system structures solaris dynamic tracing facility making running operating systems easier'to understand debug and tune is an active area of operating system research and implementation. for example solaris includes the d t r a c e dynamic tracing facility. this facility dynamically adds probes to a running system. these probes can be queried via the d programming language to determine an astonishing amount about the kernel the system state and process activities. for example figure . follows an application as it executes a system call ioctl and further shows the functional calls within the kernel as they execute lo perform the system call. lines ending with 'it' are executed in user mode and lines ending in k in kernel mode. l . all . d pqrep xclock' xever.tsqueued dtrace script '. all.d' matched probes cpu function xeventsqueued u xeventsqueued u xlltransbytesreadable u xlltransbytesreadable u xlitranssocketbytesreadable u xlltranssocketbytesreadable u ioctl u ioctl k getf k set active fd k set active fd k getf k get udatamodel k get udatamodel k releasef k clear active fd k n clear active fd k c cv broadcast k cv broadcast k releasef k ioctl k ioctl u xeventsqueued u c xeventsqueued ..i figure . solaris d t r a c e f o l l o w s a s y s t e m call w i t h i n t h e kernel i ! !! other operating systems are starting to include various perfojj figej and tracing tools fostered by research at various institutions including jfe and so on. when the process is done it executes an exit system call to terminate returning to the invoking process a status code of or a nonzero error code. this status or error code is then available to the shell or other programs. processes are discussed in chapter with an program example using the fork andexeco system calls. . types of system calls . . file management a the file system will be discussed in more detail in chapters and . we can however identify several common system calls dealing with files we first need to be able to create and delete files. either system call requires the name of the file and perhaps some of the file's attributes. once the file is created we need to open it and to use it. we may also read write or reposition rewinding or skipping to the end of the file for example . finally we need to close the file indicating that we are no longer using it. we may need these same sets of operations for directories if we have a directory structure for organizing files in the file system. in addition for either files or directories we need to be able to determine the values of various attributes and perhaps to reset them if necessary. file attributes include the file name a file type protection codes accounting information and so on. at least two system calls get file attribute and set file attribute are required for this function. some operating systems provide many more calls such as calls for file move and copy. others might provide an api that performs those operations using code and other system calls and others might just provide system programs to perform those tasks. if the system programs are callable by other programs then each can be considered an api by other system programs. . . device management a process may need several resources to execute main memory disk drives access to files and so on. if the resources are available they can be granted and control can be returned to the user process. otherwise the process will have to wait until sufficient resources are available. the various resources controlled by the operating sysstem can be thought of as devices. some of these devices are physical devices for example tapes while others can be thought of as abstract or virtual devices for example files . if there are multiple users of the system the system may require us to first request the device to ensure exclusive use of it. after we are finished with the device we release it. these functions are similar to the open and close system calls for files. other operating systems allow unmanaged access to devices. the hazard then is the potential for device contention and perhaps deadlock which is described in chapter . once the device has been requested and allocated to us we can read write and possibly reposition the device just as we can with files. in fact the similarity between i o devices and files is so great that many operating systems including unix merge the two into a combined file device structure. in this case a set of system calls is used on files and devices. sometimes i o devices are identified by special file names directory placement or file attributes. the ui can also make files and devices appear to be similar even though the underlying system calls are dissimilar. this is another example of the many design decisions that go into building an operating system and user interface. . . information maintenance many system calls exist simply for the purpose of transferring information between the user program and the operating system. for example most chapter operating system structures systems have a system call to return the current time and date. other system calls may return information about the system such as the number of current users the version number of the operating system the amount of free memory or disk space and so on. in addition the operating system keeps information about all its processes and svstem calls are used to access this information. generally calls are also used to reset the process information get process attributes and set process a t t r i b u t e s . in section . . we discuss what information is normally kept. . . communication there are two common models of interprocess communication the messagepassing model and the shared memory model. in the message passing model the communicating processes exchange messages with one another to transfer information. messages can be exchanged between the processes either directly or indirectly through a common mailbox. before communication can take place a connection must be opened. the name of the other communicator must be known be it another process on the same system or a process on another computer connected by a communications network. each computer in a network has a host name by which it is commonly known. a host also has a network identifier such as an ip address. similarly each process has a process name and this name is translated into an identifier by which the operating system can refer to the process. the get host id and get processid system calls do this translation. the identifiers are then passed to the generalpurpose open and close calls provided by the file system or to specific open connection and close connection system calls depending on the system's model of communication. the recipient process usually must give its permission for communication to take place with an accept connection call. most processes that will be receiving connections are special purpose daemons which are systems programs provided for that purpose. they execute a wait for c onnect ion call and are awakened when a connection is made. the source of the communication known as the client and the receiving daemon known as a server then exchange messages by using read message and write message system calls. the close connection call terminates the communication. in the shared memory model processes use shared memory create and shared memory attach system calls to create and gain access to regions of memory owned by other processes. recall that normally the operating system tries to prevent one process from accessing another process's memory. shared memory requires that two or more processes agree to remove this restriction. they can then exchange information by reading and writing data in the shared areas. the form of the data and the location are determined by the processes and are not under the operating system's control. the processes are also responsible for ensuring that they are not writing to the same location simultaneously. such mechanisms are discussed in chapter . in chapter we look at a variation of the process scheme threads in which memory is shared by default. both of the models just discussed are common in operating systems and most systems implement both. message passing is useful for exchanging smaller amounts of data because no conflicts need be avoided. it is also easier to implement than is shared memory for intercomputer communication. shared