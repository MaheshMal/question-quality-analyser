 although this method may not seem to be a viable approach to the deadlock problem it is nevertheless used in most operating systems as mentioned earlier. in many systems deadlocks occur infrequently say once per year thus this method is cheaper than the prevention avoidance or detection and recovery methods which must be used constantly also in some circumstances a system is in a frozen state but not in a deadlocked state. we see this situation for example with a real time process running at the highest priority or any process running on a nonpreemptive scheduler and never returning control to the operating system. the system must have manual recovery methods for such conditions and may simply use those techniques for deadlock recovery. . deadlock prevention as we noted in section . . for a deadlock to occur each of the four necessary conditions must hold. by ensuring that at least one of these conditions cannot hold we can prevent the occurrence of a deadlock. we elaborate on this approach by examining each of the four necessary conditions separately. . . mutual exclusion the mutual exclusion condition must hold for nonsharable resources. for example a printer cannot be simultaneously shared by several processes. sharable resources in contrast do not require mutually exclusive access and thus cannot be involved in a deadlock. read only files are a good example of a sharable resource. if several processes attempt to open a read only file at the same time they can be granted simultaneous access to the file. a process never needs to wait for a sharable resource. in general however we cannot prevent deadlocks by denying the mutual exclusion condition because some resources are intrinsically nonsharable . . hold and wait to ensure that the hold and wait condition never occurs in the system we must guarantee that whenever a process requests a resource it does not hold any other resources. one protocol that can be used requires each process to request and be allocated all its resources before it begins execution. we can implement this provision by requiring that system calls requesting resources for a process precede all other system calls. an alternative protocol allows a process to request resources only when it has none. a process may request some resources and use them. before it can request any additional resources however it must release all the resources that it is currently allocated. to illustrate the difference between these two protocols we consider a process that copies data from a dvd drive to a file on disk sorts the file and then prints the results to a printer. if all resources must be requested at the beginning of the process then the process must initially request the dvd drive disk file and printer. it will hold the printer for its entire execution even though it needs the printer only at the end. the second method allows the process to request initially only the dvd drive and disk file. it copies from the dvd drive to the disk and then releases chapter deadlocks both the dvd drive and the disk file. the process must then again request the disk file and the printer. after copying the disk file to the printer it releases these two resources and terminates. both these protocols have two main disadvantages. first resource utilization may be low since resources may be allocated but unused for a long period. in the example given for instance we can release the dvd drive and disk file and then again request the disk file and printer only if we can be sure that our data will remain on the disk file. if we cannot be assured that they will then we must request all resources at the beginning for both protocols. second starvation is possible. a process that needs several popular resources may have to wait indefinitely because at least one of the resources that it needs is always allocated to some other process. . . no preemption the third necessary condition for deadlocks is that there be no preemption of resources that have already been allocated. to ensure that this condition does not hold we can use the following protocol. if a process is holding some resources and requests another resource that cannot be immediately allocated to it that is the process must wait then all resources currently being held are preempted. in other words these resources are implicitly released. the preempted resources are added to the list of resources for which the process is waiting. the process will be restarted only when it can regain its old resources as well as the new ones that it is requesting. alternatively if a process requests some resources we first check whether they are available. if they are we allocate them. if they are not we check whether they are allocated to some other process that is waiting for additional resources. if so we preempt the desired resources from the waiting process and allocate them to the requesting process. if the resources are neither available nor held by a waiting process the requesting process must wait. while it is waiting some of its resources may be preempted but only if another process requests them. a process can be restarted only when it is allocated the new resources it is requesting and recovers any resources that were preempted while it was waiting. this protocol is often applied to resources whose state can be easily saved and restored later such as cpu registers and memory space. it cannot generally be applied to such resources as printers and tape drives. . . circular wait the fourth and final condition for deadlocks is the circular wait condition. one way to ensure that this condition never holds is to impose a total ordering of all resource types and to require that each process requests resources in an increasing order of enumeration. to illustrate we let r r ri ... rm be the set of resource types. we assign to each resource type a unique integer number which allows us to compare two resources and to determine whether one precedes another in our ordering. formally we define a one to one function f r n where n is the set of natural numbers. for example if the set of resource types r includes . deadlock prevention tape drives disk drives and printers then the function f might be defined as follows f tape drive f di.s.k drive f printer we can now consider the following protocol to prevent deadlocks each process can request resources only in an increasing order of enumeration. that is a process can initially request any number of instances of a resource type say r . after that the process can request instances of resource type r if and only if f r f r . if several instances of the same resource type are needed a single request for all of them must be issued. for example using the function defined previously a process that wants to use the tape drive and printer at the same time must first request the tape drive and then request the printer. alternatively we can require that whenever a process requests an instance of resource type r it has released any resources r. such that f rj f rj . if these two protocols are used then the circular wait condition cannot hold. we can demonstrate this fact by assuming that a circular wait exists proof by contradiction . let the set of processes involved in the circular wait be pq p ... p where p. is waiting for a resource r which is held by process p i. modulo arithmetic is used on the indexes so that p is waiting for a resource r held by po then since process p. i is holding resource r while requesting resource r i we must have f r f r i for all i. but this condition means that f r f r f r f r . by transitivity f ro f rq which is impossible. therefore there can be no circular wait. we can accomplish this scheme in an application program by developing an ordering among all synchronization objects in the system. all requests for synchronization objects must be made in increasing order. for example if the lock ordering in the pthread program shown in figure . was f first mutex f second mutex then threacltwo could not request the locks out of order. keep in mind that developing an ordering or hierarchy in itself does not prevent deadlock. it is up to application developers to write programs that follow the ordering. also note that the function f should be defined according to the normal order of usage of the resources in a system. for example because the tape drive is usually needed before the printer it would be reasonable to define f tape drive f printer . although ensuring that resources are acquired in the proper order is the responsibility of application developers certain software can be used to verify that locks are acquired in the proper order and to give appropriate warnings when locks are acquired out of order and deadlock is possible. one lock order verifier which works on bsd versions of unix such as freebsd is known as witness. witness uses mutual exclusion locks to protect critical sections as described in chapter it works by dynamically maintaining the relationship of lock orders in a system. let's use the program shown in figure . as an example. assume that threaclone is the tirst to acquire the locks and does so in chapter deadlocks the order firstjnutex secondjnutex. witness records the relationship that f i r s t jnutex must be acquired before secondjnutex. if threacltwo later acquires the locks out of order witness generates a warning message on the system console. 