 generally speaking we can deal with the deadlock problem in one of three ways we can use a protocol to prevent or avoid deadlocks ensuring that the system will never enter a deadlock state. we can allow the system to enter a deadlock state detect it and recover. we can ignore the problem altogether and pretend that deadlocks never occur in the system. the third solution is the one used by most operating systems including ljmtx and windows it is then up to the application developer to write programs that handle deadlocks. next we elaborate briefly on each of the three methods for handling deadlocks. then in sections . through . we present detailed algorithms. however before proceeding we should mention that some researchers have argued that none of the basic approaches alone is appropriate for the entire spectrum of resource allocation problems in operating systems. the basic approaches can be combined however allowing us to select an optimal approach for each class of resources in a system. to ensure that deadlocks never occur the system can use either a deadlockprevention or a deadlock avoidance scheme. deadlock prevention provides a set of methods for ensuring that at least one of the necessary conditions section . . cannot hold. these methods prevent deadlocks by constraining how requests for resources can be made. we discuss these methods in section . . deadlock avoidance requires that the operating system be given in advance additional information concerning which resources a process will request and use during its lifetime. with this additional knowledge it can decide for each request whether or not the process should wait. to decide whether the current request can be satisfied or must be delayed the system must consider the resources currently available the resources currently allocated to each process and the future requests and releases of each process. we discuss these schemes in section . . if a system does not employ either a deadlock prevention or a deadlockavoidance algorithm then a deadlock situation may arise. in this environment the system can provide an algorithm that examines the state of the system to determine whether a deadlock has occurred and an algorithm to recover from the deadlock if a deadlock has indeed occurred . we discuss these issues in section . and section . . if a system neither ensures that a deadlock will never occur nor provides a mechanism for deadlock detection and recovery then we may arrive at a situation where the system is in a deadlocked state yet has no way of recognizing what has happened. in this case the undetected deadlock will result in deterioration of the system's performance because resources are being held by processes that cannot run and because more and more processes as they make requests for resources will enter a deadlocked state. eventually the system will stop functioning and will need to be restarted manually