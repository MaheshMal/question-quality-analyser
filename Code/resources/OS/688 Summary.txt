 in a distributed system with no common memory and no common clock it is sometimes impossible to determine the exact order in which two events occur. the happened before relation is only a partial ordering of the events in a distributed system. timestamps can be used to provide a consistent event ordering. mutual exclusion in a distributed environment can be implemented in a variety of ways. in a centralized approach one of the processes in the system is chosen to coordinate the entry to the critical section. in the fully distributed approach the decision making is distributed across the entire system. a distributed algorithm which is applicable to ring structured networks is the token passing approach. for atomicity to be ensured all the sites in which a transaction t has executed must agree on the final outcome of the execution. t either commits at all sites or aborts at all sites. to ensure this property the transaction coordinator of t must execute a commit protocol. the most widely used commit protocol is the pc protocol. the various concurrency control schemes that can be used in a centralized system can be modified for use in a distributed environment. in the case of locking protocols we need only change the way the lock manager is implemented. in the case of timestamping and validation schemes the only change needed is the development of a mechanism for generating unique global timestamps. the mechanism can either concatenate a local timestamp with the site identification or advance local clocks whenever a message arrives that has a larger timestamp. the primary method for dealing with deadlocks in a distributed environment is deadlock detection. the main problem is deciding how to maintain the exercises wait for graph. methods for organizing the wait for graph include a centralized approach and a fully distributed approach. some distributed algorithms require the use of a coordinator. if the coordinator fails because of the failure of the site at which it resides the system can continue execution only by restarting a new copy of the coordinator on some other site. it can do so by maintaining a backup coordinator that is ready to assume responsibility if the coordinator fails. another approach is to choose the new coordinator after the coordinator has failed. the algorithms that determine where a new copy of the coordinator should be restarted are called election algorithms. two algorithms the bully algorithm and the ring algorithm can be used to elect a new coordinator in case of failures. exercises . discuss the advantages and disadvantages of the two methods we presented for generating globally unique timestamps. . the logical clock timestamp scheme presented in this chapter provides the following guarantee if event a happens before event b then the timestamp of a is less than the timestamp of b. note however that one cannot order two events based only on their timestamps. the fact that an event c has a timestamp that is less than the timestamp of event d does not necessarily mean that event c happened before event d c and d could be concurrent events in the system. discuss ways in which the logical clock timestamp scheme could be extended to distinguish concurrent events from events that can be ordered by the happens before relationship. . your company is building a computer network and you are asked to write an algorithm for achieving distributed mutual exclusion. which scheme will you use? explain your choice. . why is deadlock detection much more expensive in a distributed environment than in a centralized environment? . your company is building a computer network and you are asked to develop a scheme for dealing with the deadlock problem. a. would you use a deadlock detection scheme or a deadlockprevention scheme? b. if you were to use a deadlock prevention scheme which one would you use? explain your choice. c. if you were to use a deadlock detection scheme which one would you use? explain your choice. . under what circumstances does the wait die scheme perform betterthan the wound wait scheme for granting resources to concurrently executing transactions? . consider the centralized and the fully distributed approaches to deadlock detection. compare the two algorithms in terms of message complexity. chapter distributed coordination . consider the following hierarchical deadlock detection algorithm in which the global wait for graph is distributed over a number of different controllers which are organized in a tree. each non leaf controller maintains a wait for graph that contains relevant information from the graphs of the controllers in the subtree below it. in particular let sa sg and sc be controllers such that sc is the lowest common ancestor of sa and sb sc must be unique since we are dealing with a tree . suppose that node t appears in the local wait for graph of controllers sa and sg. then t must also appear in the local wait for graph of controller sc every controller in the path from sc to sa every controller in the path from sc to sb in addition if and tj appear in the wait for graph of controller so and there exists a path from to t in the wait for graph of one of the children of so then an edge t tj must be in the wait for graph of sd. show that if a cycle exists in any of the wait for graphs then the system is deadlocked. . derive an election algorithm for bidirectional rings that is more efficient than the one presented in this chapter. how many messages are needed for n processes? . consider a setting where processors are not associated with unique identifiers but the total number of processors is known and the processors are organized along a bidirectional ring. is it possible to derive an election algorithm for such a setting? . consider a failure that occurs during pc for a transaction. for each possible failure explain how pc ensures transaction atomicity despite the failure. . consider the following failure model for faulty processors. processors follow the protocol but might fail at unexpected points in time. when processors fail they simply stop functioning and do not continue to participate in the distributed system. given such a failure model design an algorithm for reaching agreement among a set of processors. discuss the conditions under which agreement could be reached. bibliographical notes the distributed algorithm for extending the happened befbre relation to a consistent total ordering of all the events in the system was developed by lamport b . further discussions of using logical time to characterize the behavior of distributed systems can be found in fidge raynal and singhal babaoglu and marzullo schwarz and mattern and mattern . bibliographical notes the first general algorithm for implementing mutual exclusion in a distributed environment was also developed by lamport b . lamport's scheme requires x n messages per critical section entry. subsequently ricart and agrawala proposed a distributed algorithm that requires only x j messages. their algorithm is presented in section . . . a squareroot algorithm for distributed mutual exclusion was described by maekawa . the token passing algorithm for ring structured systems presented in section . . was developed by lann . carvalho and roucairol discussed mutual exclusion in computer networks and agrawal and abbadi described an efficient and fault tolerant solution of distributed mutual exclusion. a simple taxonomy for distributed mutual exclusion algorithms was presented by raynal the issue of distributed synchronization was discussed by reed and kanodia shared memory environment lamport b lamport a and schneider totally disjoint processes . a distributed solution to the dining philosophers problem was presented by chang . the pc protocol was developed by lampson and sturgis and gray mohan and lindsay discussed two modified versions of pc called presume commit and presume abort that reduce the overhead of pc by defining default assumptions regarding the fate of transactions. papers dealing with the problems of implementing the transaction concept in a distributed database were presented by gray traiger et al. and spector and schwarz . comprehensive discussions of distributed concurrency control were offered by bernstein et al. rosenkrantz et al. reported the timestamp distributed deadlock prevention algorithm. the fully distributed deadlock detection scheme presented in section . . was developed by obermarck . the hierarchical deadlock detection scheme of exercise . appeared in menasce and muntz . knapp and singhal offered surveys of deadlock detection in distributed systems. deadlocks can also be detected by taking global snapshots of a distributed system as discussed in chandy and lamport the byzantine generals problem was discussed by lamport et al. and pease et al. . the bully algorithm was presented by garcia molina and the election algorithm for a ring structured system was written by lann . part seven special purpose systems our coverage of operating system issues thus far has focused mainly on general purpose computing systems. there are however specialpurpose systems with requirements different from those of many of the systems we have described. a real time system is a computer system that requires not only that computed results be correct but also that the results be produced within a specified deadline period. results produced after the deadline has passed even if correct may be of no real value. for such systems many traditional operating system scheduling algorithms must be modified to meet the stringent timing deadlines. a multimedia system must be able to handle not only conventional data such as text files programs and word processing documents but also multimedia data. multimedia data consist of continuous media data audio and video as well as conventional data. continuous media data such as frames of video must be delivered according to certain time restrictions for example frames per second . the demands of handling continuous media data require significant changes in operatingsystem structure most notably in memory disk and network management. apter '