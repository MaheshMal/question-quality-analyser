 . allocation methods the direct access nature of disks allows us flexibility in the implementation of files in almost every case many files are stored on the same disk. the main problem is how to allocate space to these files so that disk space is utilized effectively and files can be accessed quickly. three major methods of allocating disk space are in wide use contiguous linked and indexed. each method has advantages and disadvantages. some systems such as data general's rdos for its nova line of computers support all three. more commonly a system vises one method for all files within a file system type. . . contiguous allocation contiguous allocation requires that each file occupy a set of contiguous blocks on the disk. disk addresses define a linear ordering on the disk. with this ordering assuming that only one job is accessing the disk accessing block b after block b normally requires no head movement. when head movement is needed from the last sector of one cylinder to the first sector of the next cylinder the head need only move from one track to the next. thus the number of disk seeks required for accessing contiguously allocated files is minimal as is seek time when a seek is finally needed. the ibm vm cms operating system uses contiguous allocation because it provides such good performance. contiguous allocation of a file is defined by the disk address and length in block units of the first block. if the file is n blocks long and starts at location b then it occupies blocks b b b ... b n . the directory entry for each file indicates the address of the starting block and the length of the area allocated for this file figure . . directory file start ength count tr mail list f figure . contiguous allocation of disk space. chapter file system implementation accessing a file that has been allocated contiguously is easy. for sequential access the file system remembers the disk adciress of the last block referenced and when necessary reads the next block. for direct access to block ' of a file that starts at block b we can immediately access block b i. thus both sequential and direct access can be supported by contiguous allocation. contiguous allocation has some problems however. one difficulty is finding space for a new file. the system chosen to manage free space determines how this task is accomplished these management systems are discussed in section . . any management system can be used but some are slower than others. the contiguous allocation problem can be seen as a particular application of the general dynamic storage allocation problem discussed in section . which involves how to satisfy a request of size n from a list of free holes. first fit and best fit are the most common strategies used to select a free hole from the set of available holes. simulations have shown that both first fit and best fit are more efficient than worst fit in terms of both time and storage utilization. neither first fit nor best fit is clearly best in terms of storage utilization but first fit is generally faster. all these algorithms suffer from the problem of external fragmentation. as files are allocated and deleted the free disk space is broken into little pieces. external fragmentation exists whenever free space is broken into chunks. it becomes a problem when the largest contiguous chunk is insufficient for a request storage is fragmented into a number of holes no one of which is large enough to store the data. depending on the total amount of disk storage and the average file size external fragmentation may be a minor or a major problem. some older pc systems used contiguous allocation on floppy disks. to prevent loss of significant amounts of disk space to external fragmentation the user had to run a repacking routine that copied the entire file system onto another floppy disk or onto a tape. the original floppy disk was then freed completely creating one large contiguous free space. the routine then copied the files back onto the floppy disk by allocating contiguous space from this one large hole. this scheme effectively compacts all free space into one contiguous space solving the fragmentation problem. the cost of this compaction is time. the time cost is particularly severe for large hard disks that use contiguous allocation where compacting all the space may take hours and may be necessary on a weekly basis. some systems require that this function be done off line with the file system unmounted. during this down time normal system operation generally cannot be permitted so such compaction is avoided at all costs on production machines. most modern systems that need defragmentation can perform it on line during normal system operations but the performance penalty can be substantial. another problem with contiguous allocation is determining how much space is needed for a file. when the file is created the total amount of space it will need must be found and allocated. how does the creator program or person know the size of the file to be created? in some cases this determination may be fairly simple copying an existing file for example in general however the size of an output file may be difficult to estimate. if we allocate too little space to a file we may find that the file cannot be extended. especially with a best fit allocation strategy the space on both sides of the file may be in use. hence we cannot make the file larger in place. . allocation methods two possibilities then exist. first the user program can be terminated with an appropriate error message. the user must then allocate more space and run the program again. these repeated runs may be costly. to prevent them the user will normally overestimate the amount of space needed resulting in considerable wasted space. the other possibility is to find a larger hole copy the contents of the file to the new space and release the previous space. this series of actions can be repeated as long as space exists although it can be time consuming. however the user need never be informed explicitly about what is happening the system continues despite the problem although more and more slowly. even if the total amount of space needed for a file is known in advance preallocation may be inefficient. a file that will growr slowly over a long period months or years must be allocated enough space for its final size even though much of that space will be unused for a long time. the file therefore has a large amount of internal fragmentation. to minimize these drawbacks some operating systems use a modified contiguous allocation scheme. here a contiguous chunk of space is allocated initially and then if that amount proves not to be large enough another chunk of contiguous space known as an extent is added. the location of a file's blocks is then recorded as a location and a block count plus a link to the first block of the next extent. on some systems the owner of the file can set the extent size but this setting results in inefficiencies if the owner is incorrect. internal fragmentation can still be a problem if the extents are too large and external fragmentation can become a problem as extents of varying sizes are allocated and deallocated. the commercial veritas file system uses extents to optimize performance. it is a high performance replacement for the standard unix ufs. . . linked allocation linked allocation solves all problems of contiguous allocation. with linked allocation each file is a linked list of disk blocks the disk blocks may be scattered anywhere on the disk. the directory contains a pointer to the first and last blocks of the file. for example a file of five blocks might start at block and continue at block then block then block and finally block figure . . each block contains a pointer to the next block. these pointers are not made available to the user. thus if each block is bytes in size and a disk address the pointer requires bytes then the user sees blocks of bytes. to create a new file we simply create a new entry in the directory. with linked allocation each directory entry has a pointer to the first disk block of the file. this pointer is initialized to nil the end of list pointer value to signify an empty file. the size field is also set to . a write to the file causes the free space management system to find a free block and this new block is written to and is linked to the end of the file. to read a file we simply read blocks by following the pointers from block to block. there is no external fragmentation with linked allocation and any free block on the free space list can be used to satisfy a request. the size of a file need not be declared when that file is created. a file can continue to grow as long as free blocks are available. consequently it is never necessary to compact disk space. chapter file syslem implementation directory file start end jeep figure . linked allocation of disk space. linked allocation does have disadvantages however. the major problem is that it can be used effectively only for sequential access files. to find the ith block of a file we must start at the beginning of that file and follow the pointers until we get to the ith block. each access to a pointer requires a disk read and some require a disk seek. consequently it is inefficient to support a direct access capability for linked allocation files. another disadvantage is the space required for the pointers. if a pointer requires bytes out of a byte block then . percent of the disk is being used for pointers rather than for information. each file requires slightly more space than it would otherwise. the usual solution to this problem is to collect blocks into multiples called clusters and to allocate clusters rather than blocks. for instance the file system may define a cluster as four blocks and operate on the disk only in cluster units. pointers then use a much smaller percentage of the file's disk space. this method allows the logical to physical block mapping to remain simple but improves disk throughput because fewer disk head seeks are required and decreases the space needed for block allocation and free list management. the cost of this approach is an increase in internal fragmentation because more space is wasted when a cluster is partially full than when a block is partially full. clusters can be used to improve the disk access time for many other algorithms as well so they are used in most file systems. yet another problem of linked allocation is reliability. recall that the files are linked together by pointers scattered all over the disk and consider what would happen if a pointer were lost or damaged. a bug in the operating system software or a disk hardware failure might result in picking up the wrong pointer. this error could in turn result in linking into the free space list or into another file. one partial solution is to use doubly linked lists and another is to store the file name and relative block number in each block however these schemes require even more overhead for each file. . allocation methods directory entry test h name start block .. . . .. . no. of disk blocks fat figure . file allocation table. an important variation on linked allocation is the use of a file allocation table fat . this simple but efficient method of disk space allocation is used by the ms dos and os operating systems. a section of disk at the beginning of each volume is set aside to contain the table. the table has one entry for each disk block and is indexed by block number. the fat is used in much the same way as a linked list. the directory entry contains the block number of the first block of the file. the table entry indexed by that block number contains the block number of the next block in the file. this chain continues until the last block which has a special enci of file value as the table entry. unused blocks are indicated by a table value. allocating a new block to a file is a simple matter of finding the first valued table entry and replacing the previous end of file value with the address of the new block. the is then replaced with the end of file value. an illustrative example is the fat structure shown in figure . . for a file consisting of disk blocks and . the fat allocation scheme can result in a significant number of disk head seeks unless the fat is cached. the disk head must move to the start of the volume to read the fat and find the location of the block in question then move to the location of the block itself. in the worst case both moves occur for each of the blocks. a benefit is that random access time is improved because the disk head can find the location of any block by reading the information in the fat. . . indexed allocation linked allocation solves the external fragmentation and size declaration problems of contiguous allocation. however in the absence of a fat linked allocation cannot support efficient direct access since the pointers to the blocks are scattered with the blocks themselves all over the disk and must be retrieved chapter file system implementation directory f . a' k a ill l ! .'j c i i v . . . figure . indexed allocation of disk space. in order. indexed allocation solves this problem by bringing all the pointers together into one location the index block. each file has its own index block which is an array of disk block addresses. the ' entry in the index block points to the ' block of the file. the directory contains the address of the index block figure . . to find and read the th block we use the pointer in the ' index block entry. this scheme is similar to the paging scheme described in section . . when the file is created all pointers in the index block are set to nil. when the ith block is first written a block is obtained from the free space manager and its address is put in the zth index block entry. indexed allocation supports direct access without suffering from external fragmentation because any free block on the disk can satisfy a request for more space. indexed allocation does suffer from wasted space however. the pointer overhead of the index block is generally greater than the pointer overhead of linked allocation. consider a common case in which we have a file of only one or two blocks. with linked allocation we lose the space of only one pointer per block. with indexed allocation an entire index block must be allocated even if only one or two pointers will be non nil. this point raises the question of how large the index block should be. every file must have an index block so we want the index block to be as small as possible. if the index block is too small however it will not be able to hold enough pointers for a large file and a mechanism will have to be available to deal with this issue. mechanisms for this purpose include the following linked scheme. an index block is normally one disk block. thus it can be read and written directly by itself. to allow for large files we can link together several index blocks. for example an index block might contain a small header giving the name of the file and a set of the first disk block . allocation methods addresses. the next address the last word in the index block is nil for a small file or is a pointer to another index block for a large file . ' multilevel index. a variant of the linked representation is to use a firstlevel index block to point to a set of second level index blocks which in turn point to the file blocks. to access a block the operating system uses the first level index to find a second level index block and then uses that block to find the desired data block. this approach could be continued to a third or fourth level depending on the desired maximum file size. with byte blocks we could store byte pointers in an index block. two levels of indexes allow data blocks and a file size of up to gb. combined scheme. another alternative vised in the ufs is to keep the first say pointers of the index block in the file's inode. the first of these pointers point to direct blocks that is they contain addresses of blocks that contain data of the file. thus the data for small files of no more than blocks do not need a separate index block. if the block size is kb then up to kb of data can be accessed directly. the next three pointers point to indirect blocks. the first points to a single indirect block which is an index block containing not data but the addresses of blocks that do contain data. the second points to a double indirect block which contains the address of a block that contains the addresses of blocks that contain pointers to the actual data blocks. the last pointer contains the address of a triple indirect block. under this method the number of blocks that can be allocated to a file exceeds the amount of space addressable by the byte file pointers used by many operating systems. a bit file pointer reaches only bytes or gb. many unix implementations including solaris and ibm's a x now support up to bit file pointers. pointers of this size allow files and file systems to be terabytes in size. a unix inode is shown in figure . . indexed allocation schemes suffer from some of the same performance problems as does linked allocation. specifically the index blocks can be cached in memory but the data blocks may be spread all over a volume. . . performance the allocation methods that we have discussed vary in their storage efficiency and data block access times. both are important criteria in selecting the proper method or methods for an operating system to implement. before selecting an allocation method we need to determine how the systems will be used. a system with mostly sequential access should not use the same method as a system with mostly random access. for any type of access contiguous allocation requires only one access to get a disk block. since we can easily keep the initial address of the file in memory we can calculate immediately the disk address of the th block or the next block and read it directly. for linked allocation we can also keep the address of the next block in memory and read it directly. this method is fine for sequential access for direct access however an access to the th block might require disk reads. this chapter file system implementation figure . the unix inode. problem indicates why linked allocation should not be used for an application requiring direct access. as a result some systems support direct access files by using contiguous allocation and sequential access by linked allocation. for these systems the type of access to be made must be declared when the file is created. a file created for sequential access will be linked and cannot be used for direct access. a file created for direct access will be contiguous and can support both direct access and sequential access but its maximum length must be declared when it is created. in this case the operating system must have appropriate data structures and algorithms to support both allocation methods. files can be converted from one type to another by the creation of a new file of the desired type into which the contents of the old file are copied. the old file may then be deleted and the new file renamed. indexed allocation is more complex. if the index block is already in memory then the access can be made directly. however keeping the index block in memory requires considerable space. if this memory space is not available then we may have to read first the index block and then the desired data block. for a two level index two index block reads might be necessary. for an extremely large file accessing a block near the end of the file would require reading in all the index blocks before the needed data block finally could be read. thus the performance of indexed allocation depends on the index structure on the size of the file and on the position of the block desired. some systems combine contiguous allocation with indexed allocation by using contiguous allocation for small files up to three or four blocks and automatically switching to an indexed allocation if the file grows large. since most files are small and contiguous allocation is efficient for small files average performance can be quite good