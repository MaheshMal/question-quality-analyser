 as we saw in chapter memory is central to the operation of a modern computer system . memory consists of a large array of words or bytes each with its own address. the cpu fetches instructions from memory according to the value of the program counter. these instructions may cause additional loading from and storing to specific memory addresses. a typical instruction execution cycle for example first fetches an instruction from memory the instruction is then decoded and may cause operands to be fetched from memory. after the instruction has been executed on the chapter main memory operands results may be stored back in memory. the memory unit sees ortly a stream of memory addresses it does not know how they are generated by the instruction counter indexing indirection literal addresses and so on or what they are for instructions or data . accordingly we can ignore ha w a program generates a memory address. we are interested only in the sequence of memory addresses generated by the running program. we begin our discussion by covering several issues that are pertinent to the various techniques for managing memory. this includes an overview of basic hardware issues the binding of symbolic memory addresses to actual physical addresses and distinguishing between logical and physical addresses. we conclude with a discussion of dynamically loading and linking code and shared libraries. . . basic hardware main memory and the registers built into the processor itself are the only storage that the cpu can access directly. there are machine instructions that take memory addresses as arguments but none that take disk addresses. therefore any instructions in execution and any data being used by the instructions must be in one of these direct access storage devices. if the data are not in memory they must be moved there before the cpl can operate on them. registers that are built into the cpu are generally accessible within one cycle of the cpu clock. most cpus can decode instructions and perform simple operations on register contents at the rate of one or more operations per clock tick. the same cannot be said of main memory which is accessed via a transaction on the memory bus. memory access may take many cycles of the cpu clock to complete in which case the processor normally needs to stall since it does not have the data required to complete the instruction that it is executing. this situation is intolerable because of the frequency of memory operating ' . jsystenn process tm process base process limit figure . a base and a limit register define a logical address space. . background accesses. the remedy is to add fast memory between the cpu and main memory. a memory buffer used to accommodate a speed differential called a cache. is described in section . . . not only are we concerned with the relative speed of accessing physical memory but we also must ensure correct operation has to protect the operating system from access by user processes and in addition to protect user processes from one another. this protection must be provided by the hardware. it can be implemented in several ways as we shall see throughout the chapter. in this section we outline one possible implementation. we first need to make sure that each process has a separate memory space. to do this we need the ability to determine the range of legal addresses that the process may access and to ensure that the process can access only these legal addresses. we can provide this protection by using two registers usually a base and a limit as illustrated in figure . . the base register holds the smallest legal physical memory address the limit register specifies the size of the range. for example if the base register holds and limit register is then the program can legally access all addresses from through inclusive . protection of memory space is accomplished by having the cpu hardware compare even address generated in user mode with the registers. any attempt by a program executing in user mode to access operating system memory or other users' memory results in a trap to the operating system which treats the attempt as a fatal error figure . . this scheme prevents a user program from accidentally or deliberately modifying the code or data structures of either the operating system or other users. the base and limit registers can be loaded only by the operating system which uses a special privileged instruction. since privileged instructions can be executed only in kernel mode and since only the operating system executes in kernel mode only the operating system can load the base and limit registers. this scheme allows the operating system to change the value of the registers but prevents user programs from changing the registers' contents. the operating system executing in kernel mode is given unrestricted access to both operating system and users' memory. this provision allows trap to operating system memory monitor addressing error figure . hardware address protection with base and limit registers. chapter main memory the operating system to load users' programs into users' memory to durrtp out those programs in case of errors to access and modify parameters of system calls and so on. . . address binding usually a program resides on a disk as a binary executable file. to be executed the program must be brought into memory and placed within a process. depending on the memory management in use the process may be moved between disk and memory during its execution. the processes on the disk that are waiting to be brought into memory for execution form the input queue. the normal procedure is to select one of the processes in the input queue and to load that process into memory. as the process is executed it accesses instructions and data from memory. eventually the process terminates and its memory space is declared available. most systems allow a user process to reside in any part of the physical memory. thus although the address space of the computer starts at the first address of the user process need not be . this approach affects the addresses that the user program can use. in most cases a user program will go through several steps some of which maybe optional before being executed figure . . addresses may be represented in different ways during these steps. addresses in the source program are generally symbolic such as count . a compiler will typically bind these symbolic addresses to relocatable addresses such as bytes from the beginning of this module'' . the linkage editor or loader will in turn bind the relocatable addresses to absolute addresses such as . each binding is a mapping from one address space to another. classically the binding of instructions and data to memory addresses can be done at any step along the way compile time. if you know at compile time where the process will reside in memory then absolute code can be generated. for example if you know that a user process will reside starting at location r then the generated compiler code will start at that location and extend up from there. if at some later time the starting location changes then it will be necessary to recompile this code. the ms dos .com fo.nn.at programs are bound at compile time. load time. if it is not known at compile time where the process will reside in memory then the compiler must generate relocatable code. in this case final binding is delayed until load time. if the starting address changes we need only reload the user code to incorporate this changed value. execution time. if the process can be moved during its execution from one memory segment to another then binding must be delayed until run time. special hardware must be available for this scheme to work as will be discussed in section . . . most general purpose operating systems use this method. a major portion of this chapter is devoted to showing how these various bindings can be implemented effectively in a computer system and to discussing appropriate hardware support. . background compile time a v ' ' ot ect othe i module i objsct y v modules z . linkage sdiioi oad y load vy module i time system library loader aynamically loaded i systerr . library in mernorydynamic binary executk linking memory time ru image time figure . multistep processing of a user program. . . logical versus physical address space an address generated by the cpu is commonly referred to as a logical address whereas an address seen by the memory unit that is the one loaded into the memory address register of the memory is commonly referred to as a physical address. the compile time and load time address binding methods generate identical logical and physical addresses. however the execution time addressbinding scheme results in differing logical and physical addresses. in this case we usually refer to the logical address as a virtual address. we use logical address and virtual address interchangeably in this text. the set of all logical addresses generated by a program is a logical address space the set of all physical addresses corresponding to these logical addresses is a physical address space. thus in the execution time address binding scheme the logical and physical address spaces differ. the run time mapping from virtual to physical addresses is done by a hardware device called the memory management unit mmu . we can choose from many different methods to accomplish such mapping as we discuss in chapter main memory logical physical address address mmu figure . dynamic relocation using a relocation register. sections . through . . for the time being we illustrate this mapping with a simple mmu scheme which is a generalization of the base register scheme described in section . . . the base register is now called a relocation register. the value in the relocation register is added to every address generated by a user process at the time it is sent to memory see figure . . for example if the base is at then an attempt by the user to address location is dynamically relocated to location an access to location is mapped to location . the ms dos operating system running on. the intel x family of processors uses four relocation registers when loading and running processes. the user program never sees the real physical addresses. the program can create a pointer to location store it in memory manipulate it and compare it with other addresses all as the number . only when it is used as a memory address in an indirect load or store perhaps is it relocated relative to the base register. the user program deals with logical addresses. the memory mapping hardware converts logical addresses into physical addresses. this form of execution time binding was discussed in section . . . the final location of a referenced memory address is not determined until the reference is made. we now have two different types of addresses logical addresses in the range to max and physical addresses in the range r to r max for a base value r . the user generates only logical addresses and thinks that the process runs in locations to max. the user program supplies logical addresses these logical addresses must be mapped to physical addresses before they are used. the concept of a logical address space that is bound to a separate physical address space is central to proper memory management. . . dynamic loading in our discussion so far the entire program and all data of a process must be in physical memory for the process to execute. the size of a process is thus limited to the size of physical memory. to obtain better memory space utilization we can use dynamic loading. with dynamic loading a routine is not loaded until it is called. all routines are kept on disk in a relocatable load format. the main . background program is loaded into memory and is executed. when a routine needs to call another routine the calling routine first checks to see whether the other routine has been loaded. if not the relocatable linking loader is called to load the desired routine into memory and to update the program's address tables to reflect this change. then control is passed to the newly loaded routine. the advantage of dynamic loading is that an unused routine is never loaded. this method is particularly useful when large amounts of code are needed to handle infrequently occurring cases such as error routines. in this case although the total program size may be large the portion that is used and hence loaded may be much smaller. dynamic loading does not require special support from the operating system. it is the responsibility of the users to design their programs to take advantage of such a method. operating systems may help the programmer however by providing library routines to implement dynamic loading. . . dynamic linking and shared libraries figure . also shows dynamically linked libraries. some operating systems support only static linking in which system language libraries are treated like any other object module and are combined by the loader into the binary program image. the concept of dynamic linking is similar to that of dynamic loading. here though linking rather than loading is postponed until execution time. this feature is usually used with system libraries such as language subroutine libraries. without this facility each program on a system must include a copy of its language library or at least the routines referenced by the program in the executable image. this requirement wastes both disk space and main memory. with dynamic linking a stub is included in the image for each libraryroutine reference. the stub is a small piece of code that indicates how to locate the appropriate memory resident library routine or how to load the library if the routine is not already present. when the stub is executed it checks to see whether the needed routine is already in memory. if not the program loads the routine into memory. either way the stub replaces itself with the address of the routine and executes the routine. thus the next time that particular code segment is reached the library routine is executed directly incurring no cost for dynamic linking. under this scheme all processes that use a language library execute only one copy of the library code. this feature can be extended to library updates such as bug fixes . a library may be replaced by a new version and all programs that reference the library wrill automatically use the new version. without dynamic linking all such programs would need to be relinked to gain access to the new library. so that programs will not accidentally execute new incompatible versions of libraries version information is included in both the program and the library. more than one version of a library may be loaded into memory and each program uses its version information to decide which copy of the library to use. minor changes retain the same version number whereas major changes increment the version number. thus only programs that are compiled with the new library version are affected by the incompatible changes incorporated in it. other programs linked before the new library was installed will continue using the older library. this system is also known as shared libraries. chapter s main memory unlike dynamic loading dynamic linking generally requires help from the operating system. if the processes in memory are protected from one another then the operating system is the only entity that can check to see whether the needed routine is in another process's memory space or that can allow multiple processes to access the same memory addresses. we elaborate on this concept when we discuss paging in section