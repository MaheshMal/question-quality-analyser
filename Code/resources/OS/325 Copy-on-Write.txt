 effective access time p x p milliseconds p x p x . x p. we see then that the effective access time is directly proportional to the page fault rate. if one access out of causes a page fault the effective access time is . microseconds. the computer will be slowed down by a factor of because of demand paging! if we want performance degradation to be less than percent we need x p x p p . . that is to keep the slowdown due to paging at a reasonable level we can allow fewer than one memory access out of to page fault. in sum it is important to keep the page fault rate low in a demand paging system. otherwise the effective access time increases slowing process execution dramatically. an additional aspect of demand paging is the handling and overall use of swap space. disk i o to swap space is generally faster than that to the file system. it is faster because swap space is allocated in much larger blocks and file lookups and indirect allocation methods are not used chapter . the system can therefore gain better paging throughput by copying an entire file image into the swap space at process startup and then performing demand paging from the swap space. another option is to demand pages from the file system initially but to write the pages to swap space as they are replaced. this approach will ensure that only needed pages are read from the file system but that all subsequent paging is done from swap space. some systems attempt to limit the amount of swap space used through demand paging of binary files. demand pages for such files are brought directly from the file system. however when page replacement is called for these frames can simply be overwritten because they are never modified and the pages can be read in from the file system again if needed. using this approach the file system itself serves as the backing store. however swap space must still be used for pages not associated with a file these pages include the stack and heap for a process. this method appears to be a good compromise and is used in several systems including solaris and bsd unix. . copy on wrste in section . we illustrated how a process can start quickly by merely demandpaging in the page containing the first instruction. however process creation using the f ork system call may initially bypass the need for demand paging by using a technique similar to page sharing covered in section . . . this technique provides for rapid process creation and minimizes the number of new pages that must be allocated to the newly created process. chapter virtual memory process. physical memory process hs irnt rr i i ' m. figure . before process modifies page c. recall that the fork system call creates a child process as a duplicate of its parent. traditionally f o r k o worked by creating a copy of the parent's address space for the child duplicating the pages belonging to the parent. however considering that many child processes invoke the exec system call immediately after creation the copying of the parent's address space may be unnecessary. alternatively we can use a technique known as copy on write which works by allowing the parent and child processes initially to share the same pages. these shared pages are marked as copy on write pages meaning that if either process writes to a shared page a copy of the shared page is created. copy on write is illustrated in figures . and figure . which show the contents of the physical memory before and after process modifies page c. for example assume that the child process attempts to modify a page containing portions of the stack with the pages set to be copy on write. the operating system will then create a copy of this page mapping it to the address space of the child process. the child process will then modify its copied page and not the page belonging to the parent process. obviously when the copy onwrite technique is used only the pages that are modified by either process are copied all unmodified pages can be shared by the parent and child processes. physical process memory process. figure . after process modifies page c