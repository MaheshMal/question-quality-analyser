 in many applications ensuring the security of the computer system is worth considerable effort. large commercial systems containing payroll or other financial data are inviting targets to thieves. systems that contain data pertaining to corporate operations may be of interest to unscrupulous competitors. furthermore loss of such data whether by accident or fraud can seriously impair the ability of the corporation to function. in chapter we discussed mechanisms that the operating system can provide with appropriate aid from the hardware that allow users to protect chapter security their resources including programs and data. these mechanisms work well only as long as the users conform to the intended use of and access to these resources. we say that a system is secure if its resources are used and accessed as intended under all circumstances. unfortunately total security cannot be achieved. nonetheless we must have mechanisms to make security breaches a rare occurrence rather than the norm. security violations or misuse of the system can be categorized as intentional malicious or accidental. it is easier to protect against accidental misuse than against malicious misuse. for the most part protection mechanisms are the core of protection from accidents. the following list includes forms of accidental and malicious security violations. we should note that in our discussion of security we vise the terms intruder and cracker for those attempting to breach security. in addition a threat is the potential for a security violation stich as the discovery of a vulnerability whereas an attack is the attempt to break secvirity. breach of confidentiality. this type of violation involves unauthorized reading of data or theft of information . typically a breach of confidentiality is the goal of an intruder. capturing secret data from a system or a data stream such as credit card information or identity information for identity theft can result directly in money for the intruder. breach of integrity. this violation involves unauthorized modification of data. such attacks can for example result in passing of liability to an innocent party or modification of the source code of an important commercial application. breach of availability. this violation involves unauthorized destruction of data. some crackers would rather wreak havoc and gain status or bragging rights than gain financially. web site defacement is a common example of this type of security breach. theft of service. this violation involves unauthorized use of resources. for example an intruder or intrusion program may install a daemon on a system that acts as a file server. denial of service. this violation involves preventing legitimate use of the system. denial of service or dos attacks are sometimes accidental. the original internet worm turned into a dos attack when a bug failed to delay its rapid spread. we discuss dos attacks further in section . . . attackers use several standard methods in their attempts to breach security. the most common is masquerading in which one participant in a communication pretends to be someone else another host or another person . by masquerading attackers breach authentication the correctness of identification they can then can gain access that they would not normally be allowed or escalate their privileges obtain privileges to which they would not normally be entitled. another common attack is to replay a captured exchange of data. a replay attack consists of the malicious or fraudulent repeat of a valid data transmission. sometimes the replay comprises the entire attack for example in a repeat of a request to transfer money. but frequently it is done along with message modification again to escalate privileges. consider the damage that could be done if a request for authentication had a legitimate . the security problem user's information replaced with an unauthorized user's. yet another kind of attack is the man in the middle attack in which an attacker sits in the data flow of a communication masquerading as the sender to the receiver and vice versa. in a network communication a man in the middle attack may be preceded by a session hijacking in which an active communication session is intercepted. several attack methods are depicted in figure . . as we have already suggested absolute protection of the system from malicious abuse is not possible but the cost to the perpetrator can be made sufficiently high to deter most intruders. in some cases such as a denial ofservice attack it is preferable to prevent the attack but sufficient to detect the attack so that countermeasures can be taken. normal communication sender receiver attacker masquerading sender .f.o'ii receiver attacker man in the middle attacker figure . standard security attacks. chapter security to protect a system we must take security measures at four levels . physical. the site or sites containing the computer systems must be physically secured against armed or surreptitious entry by intruders. both the machine rooms and the terminals or workstations that have access to the machines must be secured. . human. authorizing users must be done carefully to assure that only appropriate users have access to the system. even authorized users however may be encouraged to let others use their access in exchange for a bribe for example . they may also be tricked into allowing access via social engineering. one type of social engineering attack is phishing. here a legitimate looking e mail or web page misleads a user into entering confidential information. another technique is dumpster diving a general term for attempting to gather information in order to gain unauthorized access to the computer by looking through trash finding phone books or finding notes containing passwords for example . these security problems are management and personnel issues not problems pertaining to operating systems. . operating system. the system must protect itself from accidental or purposeful security breaches. a runaway process could constitute an accidental denial of service attack. a query to a service could reveal passwords. a stack overflow could allow the launching of an unauthorized process. the list of possible breaches is almost endless. . network. much computer data in modern systems travels over private leased lines shared lines like the internet wireless connections or dial up lines. intercepting these data could be just as harmful as breaking into a computer and interruption of communications could constitute a remote denial of service attack diminishing users' use of and trust in the system. security at the first two levels must be maintained if operating system security is to be ensured. a weakness at a high level of security physical or human allows circumvention of strict low level operating system security measures. thus the old adage that a chain is as weak as its weakest link is especially true of system security. all of these aspects must be addressed for security to be maintained. furthermore the system must provide protection chapter to allow the implementation of security features. without the ability to authorize users and processes to control their access and to log their activities it would be impossible for an operating system to implement security measures or to run securely. hardware protection features are needed to support an overall protection scheme. for example a system without memory protection cannot be secure. new hardware features are allowing systems to be made more secure as we shall discuss. unfortunately little in security is straightforward. as intruders exploit security vulnerabilities security countermeasures are created and deployed. this causes intruders to become more sophisticated in their attacks. for example recent security incidents include the use of spyware to provide a conduit for spam through innocent systems we discuss this practice in . program threats section . . this cat and mouse game is likely to continue with more security tools needed to block the escalating intruder techniques and activities. in the remainder of this chapter we address security at the network and operating system levels. security at the physical and human levels although important is for the most part beyond the scope of this text. security within the operating system and between operating systems is implemented in several ways ranging from passwords for authentication through guarding against viruses to detecting intrusions. we start with an exploration of security threats. . program threats processes along with the kernel are the only means of accomplishing work on a computer. therefore writing a program that creates a breach of security or causing a normal process to change its behavior and create a breach is a common goal of crackers. in fact even most nonprogram security events have as their goal causing a program threat. for example while it is useful to log in to a system without authorization it is quite a lot more useful to leave behind a back door daemon that provides information or allows easy access even if the original exploit is blocked. in this section we describe common methods by which programs cause security breaches. note that there is considerable variation in the naming conventions of security holes and that we use the most common or descriptive terms. . . trojan horse many systems have mechanisms for allowing programs written by users to be executed by other users. if these programs are executed in a domain that provides the access rights of the executing user the other users may misuse these rights. a text editor program for example may include code to search the file to be edited for certain keywords. if any are found the entire file may be copied to a special area accessible to the creator of the text editor. a code segment that misuses its environment is called a trojan horse. long search paths such as are common on unix systems exacerbate the trojanhorse problem. the search path lists the set of directories to search when an ambiguous program name is given. the path is searched for a file of that name and the file is executed. all the directories in such a search path must be secure or a trojan horse could be slipped into the user's path and executed accidentally. for instance consider the use of the . character in a search path. the . tells the shell to include the current directory in the search. thus if a user has . in her search path has set her current directory to a friend's directory and enters the name of a normal system command the command may be executed from the friend's directory instead. the program would run within the user's domain allowing the program to do anything that the user is allowed to do including deleting the user's files for instance. a variation of the trojan horse is a program that emulates a login program. an unsuspecting user starts to log in at a terminal and notices that he has apparently mistyped his password. he tries again and is successful. what has happened is that his authentication key and password have been stolen by the login emulator which was left running on the terminal by the thief. chapter security the emulator stored away the password printed out a login error message and exited the user was then provided with a genuine login prompt. this type of attack can be defeated by having the operating system print a usage message at the end of an interactive session or by a non trappable key sequence such as the c o n t r o l a l t d e l e t e combination used by all modern windows operating systems. another variation on the trojan horse is spyware. spyware sometimes accompanies a program that the user has chosen to install. most frequently it comes along with freeware or shareware programs but sometimes it is included with commercial software. the goal of spyware is to download ads to display on the user's system create pop up browser windows when certain sites are visited or capture information from the user's system and return it to a central site. this latter mode is an example of a general category of attacks known as covert channels in which surreptitious communication occurs. as a current example the installation of an innocuous seeming program on a windows system could result in the loading of a spyware daemon. the spyware could contact a central site be given a message and a list of recipient addresses and deliver the spam message to those users from the windows machine. this process continues until the user discovers the spyware. frequently the spyware is not discovered. in it was estimated that percent of spam was being delivered by this method. this theft of service is not even considered a crime in most countries! spyware is a micro example of a macro problem violation of the principle of least privilege. under most circumstances a user of an operating system does not need to install network daemons. such daemons are installed via two mistakes. first a user may run with more privileges than necessary for example as the administrator allowing programs that she runs to have more access to the system than is necessary. this is a case of human error a common security weakness. second an operating system may allow by default more privileges than a normal user needs. this is a case of poor operating system design decisions. an operating system and indeed software in general should allow fine grained control of access and security but it must also be easy to manage and understand. inconvenient or inadequate security measures are bound to be circumvented causing an overall weakening of the security they were designed to implement. . . trap door the designer of a program or system might leave a hole in the software that only she is capable of using. this type of security breach or trap door was shown in the movie war games. for instance the code might check for a specific user id or password and it might circumvent normal security procedures. programmers have been arrested for embezzling from banks by including rounding errors in their code and having the occasional half cent credited to their accounts. this account crediting can add up to a large amount of money considering the number of transactions that a large bank executes. a clever trap door could be included in a compiler. the compiler could generate standard object code as well as a trap door regardless of the source code being compiled. this activity is particularly nefarious since a search of the source code of the program will not reveal any problems. only the source code of the compiler would contain the information. . program threats trap doors pose a difficult problem because to detect them we have to analyze all the source code for all components of a system. given that software systems may consist of millions of lines of code this analysis is not done frequently and frequently it is not done at all! . . logic bomb consider a program that initiates a security incident only under certain circumstances. it would be hard to detect because under normal operations there would be no security hole. however when a predefined set of parameters were met the security hole would be created. this scenario is known as a logic bomb. a programmer for example might write code to detect if she is still employed if that check failed a daemon could be spawned to allow remote access or code could be launched to cause damage to the site. . . stack and buffer overflow the stack or buffer overflow attack is the most common way for an attacker outside the system on a network or dial up connection to gain unauthorized access to the target system. an authorized user of the system may also use this exploit for privilege escalation. essentially the attack exploits a bug in a program. the bug can be a simple case of poor programming in which the programmer neglected to code bounds checking on an input field hi this case the attacker sends more data than the program was expecting. using trial and error or by examining the source code of the attacked program if it is available the attacker determines the vulnerability and writes a program to do the following . overflow an input field command line argument or input buffer for example on a network daemon until it writes into the stack. . overwrite the current return address on the stack with the address of the exploit code loaded in step . . write a simple set of code for the next space in the stack that includes the commands that the attacker wishes to execute for instance spawn a shell. the result of this attack program's execution will be a root shell or other privileged command execution. for instance if a web page form expects a user name to be entered into a field the attacker could send the user name plus extra characters to overflow the buffer and reach the stack plus a new return address to load onto the stack plus the code the attacker wants to run. when the buffer reading subroutine returns from execution the return address is the exploit code and the code is run. let's look at a buffer overflow exploit in more detail. consider the simple c program shown in figure . . this program creates a character array of size buffer size and copies the contents of the parameter provided on the command line argv l . as long as the size of this parameter is less than buffer size we need one byte to store the null terminator this program works properly. but consider what happens if the parameter provided on the chapter security include stdio.h define buffer size int main int argc char argv char buffer buffer size if argc return else strcpy buffer argv return figure . c program with buffer overflow condition. command line is longer than buffer size. in this scenario the strcpy function will begin copying from argv until it encounters a null terminator or until the program crashes. thus this program suffers from a potential buffer overflow problem in which copied data overflow the buffer array. note that a careful programmer could have performed bounds checking on the size of argv by using the strncpy function rather than strcpy replacing the line strcpy buffer argv l with strncpy buffer argv l sizeof buf f e r l . unfortunately good bounds checking is the exception rather than the norm. furthermore lack of bounds checking is not the only possible cause of the behavior of the program in figure . . the program could instead have been carefully designed to compromise the integrity of the system. we now consider the possible security vulnerabilities of a buffer overflow. when a function is invoked in a typical computer architecture the variables defined locally to the function sometimes known as automatic variables the parameters passed to the function and the address to which control returns once the function exits are stored in a stack frame. the layout for a typical stack bottom frame pointer return address saved frame pointer grows automatic variables parameter s top figure . the layout for a typical stack frame. . program threats frame is shown in figure . . examining the stack frame from top to bottom we first see the parameters passed to the function followed by any automatic variables declared in the function. we next see the frame pointer which is the address of the beginning of the stack frame. finally we have the return address which specifies where to return control once the function exits. the frame pointer must be saved on the stack as the value of the stack pointer can vary during the function call the saved frame pointer allows relative access to parameters and automatic variables. given this standard memory layout a cracker could execute a bufferoverflow attack. her goal is to replace the return address in the stack frame so that it now points to the code segment containing the attacking program. the programmer first writes a short code segment such as the following include stdio.h int mainfint argc char argv execvpt'' bin sh'' 'v bin sh'' null return using the execvpo system call this code segment creates a shell process. if the program being attacked runs with system wide permissions this newly created shell will gain complete access to the system. of course the code segment could do anything allowed by the privileges of the attacked process. this code segment is then compiled so that the assembly language instructions can be modified. the primary modification is to remove unnecessary features in the code thereby reducing the code size so that it can fit into a stack frame. this assembled code fragment is now a binary sequence that will be at the heart of the attack. refer again to the program shown in figure . . let's asstime that when the maino function is called in that program the stack frame appears as shown in figure . a . using a debugger the programmer then finds the address of buffer in the stack. that address is the location of the code the attacker wants executed so the binary sequence is appended with the necessary amount of no op instructions for no operation to fill the stack frame up to the location of the return address and the location of buffer the new return address is added. the attack is complete when the attacker gives this constructed binary sequence as input to the process. the process then copies the binary sequence from argv to position buffer in the stack frame. now when control returns from maino instead of returning to the location specified by the old value of the return address we return to the modified shell code which runs with the access rights of the attacked process! figure . b contains the modified shell code. there are many ways to exploit potential buffer overflow problems. in this example we considered the possibility that the program being attacked the code shown in figure . ran with system wide permissions. however the code segment that runs once the value of the return address has been modified might perform any type of malicious act such as deleting files opening network ports for further exploitation and so on. chapter security return address address of mo li jed shell code ii no op copied a b figure . hypothetical stack frame for figure . a before and b after. this example buffer overflow attack reveals that considerable knowledge and programming skill are needed to recognize exploitable code and then to exploit it. unfortunately it does not take great programmers to launch security attacks. rather one cracker can determine the bug and then write an exploit. anyone with rudimentary computer skills and access to the exploit a so called script kiddie can then try to launch the attack at target systems. the buffer overflow attack is especially pernicious because it can be run between systems and can travel over allowed communication channels. such attacks can occur within protocols that are expected to be used to communicate with the target machine and they can therefore be hard to detect and prevent. they can even bypass the security added by firewalls section . . one solution to this problem is for the cpu to have a feature that disallows execution of code in a stack section of memory. recent versions of sun's sparc chip include this setting and recent versions of solaris enable it. the return address of the overflowed routine can still be modified but when the return address is within the stack and the code there attempts to execute an exception is generated and the program is halted with an error. recent versions of amd and intel x chips include the nx feature to prevent this type of attack. the use of the feature is supported in several x operating systems including linux and windows xp sp . the hardware implementation involves the use of a new bit in the page tables of the cpus. this bit marks the associated page as nonexecutable disallowing instructions to be read from it and executed. as this feature becomes prevalent buffer overflow attacks should greatly dimmish. . . viruses another form of program threat is a virus. viruses are self replicating and are designed to infect other programs. they can wreak havoc in a system by modifying or destroying files and causing system crashes and program . program threats malfunctions. a virus is a fragment of code embedded in a legitimate program. as with most penetration attacks viruses are very specific to architectures operating systems and applications. viruses are a particular problem for users of pcs. unix and other multiuser operating systems generally are not susceptible to viruses because the executable programs are protected from writing by the operating system. even if a virus does infect such a program its powers usually are limited because other aspects of the system are protected. viruses are usually borne via email with spam the most common vector. they can also spread when users download viral programs from internet file sharing services or exchange infected disks. another common form of virus transmission uses microsoft office files such as microsoft word documents. these documents can contain macros or visual basic programs that programs in the office suite word powerpoint and excel will execute automatically. because these programs run under the user's own account the macros can run largely unconstrained for example deleting user files at will . commonly the virus will also e mail itself to others in the user's contact list. here is a code sample that shows the simplicity of writing a visual basic macro that a virus could use to format the hard drive of a windows computer as soon as the file containing the macro was opened sub autoopen dim ofs set ofs createobject ''scripting.filesystemobject'' vs shell ''c command.com k format c '' vbhide end sub how do viruses work? once a virus reaches a target machine a program known as a virus dropper inserts the virus onto the system. the virus dropper is usually a trojan horse executed for other reasons but installing the virus as its core activity. once installed the virus may do any one of a number of things. there are literally thousands of viruses but they fall into several main categories. note that many viruses belong to more than one category. file. a standard file virus infects a system by appending itself to a file. it changes the start of the program so that execution jumps to its code. after it executes it returns control to the program so that its execution is not noticed. file viruses are sometimes known as parasitic viruses as they leave no full files behind and leave the host program still functional. boot. a boot virus infects the boot sector of the system executing every time the system is booted and before the operating system is loaded. it watches for other bootable media that is floppy disks and infects them. these viruses are also known as memory viruses because they do not appear in the file system. figure . shows how a boot virus works. macro. most viruses are written in a low level language such as assembly or c. macro viruses are written in a high level language such as visual basic. these viruses are triggered when a program capable of executing the macro is run. for example a macro virus could be contained in a spreadsheet file. chapter security virus copies buo' j sector to unusprt location x virus replaces original boot block with itself whenever new it btocks ariy aftenfi dt df thisategic b rrtt to removable r w d sk other pifdgrams o yi rite the is installed it infects u p boot sector n n certain bate that as well figure . a boot sector computer virus. source code. a source code virus looks for source code and modifies it to include the virus and to help spread the virus. polymorphic. this virus changes each time it is installed to avoid detection by antivirus software. the changes do not affect the virus's functionality but rather change the virus's signature. a virus signature is a pattern that can be used to identify a virus typically a series of bytes that make up the virus code. encrypted. an encrypted virus includes decryption code along with the encrypted virus again to avoid detection. the virus first decrypts and then executes. stealth. this tricky virus attempts to avoid detection by modifying parts of the system that could be used to detect it. for example it could modify the read system call so that if the file it has modified is read the original form of the code is returned rather than the infected code