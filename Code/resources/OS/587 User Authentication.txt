 to send a message m to the server the client sends c upon receiving c the server recovers and accepts m if v ktmac m a true. similarly to send a message m to the client the server sends c e kfp m s ktmc m and the client recovers and accepts m if v ktmac m a true. this protocol enables the server to limit the recipients of its messages to the client that generated pms and to limit the senders of the messages it accepts to that same client. similarly the client can limit the recipients of the messages it sends and the sender of the messages it accepts to the party that knows s kd that is the party that can decrypt cpms . in many applications such as web transactions the client needs to verify the identity of the party that knows s kti . this is one purpose of the certificate certs in particular the attrs field contains information that the client can vise to determine the identity for example the domain name of the server with which it is communicating. for applications in which the server also needs information about the client ssl supports an option by which a client can send a certificate to the server. in addition to its use on the internet ssl is being used for a wide variety of tasks. for example ipsec vpns now have a competitor in ssl vpns. ipsec is good for point to point encryption of traffic say between two company offices. ssl vpns are more flexible but not as efficient so they might be used between an individual employee working remotely and the corporate office. . user authentication the discussion of authentication above involves messages and sessions. but what of users? if a system cannot authenticate a user then authenticating that a message came from that user is pointless. thus a major security problem for operating systems is user authentication. the protection system depends on the ability to identify the programs and processes currently executing which in turn depends on the ability to identify each user of the system. a user normally identifies herself. how do we determine whether a user's identity is authentic? generally user authentication is based on one or more of three things the user's possession of something a key or card the user's knowledge of something a user identifier and password and or an attribute of the user fingerprint retina pattern or signature . chapter security . . passwords ? the most common approach to authenticating a user identity is the use of passwords. when the user identifies herself by user id or account name she is asked for a password. if the user supplied password matches the password stored in the system the system assumes that the account is being accessed by the owner of that account. passwords are often used to protect objects in the computer system in the absence of more complete protection schemes. they can be considered a special case of either keys or capabilities. for instance a password could be associated with each resource such as a file . whenever a request is made to use the resource the password must be given. if the password is correct access is granted. different passwords may be associated with different access rights. for example different passwords may be used for reading files appending files and updating files. in practice most systems require only one password for a user to gain full rights. although more passwords theoretically would be more secure such systems tend not to be implemented due to the classic trade off between security and convenience. if security makes something inconvenient then the security is frequently bypassed or otherwise circumvented. . . password vulnerabilities passwords are extremely common because they are easy to understand and use. unfortunately passwords can often be guessed accidentally exposed sniffed or illegally transferred from an authorized user to an unauthorized one as we show next. there are two common ways to guess a password. one way is for the intruder either human or program to know the user or to have information about the user. all too frequently people use obvious information such as the names of their cats or spouses as their passwords. the other way is to use brute force trying enumeration or all possible combinations of valid password characters letters numbers and punctuation on some systems until the password is found. short passwords are especially vulnerable to this method. for example a four decimal password provides only variations. on average guessing times would produce a correct hit. a program that could try a password every millisecond would take only about seconds to guess a four digit password. enumeration is less successful where systems allow longer passwords that include both uppercase and lowercase letters along with numbers and all punctuation characters. of course users must take advantage of the large password space and must not for example use only lowercase letters. in addition to being guessed passwords can be exposed as a result of visual or electronic monitoring. an intruder can look over the shoulder of a user shoulder surfing when the user is logging in and can learn the password easily by watching the keyboard. alternatively anyone with access to the network on which a computer resides can seamlessly add a network monitor allowing her to watch all data being transferred on the network sniffing including user ids and passwords. encrypting the data stream containing the password solves this problem. even such a system could have passwords stolen however. for example if a file is used to contain the passwords it . user authentication could be copied for off system analysis. or consider a trojan horse prpgram installed on the system that captures every keystroke before sending it on to the application. exposure is a particularly severe problem if the password is written down where it can be read or lost. as we shall see some systems force users to select hard to remember or long passwords which may cause a user to record the password or to reuse it. as a result such systems provide much less security than systems that allow users to select easy passwords! the final type of password compromise illegal transfer is the result of human nature. most computer installations have a rule that forbids users to share accounts. this rule is sometimes implemented for accounting reasons but is often aimed at improving security. for instance suppose one user id is shared by several users and a security breach occurs from that user id. it is impossible to know who was using the id at the time the break occurred or even whether the user was an authorized one. with one user per user id any user can be questioned directly about use of the account in addition the user might notice something different about the account and detect the break in. sometimes users break account sharing rules to help friends or to circumvent accounting and this behavior can result in a system's being accessed by unauthorized users possibly harmful ones. passwords can be either generated by the system or selected by a user. system generated passwords may be difficult to remember and thus users may write them down. as mentioned however user selected passwords are often easy to guess the user's name or favorite car for example . some systems will check a proposed password for ease of guessing or cracking before accepting it. at some sites administrators occasionally check user passwords and notify a user if his password is easy to guess. some systems also age passwords forcing users to change their passwords at regular intervals every three months for instance . this method is not foolproof either because users can easily toggle between two passwords. the solution as implemented on some systems is to record a password history for each user. for instance the system could record the last n passwords and not allow their reuse. several variants on these simple password schemes can be used. for example the password can be changed more frequently. in the extreme the password is changed from session to session. a new password is selected either by the system or by the user at the end of each session and that password must be used for the next session. in such a case even if a password is misused it can be used only once. when the legitimate user tries to use a now invalid password at the next session he discovers the security violation. steps can then be taken to repair the breached security. . . encrypted passwords one problem with all these approaches is the difficulty of keeping the password secret within the computer. how can the system store a password securely yet allow its use for authentication when the user presents her password? the unix system uses encryption to avoid the necessity of keeping its password list secret. each user has a password. the system contains a function that is extremely difficult the designers hope impossible to invert but is simple to compute. that is given a value x it is easy to compute the function value chapter security f x . given a function value f x however it is impossible to compute x this function is used to encode all passwords. only encoded passwords are stored. when a user presents a password it is encoded and compared against the stored encoded password. even if the stored encoded password is seen it cannot be decoded so the password cannot be determined. thus the password file does not need to be kept secret. the function is typically an encryption algorithm that has been designed and tested rigorously. the flaw in this method is that the system no longer has control over the passwords. although the passwords are encrypted anyone with a copy of the password file can run fast encryption routines against it encrypting each word in a dictionary for instance and comparing the results against the passwords. if the user has selected a password that is also a word in the dictionary the password is cracked. on sufficiently fast computers or even on clusters of slow computers stich a comparison may take only a few hours. furthermore because unix systems use a well known encryption algorithm a cracker might keep a cache of passwords that have been cracked previously. for these reason new versions of unix store the encrypted password entries in a file readable only by the superuser. the programs that compare a presented password to the stored password run s e t u i d to root so they can read this file but other users cannot. they also include a salt or recorded random number in the encryption algorithm. the salt is added to the password to ensure that if two plaintext passwords are the same they result in different ciphertexts. another weakness in the unix password methods is that many unix systems treat only the first eight characters as significant. it is therefore extremely important for users to take advantage of the available password space. to avoid the dictionary encryption method some systems disallow the use of dictionary words as passwords. a good technique is to generate your password by using the first letter of each word of an easily remembered phrase using both upper and lower characters with a number or punctuation mark thrown in for good measure. for example the phrase my mother's name is katherine might yield the password mmn.isk!' . the password is hard to crack but easy for the user to remember. . . one time passwords to avoid the problems of password sniffing and shoulder surfing a system could use a set of paired passwords. when a session begins the system randomly selects and presents one part of a password pair the user must supply the other part. in this system the user is challenged and must respond with the correct answer to that challenge. this approach can be generalized to the use of an algorithm as a password. the algorithm might be an integer function for example. the system selects a random integer and presents it to the user. the user applies the function and replies with the correct result. the system also applies the function. if the two results match access is allowed. such algorithmic passwords are not susceptible to reuse that is a user can type in a password and no entity intercepting that password will be able to reuse it. in this variation the system and the user share a secret. the secret is never transmitted over a medium that allows exposure. rather the secret is used as input to the function along with a shared seed. a seed is a random . user authentication number or alphanumeric sequence. the seed is the authentication challenge from the computer. the secret and the seed are used as input to the function secret seed . the result of this function is transmitted as the password to the computer. because the computer also knows the secret and the seed it can perform the same computation. if the results match the user is authenticated. the next time the user needs to be authenticated another seed is generated and the same steps ensue. this time the password is different. in this one time password system the password is different in each instance. anyone capturing the password from one session and trying to reuse it in another session will fail. one time passwords are among the only ways to prevent improper authentication due to password exposure. one time password systems are implemented in various ways. commercial implementations such as securld use hardware calculators. most of these calculators are shaped like a credit card a key chain dangle or a usb device they include a display and may or may not also have a keypad. some use the current time as the random seed. others require that the user enters the shared secret also known as a personal identification number or pin on the keypad. the display then shows the one time password. the use of both a one time password generator and a pin is one form of two factor authentication. two different types of components are needed in this case. two factor authentication offers far better authentication protection than single factor authentication. another variation on one time passwords is the use of a code book or one time pad which is a list of single use passwords. in this method each password on the list is used in order once and then is crossed out or erased. the commonly used s key system uses either a software calculator or a code book based on these calculations as a source of one time passwords. of course the user must protect his code book. . . biometrics another variation on the use of passwords for authentication involves the use of biometric measures. palm or hand readers are commonly used to secure physical access for example access to a data center. these readers match stored parameters against what is being read from hand reader pads. the parameters can include a temperature map as well as finger length finger width and line patterns. these devices are currently too large and expensive to be used for normal computer authentication. fingerprint readers have become accurate and cost effective and should become more common in the future. these devices read your finger's ridge patterns and convert them into a sequence of numbers. over time they can store a set of sequences to adjust for the location of the finger on the reading pad and other factors. software can then scan a finger on the pad and compare its features with these stored sequences to determine if the finger on the pad is the same as the stored one. of course multiple users can have profiles stored and the scanner can differentiate among them. a very accurate two factor authentication scheme can result from requiring a password as well as a user name and fingerprint scan. if this information is encrypted in transit the system can be very resistant to spoofing or replay attack. chapter security multi factor authentication is better still. consider how strong authentication can be with a usb device that must be plugged into the system a pin and a fingerprint scan. except for the user's having to place her finger on a pad and plug the usb into the system this authentication method is no less convenient that using normal passwords. recall though that strong authentication by itself is not sufficient to guarantee the id of the user. an authenticated session can still be hijacked if it is not encrypted