 disk card reader line printer figure . spooling. simultaneous peripheral operation on line. spooling in essence uses the disk as a huge buffer for reading as far ahead as possible on input devices and for storing output files until the output devices are able to accept them. spooling is also used for processing data at remote sites. the cpu sends the data via communication paths to a remote printer or accepts an entire input job from a remote card reader . the remote processing is done at its own speed with no cpu intervention. the cpu just needs to be notified when the processing is completed so that it can spool the next batch of data. spooling overlaps the i o of one job with the computation of other jobs. even in a simple system the spooler may be reading the input of one job while printing the output of a different job. during this time still another job or other jobs may be executed reading its cards from disk and printing its output lines onto the disk. spooling has a direct beneficial effect on the performance of the system. for the cost of some disk space and a few tables the computation of one job can overlap with the i o of other jobs. thus spooling can keep both the cpu and the i o devices working at much higher rates. spooling leads naturally to multiprogramming which is the foundation of all modern operating systems. . atlas the atlas operating system kilburn et al. howarth et al. was designed at the university of manchester in england in the late s and early s. many of its basic features that were novel at the time have become standard parts of modern operating systems. device drivers were a major part of the system. in addition system calls were added by a set of special instructions called extra codes. atlas was a batch operating system with spooling. spooling allowed the system to schedule jobs according to the availability of peripheral devices such as magnetic tape units paper tape readers paper tape punches line printers card readers and card punches. chapter influential operating systems the most remarkable feature of atlas however was its memory management. core memory was new and expensive at the time. many computers like the ibm used a drum for primary memory. the atlas system used a drum for its main memory but it had a small amount of core memory that was used as a cache for the drum. demand paging was used to transfer information between core memory and the drum automatically. the atlas system used a british computer with bit words. addresses were bits but were encoded in decimal which allowed only million words to be addressed. at that time this was an extremely large address space. the physical memory for atlas was a kb word drum and kb words of core. memory was divided into word pages providing frames in physical memory. an associative memory of registers implemented the mapping from a virtual address to a physical address. if a page fault occurred a page replacement algorithm was invoked. one memory frame was always kept empty so that a drum transfer could start immediately. the page replacement algorithm attempted to predict future memory accessing behavior based on past behavior. a reference bit for each frame was set whenever the frame was accessed. the reference bits were read into memory every instructions and the last values of these bits were retained. this history was used to define the time since the most recent reference h and the interval between the last two references t . pages were chosen for replacement in the following order . any page with t t . such a page is considered to be no longer in use. . if fi h for all pages then replace the page with the largest f fi. the page replacement algorithm assumes that programs access memory in loops. if the time between the last two references is t then another reference is expected fc time units later. if a reference does not occur t t it is assumed that the page is no longer being used and the page is replaced. if all pages are still in use then the page that will not be needed for the longest time is replaced. the time to the next reference is expected to be to h. . xds the xds operating system lichtenberger and pirtle was designed at the university of california at berkeley. like the atlas system it used paging for memory management. unlike the atlas system it was a time shared system. the paging was used only for relocation it was not used for demand paging. the virtual memory of any user process was made up of kb words whereas the physical memory was made up of kb words. each page was made up of kb words. the page table was kept in registers. since physical memory was larger than virtual memory several user processes could be in memory at the same time. the number of users could be increased by sharing of pages when the pages contained read only reentrant code. processes were kept on a drum and were swapped in and out of memory as necessary