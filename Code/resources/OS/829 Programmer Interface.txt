 information for the client. the client chooses one of the configurations and sends a request message to the selected dhcp server. the dhcp server responds with the ip address and configuration information it gave previously and with a lease for that address. the lease gives the client the right to use the ip address for a specified period of time. when the lease time is half expired the client attempts to renew the lease for the address. if the lease is not renewed the client must obtain a new one. . programmer interface the win api is the fundamental interface to the capabilities of windows xp. this section describes five main aspects of the win api access to kernel objects sharing of objects between processes process management interprocess communication and memory management. . . access to kernel objects the windows xp kernel provides many services that application programs can use. application programs obtain these services by manipulating kernel objects. a process gains access to a kernel object named xxx by calling the createxxx function to open a handle to xxx. this handle is unique to the process. depending on which object is being opened if the create function fails it may return or it may return a special constant named invalid handle value. a process can close any handle by calling the closehandle function and the system may delete the object if the count of processes using the object drops to . . . sharing objects between processes windows xp provides three ways to share objects between processes. the first way is for a child process to inherit a handle to the object. when the parent calls the createxxx function the parent supplies a securitiesjvttributes structure with the blnherithandle field set to true. this field creates an inheritable handle. next the child process is created passing a value of true to the createprocesso function's blnherithandle argument. figure . shows a code sample that creates a semaphore handle inherited by a child process. assuming the child process knows which handles are shared the parent and child can achieve interprocess communication through the shared objects. in the example in figure . the child process gets the value of the handle from the first command line argument and then shares the semaphore with the parent process. the second way to share objects is for one process to give the object a name when the object is created and for the second process to open the name. this method has two drawbacks windows xp does not provide a way to check whether an object with the chosen name already exists and the object name space is global without regard to the object type. for instance two applications may create an object named pipe when two distinct and possibly different objects are desired. chapter windows xp security attributes sa sa.nlength sizeof sa sa.lpsecuritydescriptor null sa.blnherithandle true handle a semaphore createsemaphore sa null char comand line ostrstream ostring comraandjine sizeof command. ine ostring a semaphore ends createprocess another process . exe command line null null true . . . figure . code enabling a child to share an object by inheriting a handle. named objects have the advantage that unrelated processes can readily share them. the first process calls one of the createxxx functions and supplies a name in the lpszname parameter. the second process gets a handle to share the object by calling openxxx or createxxx with the same name as shown in the example of figure . . the third way to share objects is via the duplicatehandleo function. this method requires some other method of interprocess communication to pass the duplicated handle. given a handle to a process and the value of a handle within that process a second process can get a handle to the same object and thus share it. an example of this method is shown in figure . . . . process management in windows xp a process is an executing instance of an application and a thread is a unit of code that can be scheduled by the operating system. thus a process contains one or more threads. a process is started when some other process calls the createprocess routine. this routine loads any dynamic link libraries used by the process and creates a primary thread. additional threads can be created by the createthreado function. each thread is created with its own stack which defaults to mb unless specified otherwise in an argument to createthreado. because some c run time functions maintain state in static variables such as errno a multithread application needs to guard against unsynchronized access. the wrapper function beginthreadexo provides appropriate synchronization. process a handle a semaphore createsemaphore null myseml process b handle b semaphore opensemaphore semaphorej lljiccess false myseml figure . code for sharing an object by name lookup. . programmer interface process a wants to give process b access to a semaphore process a handle a.semaphore createsemaphore null null send the value of the semaphore to process b using a message or shared memory object process b handle process a openprocess process j lljiccess false process id of a handle b.semaphore duplicatehandle process a a semaphore getcurrentprocess b semaphore false duplicate same access use b.semaphore to access the semaphore figure . code for sharing an object by passing a handle. . . . instance handles every dynamic link library or executable file loaded into the address space of a process is identified by an instance handle. the value of the instance handle is actually the virtual address where the file is loaded. an application can get the handle to a module in its address space by passing the name of the module to getmodulehandleo. if null is passed as the name the base address of the process is returned. the lowest kb of the address space are not used so a faulty program that tries to de reference a null pointer gets an access violation. priorities in the win api environment are based on the windows xp scheduling model but not all priority values may be chosen. win api uses four priority classes . idle priority class priority level . normal priority class priority level . high priqrity class priority level . realtime priority class priority level processes are typically members of the normaljpriority class unless the parent of the process was of the idle priority class or another class was specified when createprocess was called. the priority class of a process can be changed with the setpriorityclasso function or by passing of an argument to the start command. for example the command start realtime cbserver.exe would run the cbserver program in the realtimejpriority class. only users with the increase scheduling priority privilege can move a process into the realtime priority xlass. administrators and power users have this privilege by default. chapter windows xp . . . scheduling rule f when a user is running an interactive program the system needs to provide especially good performance for the process. for this reason windows xp has a special scheduling rule for processes in the normal.priority class. windows xp distinguishes between the foreground process that is currently selected on the screen and the background processes that are not currently selected. when a process moves into the foreground windows xp increases the scheduling quantum by some factor typically by . this factor can be changed via the performance option in the system section of the control panel. this increase gives the foreground process three times longer to run before a time sharing preemption occurs. . . . thread priorities a thread starts with an initial priority determined by its class. the priority can be altered by the setthreadpriorityo function. this function takes an argument that specifies a priority relative to the base priority of its class thread priority ldwest base thread priority jelow jjormal base thread priorityjjormal base thread priority above normal base thread priority highest base two other designations are also used to adjust the priority. recall from section . . . that the kernel has two priority classes for the realtime class and for the variable priority class. threadjpriority idle sets the priority to for real time threads and to for variable priority threads. threadjpriority time critical sets the priority to for real time threads and to for variable priority threads. as we discussed in section . . . the kernel adjusts the priority of a thread dynamically depending on whether the thread is i o bound or cpu bound. the win api provides a method to disable this adjustment via setprocesspriorityboost and setthreadpriorityboostq functions. . . . thread synchronization a thread can be created in a suspended state the thread does not execute until another thread makes it eligible via the resumethreado function. the suspendthreado function does the opposite. these functions set a counter so if a thread is suspended twice it must be resumed twice before it can run. to synchronize the concurrent access to shared objects by threads the kernel provides synchronization objects such as semaphores and mutexes. in addition synchronization of threads can be achieved by use of the waitforsingleobjectq and waitformultipleobjectsq functions. another method of synchronization in the win api is the critical section. a critical section is a synchronized region of code that can be executed by only one thread at a time. a thread establishes a critical section by calling i n i t i a l i z e c r i t . programmer interface i c a l s e c t i o n . the application must call e n t e r c r i t i c a l s e c t i o n q hefore entering the critical section and leavecriticalsectiono after exiting the critical section. these two routines guarantee that if multiple threads attempt to enter the critical section concurrently only one thread at a time will be permitted to proceed the others will wait in the e n t e r c r i t i c a l s e c t i o n o routine. the critical section mechanism is faster than using kernel synchronization objects because it does not allocate kernel objects until it first encounters contention for the critical section. . . . fibers a fiber is user mode code that is scheduled according to a user defined scheduling algorithm. a process may have multiple fibers in it just as it may have multiple threads. a major difference between threads and fibers is that whereas threads can execute concurrently only one fiber at a time is permitted to execute even on multiprocessor hardware. this mechanism is included in windows xp to facilitate the porting of those legacy unix applications that were written for a fiber execution model. the system creates a fiber by calling either convertthreadtofiberq or createfiber . the primary difference between these functions is that createfiber does not begin executing the fiber that was created. to begin execution the application must call switchtofibero. the application can terminate a fiber by calling deletefiber . . . . thread pool repeated creation and deletion of threads can be expensive for applications and services that perform small amounts of work in each. the thread pool provides user mode programs with three services a queue to which work requests may be submitted via the queueuserworkltemq api an api that can be used to bind callbacks to waitable handles registerwaitforsingleobject and apis to bind callbacks to timeouts createtimerqueueo and createtimerqueuetimero . the thread pool's goal is to increase performance. threads are relatively expensive and a processor can only be executing one thing at a time no matter how many threads are used. the thread pool attempts to reduce the number of outstanding threads by slightly delaying work requests reusing each thread for many requests while providing enough threads to effectively utilize the machine's cpus. the wait and timer callback apis allow the thread pool to further reduce the number of threads in a process using far fewer threads than would be necessary if a process were to devote one thread to servicing each waitable handle or timeout. . . interprocess communication win api applications handle interprocess communication in several ways. one way is by sharing kernel objects. another way is by passing messages an approach that is particularly popular for windows gui applications. one thread can send a message to another thread or to a window by calling postmessageo postthreadmessageo sendmessageq sendthreadmessageo or sendmessagecallbackq. the difference between posting a mes chapter windows xp sage and sending a message is that the post routines are asynchronous? they return immediately and the calling thread does not know when the message is actually delivered. the send routines are synchronous they block the caller until the message has been delivered and processed. in addition to sending a message a thread can send data with the message. since processes have separate address spaces the data must be copied. the system copies data by calling sendmessageo to send a message of type wm copydata with a copydatastruct data structure that contains the length and address of the data to be transferred. when the message is sent windows xp copies the data to a new block of memory and gives the virtual address of the new block to the receiving process. unlike threads in the bit windows environment every win api thread has its own input queue from which it receives messages. all input is received via messages. this structure is more reliable than the shared input queue of bit windows because with separate queues it is no longer possible for one stuck application to block input to the other applications. if a win api application does not call getmessage to handle events on its input queue the queue fills up and after about five seconds the system marks the application as not responding . . . memory management the win api provides several ways for an application to use memory virtual memory memory mapped files heaps and thread local storage. . . . virtual memory an application calls virtualalloc to reserve or commit virtual memory and virtualfreeo to decommit or release the memory. these functions enable the application to specify the virtual address at which the memory is allocated. they operate on multiples of the memory page size and the starting address of an allocated region must be greater than x . examples of these functions appear in figure . . a process may lock some of its committed pages into physical memory by calling virtuallocko. the maximum number of pages a process can lock allocate mb at the top of our address space void buf virtualalloc oxlqoqcoc memjieserve mem top down pagejreadwrite commit the upper mb of the allocated space virtualalloc buf x x mem commit page readwrite do something with the memory now decommit the memory virtualfree buf x x memj ecommit release all of the allocated address space virtualfree buf mem release figure . code fragments for allocating virtual memory. . programmer interface is unless the process first calls setprocessworkingsetsizeo to increase the maximum working set size. . . . memory mapping files another way for an application to use memory is by memory mapping a file into its address space. memory mapping is also a convenient way for two processes to share memory both processes map the same file into their virtual memory memory mapping is a multistage process as you can see in the example in figure . . if a process wants to map some address space just to share a memory region with another process no file is needed. the process calls createfilemappingo with a file handle of oxffffffff and a particular size. the resulting file mapping object can be shared by inheritance by name lookup or by duplication. . . . heaps heaps provide a third way for applications to use memory. a heap in the win environment is a region of reserved address space. when a win api process is initialized it is created with a mb default heap. since many win api functions use the default heap access to the heap is synchronized to protect the heap's space allocation data structures from being damaged by concurrent updates by multiple threads. win api provides several heap management functions so that a process can allocate and manage a private heap. these functions are heapcreateq heapalloco heaprealloco heapsizeo heapfreeq and heapdestroyc . the win api also provides the heaplocko and heapunlocko functions to enable a thread to gain exclusive access to a heap. unlike virtuallocko these functions perform only synchronization they do not lock pages into physical memory. open the file or create it if it does not exist handle hfile createfile somef ile genericjiead generic.write file sharejread file.share.write null openjvlways file attribute normal null create the file mapping mb in size handle hmap createfilemapping hfile page readwritb sec commit x shm new get a view of the space mapped void buf mapviewoffile hmap filej apj ll.access c x do something with the mapped file now unmap the file unmapviewoffile buf closehandle hmap closehandle hfile figure . code fragments for memory mapping of a file. chapter windows xp reserve a slot for a variable dword var index tlsalloco set it to the value tlssetvalue var.index get the value int var tlsgetvalue var.index release the index tlsfree var.index figure . code for dynamic thread local storage. . . . thread local storage the fourth way for applications to use memory is through a thread local storage mechanism. functions that rely on global or static data typically fail to work properly in a multithreaded environment. for instance the c runtime function strtoko uses a static variable to keep track of its current position while parsing a string. for two concurrent threads to execute s t r t o k correctly they need separate current position variables. the thread local storage mechanism allocates global storage on a per thread basis. it provides both dynamic and static methods of creating thread local storage. the dynamic method is illustrated in figure . . to use a thread local static variable the application declares the variable as follows to ensure that every thread has its own private copy ..declspec thread dword cur pos 