 there are many defenses against computer attacks running the gamut from methodology to technology. the broadest tool available to system designers and users is cryptography. in this section we discuss the details of crypography and its use in computer security. in an isolated computer the operating system can reliably determine the sender and recipient of all interprocess communication since it controls all communication channels in the computer. in a network of computers the . cryptography as a security tool situation is quite different. a networked computer receives bits fivm the wire with no immediate and reliable way of determining what machine or application sent those bits. similarly the computer sends bits onto the network with no way of knowing who might eventually receive them. commonly network addresses are used to infer the potential senders and receivers of network messages. network packets arrive with a source address such as an ip address. and when a computer sends a message it names the intended receiver by specifying a destination address. however for applications where security matters we are asking for trouble if we assume that the source or destination address of a packet reliably determines who sent or received that packet. a rogue computer can send a message with a falsified source address and numerous computers other than the one specified by the destination address can and typically do receive a packet. for example all of the routers on the way to the destination will receive the packet too. how then is an operating system to decide whether to grant a request when it cannot trust the named source of the request? and how is it supposed to provide protection for a request or data when it cannot determine who will receive the response or message contents it sends over the network? it is generally considered infeasible to build a network of any scale in which the source and destination addresses of packets can be trusted in this sense. therefore the only alternative is somehow to eliminate the need to trust the network. this is the job of cryptography. abstractly cryptography is used to constrain the potential senders and or receivers of a message. modern cryptography is based on secrets called keys that are selectively distributed to computers in a network and used to process messages. cryptography enables a recipient of a message to verify that the message was created by some computer possessing a certain key the key is the source of the message. similarly a sender can encode its message so that only a computer with a certain key can decode the message so that the key becomes the destination. unlike network addresses however keys are designed so that it is not computationally feasible to derive them from the messages they were used to generate or from any other public information. thus they provide a much more trustworthy means of constraining senders and receivers of messages. note that cryptography is a field of study unto itself with large and small complexities and subtleties. here we explore the most important aspects of the parts of cryptography that pertain to operating systems. . . encryption because it solves a wide variety of communication security problems encryption is used frequently in many aspects of modern computing. encryption is a means for constraining the possible receivers of a message. an encryption algorithm enables the sender of a message to ensure that only a computer possessing a certain key can read the message. encryption of messages is an ancient practice of course and there have been many encryption algorithms dating back to before caesar. in this section we describe important modern encryption principles and algorithms. figure . shows an example of two users communicating securely over an insecure channel. we refer to this figure throughout the section. note that the chapter security write message m attacker figure . a secure communication over an insecure medium. key exchange can take place directly between the two parties or via a trusted third party that is a certificate authority as discussed in section . . . . an encryption algorithm consists of the following components a set k of keys. a set m of messages. a set c of ciphertexts. a function e k m c . that is for each k e k e k is a function for generating ciphertexts from messages. both e and e k for any k should be efficiently computable functions. a function d k c m . that is for each k e k d k is a function for generating messages from ciphertexts. both d and d k for any k should be efficiently computable functions. an encryption algorithm must provide this essential property given a ciphertext c e c a computer can compute m such that e k m c only if it possesses d k . thus a computer holding d k can decrypt ciphertexts to the plaintexts used to produce them but a computer not holding d k cannot decrypt ciphertexts. since ciphertexts are generally exposed for example sent . cryptography as a security tool on the network it is important that it be infeasible to derive d k from the ciphertexts. there are two main types of encryption algorithms symmetric and asymmetric. we discuss both types in the following sections. . . . symmetric encryption in a symmetric encryption algorithm the same key is used to encrypt and to decrypt. that is e k can be derived from d k and vice versa. therefore the secrecy of e k must be protected to the same extent as that of d k . for the past years or so the most commonly used symmetric encryption algorithm in the united states for civilian applications has been the dataencryption standard des adopted by the national institute of standards and technology nist . des works by taking a bit value and a bit key and performing a series of transformations. these transformations are based on substitution and permutation operations as is generally the case for symmetric encryption transformations. some of the transformations are black box transformations in that their algorithms are hidden. in fact these so called s boxes are classified by the united states government. messages longer than bits are broken into bit chunks and a shorter block is padded to fill out the block. because des works on a chunk of bits at a time is a known as a block cipher. if the same key is used for encrypting an extended amount of data it becomes vulnerable to attack. consider for example that the same source block would result in the same ciphertext if the same key and encryption algorithm were used. therefore the chunks are not just encrypted but also xored with the previous ciphertext block before encryption. this is known as cipher block chaining. des is now considered insecure for many applications because its keys can be exhaustively searched with moderate computing resources. rather than giving up on des though nist created a modification called triple des in which the des algorithm is repeated three times two encryptions and one decryption on the same plaintext using two or three keys for example c e k d k e ki m . when three keys are used the effective key length is bits. triple des is in widespread use today. in nist adopted a new encryption algorithm called the advanced encryption standard aes to replace des. aes is another symmetric block cipher. it can use key lengths of and bits and works on bit blocks. it works by performing to rounds of transformations on a matrix formed from a block. generally the algorithm is compact and efficient. there are several other symmetric block encryption algorithms in use today that bear mentioning. the twofish algorithm is fast compact and easy to implement. it can use a variable key length of up to bits and works on bit blocks. rc can vary in key length number of transformations and block size. because it uses only basic computational operations it can run on a wide variety of cpus. rc is perhaps the most common stream cipher. a stream cipher is designed to encrypt and decrypt a stream of bytes or bits rather than a block. this is useful when the length of a communication would make a block cipher too slow. the key is input into a pseudo random bit generator which is an algorithm that attempts to produce random bits. the output of the generator chapter security when fed a key is a keystream. a keystream is an infinite set of keys that can be vised for the input plaintext stream. rc is used in encrypting steams of data such as in wep the wireless lan protocol. it is also used in communications between web browsers and web servers as we discuss below. unfortunately rc as used in wep ieee standard . has been found to be breakable in a reasonable amount of computer time. in fact rc itself has vulnerabilities. . . . asymmetric encryption in an asymmetric encryption algorithm there are different encryption and decryption keys. here we describe one such algorithm known as rsa after the names of its inventors rivest shamir and adleman. the rsa cipher is a block cipher public key algorithm and is the most widely used asymmetrical algorithm. asymmetrical algorithms based on elliptical curves are gaining ground however because the key length of such an algorithm can be shorter for the same amount of cryptographic strength. it is computationally infeasible to derive d q n from e kc a and so e kc iv need not be kept secret and can be widely disseminated thus e ke n or just kt. is the public key and d kli n or just kj is the private key. a is the product of two large randomly chosen prime numbers p and q for example p andtj are bits each . the encryption algorithm is e kc n m mke mod jv where kl. satisfies kl.kj mod p q . the decryption algorithm is then d kd n c ck modn. an example using small values is shown in figure . . in this example we makep andq . we then calculate n and p l j l . we next select ke relatively prime to and yielding . finally we calculate kd such that kekd mod yielding . we how have our keys the public key kt n and the private key kj n . encrypting the message with the public key results in the message which is then decoded by the receiver via the private key. the use of asymmetric encryption begins with the publication of the public key of the destination. for bidirectional communication the source also must publish its public key. publication can be as simple as handing over an electronic copy of the key or it can be more complex. the private key or secret key must be jealously guarded as anyone holding that key can decrypt any message created by the matching public key. we should note that the seemingly small difference in key use between asymmetric and symmetric cryptography is quite large in practice. asymmetric cryptography is based on mathematical functions rather than transformations making it much more computationally expensive to execute. it is much faster for a computer to encode and decode ciphertext by using the usual symmetric algorithms than by using asymmetric algorithms. why then use an asymmetric algorithm? in truth these algorithms are not used for generalpurpose encryption of large amounts of data. however they are used not only for encryption of small amounts of data but also for authentication confidentiality and key distribution as wre show in the following sections. . . . authentication we have seen that encryption offers a way of constraining the set of possible receivers of a message. constraining the set of potential senders of a message is . cryptography as a security tool write message x encryption key k decryption key k i read figure . encryption and decryption using rsa asymmetric cryptography. called authentication. authentication is thus complementary to encryption. in fact sometimes their functions overlap. consider that an encrypted message can also prove the identity of the sender. for example if d kd n e ke n m produces a valid message then we know that the creator of the message must hold kc. authentication is also useful for proving that a message has not been modified. in this section we discuss authentication as a constraint on possible receivers of a message. note that this sort of authentication is similar to but distinct from user authentication which we discuss in section . . an authentication algorithm consists of the following components a set k of keys. a set m of messages. a set a of authenticators. a function s k m a . that is for each k e k s k is a function for generating authenticators from messages. both s and s k for any k should be efficiently computable functions. chapter security a function v x mxyl true false . that is for each k e k v k is a function for verifying authenticators on messages. both v and v k for any k should be efficiently computable functions. the critical property that an authentication algorithm must possess is this for a message m a computer can generate an authenticator a e a such that v k ni.a true only if it possesses s k . thus a computer holding s k can generate authenticators on messages so that any other computer possessing v k can verify them. however a computer not holding s k cannot generate authenticators on messages that can be verified using v k . since authenticators are generally exposed for example they are sent on the network with the messages themselves it must not be feasible to derive s k from the authenticators. just as there are two types of encryption algorithms there are two main varieties of authentication algorithms. the first step in understanding these algorithms is to explore hash functions. a hash function creates a small fixedsized block of data known as a message digest or hash value from a message. hash functions work by taking a message in n bit blocks and processing the blocks to produce an n bit hash. h must be collision resistant on m that is it must be infeasible to find an m' m such that h m h m' . now if h m h m' we know that ni m i that is we know that the message has not been modified. common message digest functions include md which produces a bit hash and sha l which outputs a bit hash. message digests are useful for detecting changed messages but are not useful as authenticators. for example h m can be sent along with a message but if h is known then someone could modify m and recompute h m and the message modification would not be detected. therefore an authentication algorithm takes the message digest and encrypts it. the first type of authentication algorithm uses symmetric encryption. in a message authentication code mac a cryptographic checksum is generated from the message using a secret key. knowledge of v k and knowledge of s k are equivalent one can be derived from the other so k must be kept secret. a simple example of a mac defines s k m f k h m where is a function that is one way on its first argument that is k cannot be derived from f k h m . because of the collision resistance in the hash function we are reasonably assured that no other message could create the same mac. a suitable verification algorithm is then v k m a f k m a . note that k is needed to compute both s k and v k so anyone able to compute one can compute the other. the second main type of authentication algorithm is a digital signature algorithm and the authenticators thus produced are called digital signatures. in a digital signature algorithm it is computationally infeasible to derive s rs from v kv in particular v is a one way function. thus kv is the public key and ks is the private key. consider as an example the rsa digital signature algorithm. it is similar to the rsa encryption algorithm but the key use is reversed. the digital signature of a message is derived by computing s ks m h m k mod n. the key ks again is a pair d n where n is the product of two large randomlychosen prime numbers p and q. the verification algorithm is then v kv m a ak mod n h m where kv satisfies kvks mod p l q . . cryptography as a security tool if encryption can prove the identity of the sender of a message then why do we need separate authentication algorithms? there are three primary reasons. authentication algorithms generally require fewer computations with the notable exception of rsa digital signatures . over large amounts of plaintext this efficiency can make a huge difference in resource use and the time needed to authenticate a message. an authenticator of a message is almost always shorter than the message and its ciphertext. this improves space use and transmission time efficiency. sometimes we want authentication but not confidentiality. for example a company could provide a software patch and could sign that patch to prove that it came from the company and that it hasn't been modified. authentication is a component of many aspects of security for example it is the core of nonrepudiation which supplies proof that an entity performed an action. a typical example of nonrepudiation involves the filling out of electronic forms as an alternative to the signing of paper contracts. nonrepudiation assures that a person filling out an electronic form cannot deny that he did so. . . . key distribution certainly a good part of the battle between cryptographers those inventing ciphers and cryptanalysts those trying to break them involves keys. with symmetric algorithms both parties need the key and no one else should have it. the delivery of the symmetric key is a huge challenge. sometimes it is performed out of band say via a paper document or a conversation. these methods do not scale well however. also consider the key management challenge. suppose a user wanted to communicate with n other users privately. that user would need jv keys and for more security would need to change those keys frequently. these are the very reasons for efforts to create asymmetric key algorithms. k ot only can the keys be exchanged in public but a given user needs only one private key no matter how many other people she wants to communicate with. there is still the matter of managing a public key per party to be communicated with but since public keys need not be secured simple storage can be used for that key ring. unfortunately even the distribution of public keys requires some care. consider the man in the middle attack shown in figure . . here the person who wants to receive an encrypted message sends out his public key but an attacker also sends her bad public key which matches her private key . the person who wants to send the encrypted message knows no better and so uses the bad key to encrypt the message. the attacker then happily decrypts it. the problem is one of authentication what we need is proof of who or what owns a public key. one way to solve that problem involves the use of digital certificates. a digital certificate is a public key digitally signed by a trusted party. the trusted party receives proof of identification from some entity and certifies that the public key belongs to that entity. but how do we chapter security write message m encryption key kbad decryption i decryption key kbad j algorithm attacker read messagemdecryption keykd figure . a man in the middle attack on asymmetric cryptography. know we can trust the certifier? these certificate authorities have their public keys included within web browsers and other consumers of certificates before they are distributed. these certificate authorities can then vouch for other authorities digitally signing the public keys of these other authorities and so on creating a web of trust. the certificates can be distributed in a standard x. digital certificate format that can be parsed by computer. this scheme is used for secure web communication as we discuss in section . . . . . implementation of cryptography network protocols are typically organized in layers each layer acting as a client to the one below it. that is when one protocol generates a message to send to its protocol peer on another machine it hands its message to the protocol below it in the network protocol stack for delivery to its peer on that machine. for example in an ip network tcp a transport layer protocol acts as a client of ip a network layer protocol tcp packets are passed down to ip for delivery to the tcp peer at the other end of the tcp connection. ip encapsulates the tcp . cryptography as a security tool packet in an ip packet which it similarly passes down to the data link layer t be transmitted across the network to its ip peer on the destination computer. this ip peer then delivers the tcp packet up to the tcp peer on that machine. all in all the iso reference model which has been almost universally adopted as a model for data networking defines seven such protocol layers. you will read more about the iso model of networking in chapter figure . shows a diagram of the model. cryptography can be inserted at almost any layer in the iso model. ssl section . . for example provides security at the transport layer. networklayer security generally has been standardized on ipsec which defines ip packet formats that allow the insertion of authenticators and the encryption of packet contents. it uses symmetric encryption and uses the ike protocol for key exchange. ipsec is becoming widely used as the basis for virtual private networks vpns in which all traffic between two ipsec endpoints is encrypted to make a private network out of one that may otherwise be public. numerous protocols also have been developed for use by applications but then the applications themselves must be coded to implement security. where is cryptographic protection best placed in a protocol stack? in general there is no definitive answer. on the one hand more protocols benefit from protections placed lower in the stack. for example since ip packets encapsulate tcp packets encryption of ip packets using ipsec for example also hides the contents of the encapsulated tcp packets. similarly authenticators on ip packets detect the modification of contained tcp header information. on the other hand protection at lower layers in the protocol stack may give insufficient protection to higher layer protocols. for example an application server that runs over ipsec might be able to authenticate the client computers from which requests are received. however to authenticate a user at a client computer the server may need to use an application level protocol for example the user may be required to type a password. also consider the problem of e mail. e mail delivered via the industry standard smtp protocol is stored and forwarded frequently multiple times before it is delivered. each of these hops could go over a secure or insecure network. for e mail to be secure the e mail message needs to be encrypted so that its security is independent of the transports that carry it. . . an example ssl ssl . is a cryptographic protocol that enables two computers to communicate securely that is so that each can limit the sender and receiver of messages to the other. it is perhaps the most commonly used cryptographic protocol on the internet today since it is the standard protocol by which web browsers communicate securely with web servers. for completeness we should note that ssl was designed by netscape and that it evolved into the industry standard tls protocol. in this discussion we use ssl to mean both ssl and tls. ssl is a complex protocol with many options. here we present only a single variation of it and even then in a very simplified and abstract form so as to maintain focus on its use of cryptographic primitives. what we are about to see is a complex dance in which asymmetric cryptography is used so that a client and server can establish a secure session key that can be used chapter security for symmetric encryption of the session between the two all of this while avoiding man in the middle and replay attacks. for added cryptographic strength the session keys are forgotten once a session is completed. another communication between the two would require generation of new session keys. the ssl protocol is initiated by a client c to communicate securely with a server. prior to the protocol's use the server s is assumed to have obtained a certificate denoted cert from certification authority ca. this certificate is a structure containing the following various attributes attrs of the server such as its unique distinguished name and its common dns name the identity of a public encryption algorithm e for the server the public key kc of this server a validity interval interval during which the certificate should be considered valid a digital signature a on the above information by the ca that is a s kca attrs e ke interval in addition prior to the protocol's use the client is presumed to have obtained the public verification algorithm v ca for ca. in the case of the web the user's browser is shipped from its vendor containing the verification algorithms and public keys of certain certification authorities. the user can add or delete these for certification authorities as she chooses. when c connects to s it sends a byte random value nc to the server which responds with a random value ns of its own plus its certificate cert . the client verifies that v kca attrs e ke interval a true and that the current time is in the validity interval interval. if both of these tests are satisfied the server has proved its identity. then the client generates a random byte premaster secret pms and sends cpms e fcs pms to the server. the server recovers pms d crf cpms . now both the client and the server are in possession of ns and pms and each can compute a shared byte master secret ms f nc itg pms where f is a one way and collision resistant function. only the server and client can compute ms since only they know pms. moreover the dependence of ms on nc and ns ensures that ms is a fresh value that is a session key that has not been used in a previous communication. at this point the client and the server both compute the following keys from the ms a symmetric encryption key kf p for encrypting messages from the client to the server a symmetric encryption key k?p p for encrypting messages from the server to the client a mac generation key ktmac for generating authenticators on messages from the client to the server a mac generation key ktmac for generating authenticators on messages from the server to the client