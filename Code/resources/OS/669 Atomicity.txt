 . atomicity ? in chapter we introduced the concept of an atomic transaction which is a program unit that must be executed atomically. that is either all the operations associated with it are executed to completion or none are performed. when we are dealing with a distributed system ensuring the atomicity of a transaction becomes much more complicated than in a centralized system. this difficulty occurs because several sites may be participating in the execution of a single transaction. the failure of one of these sites or the failure of a communication link connecting the sites may result in erroneous computations. ensuring that the execution of transactions in the distributed system preserves atomicity is the function of the transaction coordinator. each site has its own local transaction coordinator which is responsible for coordinating the execution of all the transactions initiated at that site. for each such transaction the coordinator is responsible for the following starting the execution of the transaction breaking the transaction into a number of subtransactions and distributing these subtransactions to the appropriate sites for execution coordinating the termination of the transaction which may result in the transactions being committed at all sites or aborted at all sites we assume that each local site maintains a log for recovery purposes. . . the two phase commit protocol for atomicity to be ensured all the sites in which a transaction t has executed must agree on the final outcome of the execution. t must either commit at all sites or it must abort at all sites. to ensure this property the transaction coordinator of t must execute a commit protocol. among the simplest and most widely used commit protocols is the two phase commit pc protocol which we discuss next. let tbe a transaction initiated at site s and let the transaction coordinator at si be c . when t completes its execution that is when all the sites at which t has executed inform c that t has completed then c starts the pc protocol. phase . c adds the record prepare t to the log and forces the record onto stable storage. it then sends a prepare t message to all the sites at which t has executed. on receiving the message the transaction manager at that site determines whether it is willing to commit its portion of t. if the answer is no it adds a record no t to the log and then it responds by sending an abort t message to c . if the answer is yes it adds a record ready t to the log and forces all the log records corresponding to t onto stable storage. the transaction manager then replies with a ready t message to c . phase . when c has received responses to the prepare t message from all the sites or when a pre specified interval of time has elapsed since the prepare t message was sent out c can determine whether the transaction chapter distributed coordination t can be committed or aborted. transaction t can be committed if has received a ready t message from all the participating sites. otherwise transaction t must be aborted. depending on the verdict either a record commit t or a record abort t is added to the log and is forced onto stable storage. at this point the fate of the transaction has been sealed. following this the coordinator sends either a commit t or an abort t message to all participating sites. when a site receives that message it records the message in the log. a site at which t has executed can unconditionally abort t at any time prior to its sending the message ready t to the coordinator. the ready t message is in effect a promise by a site to follow the coordinator's order to commit t or to abort t. a site can make such a promise only when the needed information is stored in stable storage. otherwise if the site crashes after sending ready t it may be unable to make good on its promise. since unanimity is required to commit a transaction the fate of t is sealed as soon as at least one site responds with abort t . note that the coordinator site s can decide unilaterally to abort t as it is one of the sites at which t has executed. the final verdict regarding t is determined at the time the coordinator writes that verdict commit or abort to the log and forces it to stable storage. in some implementations of the pc protocol a site sends an acknowledge t message to the coordinator at the end of the second phase of the protocol. when the coordinator has received the acknowledge t message from all the sites it adds the record complete t to the log. . . failure handling in pc we now examine in detail how pc responds to various types of failures. as we shall see one major disadvantage of the pc protocol is that coordinator failure may result in blocking and a decision either to commit or to abort t may have to be postponed until c recovers. . . . failure of a participating site when a participating site sjt recovers from a failure it must examine its log to determine the fate of those transactions that were in the midst of execution when the failure occurred. let tbe one such transaction. how will s deal with t? we consider each of the possible alternatives the log contains a commit t record. in this case the site executes redo t . the log contains an abort t record. in this case the site executes undo t . the log contains a ready t record. in this case the site must consult c to determine the fate of t. if c is up it notifies s regarding whether t committed or aborted. in the former case it executes redo t in the latter case it executes undo t . if c is down s must try to find out the fate of t from other sites. it does so by sending a query status t message to all . atomicity the sites in the system. on receiving such a message a site must censult its log to determine whether t has executed there and if so whether t committed or aborted. it then notifies s t about this outcome. if no site has the appropriate information that is whether t committed or aborted then s k can neither abort nor commit t. the decision concerning t is postponed until sk can obtain the needed information. thus sk must periodically resend the query status t message to the other sites. it does so until a site recovers that contains the needed information. the site at which c resides always has the needed information. the log contains no control records abort commit ready concerning t. the absence of control records implies that sk failed before responding to the prepare t message from c . since the failure of sk means that it could not have sent such a response by our algorithm c must have aborted t. hence sk must execute undo t . . . . failure of the coordinator if the coordinator fails in the midst of the execution of the commit protocol for transaction t then the participating sites must decide on the fate of t. we shall see that in certain cases the participating sites cannot decide whether to commit or abort t and therefore these sites must wait for the recovery of the failed coordinator. if an active site contains a commit t record in its log then t must be committed. if an active site contains an abort t record in its log then t must be aborted. if some active site does not contain a ready t record in its log then the failed coordinator c cannot have decided to commit t. we can draw this conclusion because a site that does not have a ready t record in its log cannot have sent a ready t message to q. however the coordinator may have decided to abort f. rather than wait for c to recover it is preferable to abort t in this case. if none of the preceding cases holds then all the active sites must have a ready t record in their logs but no additional control records such as abort t or commit t . since the coordinator has failed it is impossible to determine whether a decision has been made or if so what that decision is until the coordinator recovers. thus the active sites must wait for c to recover. as long as the fate of t remains in doubt t may continue to hold system resources. for example if locking is used t may hold locks on data at active sites. such a situation is undesirable because hours or days may pass before c is again active. during this time other transactions may be forced to wait for t. as a result data are unavailable not only on the failed site c but on active sites as well. the amount of unavailable data increases as the downtime of c grows. this situation is called the blocking problem because t is blocked pending the recovery of site c . chapter distributed coordination . . . failure of the network ? when a link fails the messages in the process of being routed through the link do not arrive at their destinations intact. from the viewpoint of the sites connected throughout that link the other sites appear to have failed. thus our previous schemes apply here as well. when a number of links fail the network may partition hi this case two possibilities exist. the coordinator and all its participants may remain in one partition in this case the failure has no effect on the commit protocol. alternatively the coordinator and its participants may belong to several partitions in this case messages between the participant and the coordinator are lost reducing the case to a link failure