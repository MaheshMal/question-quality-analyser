 an important aspect of memory management that became unavoidable with paging is the separation of the user's view of memory and the actual physical memory. as we have already seen the user's view of memory is not the same as the actual physical memory. the user's view is mapped onto physical memory. this mapping allows differentiation between logical memory and. physical memory. . . basic method do users think of memory as a linear array of bytes some containing instructions and others containing data? most people would say no. rather users prefer to view memory as a collection of variable sized segments. with no necessary ordering among segments figure . . consider how you think of a program when you are writing it. you think of it as a main program with a set of methods procedures or functions. it may also include various data structures objects arrays stacks variables and so on. each of these modules or data elements is referred to by name. you talk about the stack the math library ''the main program without caring what addresses in memory these elements occupy you are not concerned s. segmentation logical address figure . user's view of a program. with whether the stack is stored before or after the sqrt function. each of these segments is of variable length the length is intrinsically defined by the purpose of the segment in the program. elements within a segment are identified by their offset from the beginning of the segment the first statement of the program the seventh stack frame entry in the stack the fifth instruction of the sqrt and so on. segmentation is a memory management scheme that supports this user view of memory. a logical address space is a collection of segments. each segment has a name and a length. the addresses specify both the segment name and the offset within the segment. the user therefore specifies each address by two quantities a segment name and an offset. contrast this scheme with the paging scheme in which the user specifies only a single address which is partitioned by the hardware into a page number and an offset all invisible to the programmer. for simplicity of implementation segments are numbered and are referred to by a segment number rather than by a segment name. tluis a logical address consists of a two tuple segment number offset . normally the user program is compiled and the compiler automatically constructs segments reflecting the input program. a c compiler might create separate segments for the following . the code . global variables . the heap from which memory is allocated . the stacks used by each thread . the standard c library chapter emery libraries that are linked in during compile time might be assigned separate segments. the loader would take all these segments and assign them segment numbers. . . hardware although the user can now refer to objects in the program by a two dimensional address the actual physical memory is still of course a one dimensional sequence of bytes. thus we must define an implementation to map twodimensional user defined addresses into one dimensional physical addresses. this .mapping is effected by a segment table. each entry in the segment table has a segment base and a segment limit. the segment base contains the starting physical address where the segment resides in memory whereas the segment limit specifies the length of the segment. the use of a segment table is illustrated in figure . . a logical address consists of two parts a segment number s and an offset into that segment d. the segment number is used as an index to the segment table. the offset d of the logical address must be between and the segment limit. if it is not we trap to the operating system logical addressing attempt beyond end of segment . when an offset is legal it is added to the segment base to produce the address in physical memory of the desired byte. the segment table is thus essentially an array of base limit register pairs. as an example consider the situation shown in figure . . we have five segments numbered from through . the segments are stored in physical memory as shown. the segment table has a separate entry for each segment giving the beginning address of the segment in physical memory or base and the length of that segment or limit . for example segment is bytes long and begins at location . thus a reference to byte of segment is mapped s limit base segment s d table no trap addressing error physical memory figure . segmentation hardware. . example the intel pentium sjd'outins segment q h limit base i i i segment ' c segment table secment logical address space iegment segment i physical memory figure . exampie of segmentation. onto location . a reference to segment r byte is mapped to the base of segment . a reference to byte of segment would result in a trap to the operating system as this segment is only bytes long. . example the intel pentium both paging and segmentation have advantages and disadvantages. in fact some architectures provide both. in this section we discuss the intel pentium architecture which supports both pure segmentation and segmentation with paging. we do not give a complete description of the memory management structure of the pentium in this text. rather we present the major ideas on which it is based. we conclude our discussion with an overview of linux address translation on pentium systems. in pentium systems the cpu generates logical addresses which are given to the segmentation unit. the segmentation unit produces a linear address for each logical address. the linear address is then given to the paging unit which in turn generates the physical address in main memory. thus the segmentation and paging units form the equivalent of the memory management unit vimu . this scheme is shown in figure . . . . pentium segmentation the pentium architecture allows a segment to be as large as gb and the maximum number of segments per process is kb. the logical address space chapter main memory logical linear . physical address j segmeofato.i address n? g og j address mi . lti't i figure . logical to physical address translation in the pentium. of a process is divided into two partitions. the first partition consists of up to kb segments that are private to that process. the second partition consists of up to kb segments that are shared among all the processes. information about the first partition is kept in the local descriptor table ldt information about the second partition is kept in the global descriptor table gdt . each entry in the ldt and gdt consists of an byte segment descriptor with detailed information about a particular segment including the base location and limit of that segment. the logical address is a pair selector offset where the selector is a bit number v in which s designates the segment number g indicates whether the segment is in the gdt or ldt and p deals with protection. the offset is a bit number specifying the location of the byte or word within the segment in question. the machine has six segment registers allowing six segments to be addressed at any one time by a process. it also has six byte microprogram registers to hold the corresponding descriptors from either the ldt or gdt. this cache lets the pentium avoid having to read the descriptor from memory for every memory reference. the linear address on the pentium is bits long and is formed as follows. the segment register points to the appropriate entry in the ldt or gdt. the base and limit information about the segment in question is used to generate a linear address. first the limit is used to check for address validity. if the address is not valid a memory fault is generated resulting in a trap to the operating system. if it is valid then the value of the offset is added to the value of the base resulting in a bit linear address. this is shown in figure . . in the following section we discuss how the paging unit turns this linear address into a physical address. . . pentium paging the pentium architecture allows a page size of either kb or mb. for kb pages the pentium uses a two level paging scheme in which the division of the bit linear address is as follows page number page offset the address translation scheme for this architecture is similar to the scheme shown in figure . . the intel pentium address translation is shown in more . example the intel pentium logical address selector offset descriptor table bit linear address figure . intel pentium segmentation. detail in figure . . the ten high order bits reference an entry in the outermost page table which the pentium terms the page directory. the cr register points to the page directory for the current process. the page directory entry points to an inner page table that is indexed by the contents of the innermost ten bits in the linear address. finally the low order bits refer to the offset in the kb page pointed to in the page table. one entry in the page directory is the page size flag which if set indicates that the size of the page frame is mb and not the standard kb. if this flag is set the page directory points directly to the mb page frame bypassing the inner page table and the low order bits in the linear address refer to the offset in the mb page frame. to improve the efficiency of physical memory use intel pentium page tables can be swapped to disk. in this case an invalid bit is used in the page directory entry to indicate whether the table to which the entry is pointing is in memory or on disk. if the table is on disk the operating system can use the other bits to specify the disk location of the table the table then can be brought into memory on demand. . . linux on pentium systems as an illustration consider the linux operating system running on the intel pentium architecture. because linux is designed to run on a variety of processors many of which may provide only limited support for segmentation linux does not rely on segmentation and uses it minimally on the pentium linux uses only six segments . a segment for kernel code . a segment for kernel data . a segment for user code . a segment for user data . a task state segment tss . a default ldt segment chapter main memory iogica! address age directory page table offset labfe . directory cr register page page directory offsei figure . paging in the pentium architecture. the segments for user code and user data are shared by all processes running in user mode. this is possible because all processes use the same logical address space and all segment descriptors are stored in the global descriptor table gdt . furthermore each process has its own task state segment tss and the descriptor for this segment is stored in the gdt. the tss is used to store the hardware context of each process during context switches. the default ldt segment is normally shared by all processes and is usually not used. however if a process requires its own ldt it can create one and use that instead of the default ldt. as noted each segment selector includes a bit field for protection. thus the pentium allows four levels of protection. of these four levels linux only recognizes two user mode and kernel mode. although the pentium uses a two level paging model linux is designed to run on a variety of hardware platforms many of which are bit platforms where two level paging is not plausible. therefore linux has adopted a threelevel paging strategy that works well for both bit and bit architectures. the linear address in linux is broken into the following four parts globr rjiiectory j duecto'y ticfigure . highlights the three level paging model in linux. the number of bits in each part of the linear address varies according to architecture. however as described earlier in this section the pentium architecture only uses a two level paging model. how then does linux apply its three level model on the pentium in this situation the size of the middle directory is zero bits effectively bypassing the middle directory