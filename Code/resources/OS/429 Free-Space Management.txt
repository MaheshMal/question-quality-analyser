 for instance the version of the unix operating system from sun microsystems was changed in to improve performance in the file system allocation algorithm. the performance measurements indicated that the maximum disk throughput on a typical workstation a m ps sparcstationl took percent of the cpu and produced a disk bandwidth of only . mb per second. to improve performance sun made changes to allocate space in clusters of kb whenever possible kb was the maximum size of a dma transfer on sun systems at that time . this allocation reduced external fragmentation and thus seek and latency times. in addition the disk reading routines were optimized to read in these large clusters. the inode structure was left unchanged. as a result of these changes plus the use of read ahead and free behind discussed in section . . percent less cpu was used and throughput substantially improved. many other optimizations are in use. given the disparity between cpu speed and disk speed it is not unreasonable to add thousands of extra instructions to the operating system to save just a fewr disk head movements. furthermore this disparity is increasing over time to the point where hundreds of thousands of instructions reasonably could be used to optimize head movements. . free space management since disk space is limited we need to reuse the space from deleted files for new files if possible. write once optical disks only allow one write to any given sector and thus such reuse is not physically possible. to keep track of free disk space the system maintains a free space list. the free space list records all free disk blocks those not allocated to some file or directory. to create a file we search the free space list for the required amount of space and allocate that space to the new file. this space is then removed from the free space list. when a file is deleted its disk space is added to the free space list. the free space list despite its name might not be implemented as a list as we discuss next. . . bit vector frequently the free space list is implemented as a bit map or bit vector. each block is represented by bit. if the block is free the bit is if the block is allocated the bit is . for example consider a disk where blocks and are free and the rest of the blocks are allocated. the free space bit map would be ... the main advantage of this approach is its relative simplicity and its efficiency in finding the first free block or n consecutive free blocks on the disk indeed many computers supply bit manipulation instructions that can be used effectively for that purpose. for example the intel family starting with the and the motorola family starting with the processors that have powered pcs and macintosh systems respectively have instructions that return the offset in a word of the first bit with the value . one technique chapter file system implementation for finding the first free block on a system that uses a bit vector to allocate disk space is to sequentially check each word in the bit map to see whether that value is not since a valued word has all bits and represents a set of allocated blocks. the first non word is scanned for the first bit which is the location of the first free block. the calculation of the block number is number of bits per word x number of value words offset of first bit. again we see hardware features driving software functionality. unfortunately bit vectors are inefficient unless the entire vector is kept in main memory and is written to disk occasionally for recovery needs . keeping it in main memory is possible for smaller disks but not necessarily for larger ones. a . gb disk with byte blocks would need a bit map of over kb to track its free blocks although clustering the blocks in groups of four reduces this number to over kb per disk. a gb disk with kb blocks requires over mb to store its bit map. . . linked list another approach to free space management is to link together all the free disk blocks keeping a pointer to the first free block in a special location on the disk and caching it in memory. this first block contains a pointer to the next free disk block and so on. in our earlier example section . . we would keep a pointer to block as the first free block. block would contain a pointer to block which would point to block which would point to block which would point to block and so on figure . . however this scheme is not efficient to traverse the list we must read each block which requires substantial i o time. fortunately traversing the free list is not a frequent action. usually the free space list head figure . linked free space list on disk