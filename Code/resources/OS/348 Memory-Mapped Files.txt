 consider a sequential read of a file on disk using the standard system calls openq r e a d o and w r i t e q . each file access requires a system call and disk access. alternatively we can use the virtual memory techniques discussed so far to treat file i o as routine memory accesses. this approach known as memory mapping a file allows a part of the virtual address space to be logically associated with the file. . . basic mechanism memory mapping a file is accomplished by mapping a disk block to a page or pages in memory. initial access to the file proceeds through ordinary demand paging resulting in a page fault. however a page sized portion of the file is read from the file system into a physical page some systems may opt . memory mapped files to read in more than a page sized chunk of memory at a time . subsequent reads and writes to the file are handled as routine memory accesses thereby simplifying file access and usage by allowing the system to manipulate files through memory rather than incurring the overhead of using the readq and w r i t e o system calls. note that writes to the file mapped in memory are not necessarily immediate synchronous writes to the file on disk. some systems may choose to update the physical file when the operating system periodically checks whether the page in memory has been modified. when the file is closed all the memory mapped data are written back to disk and removed from the virtual memory of the process. some operating systems provide memory mapping only through a specific system call and use the standard system calls to perform all other file i o. however some systems choose to memory map a file regardless of whether the file was specified as memory mapped. let's take solaris as an example. if a file is specified as memory mapped using the mmapo system call solaris maps the file into the address space of the process. if a file is opened and accessed using ordinary system calls such as openo r e a d and w r i t e solaris still memory maps the file however the file is mapped to the kernel address space. regardless of how the file is opened then solaris treats all file i o as memory mapped allowing file access to take place via the efficient memory subsystem. multiple processes may be allowed to map the same file concurrently to allow sharing of data. writes by any of the processes modify the data in virtual memory and can be seen by all others that map the same section of r i i r r . j i i i i i i i i i i l process a i i process b virtual memory virtual memory physical memory i disk file figure . memory mapped files. chapter virtual memory the file. given our earlier discussions of virtual memory it should be clear how the sharing of memory mapped sections of memory is implemented the virtual memory map of each sharing process points to the same page of physical memory the page that holds a copy of the disk block. this memory sharing is illustrated in figure . . the memory mapping system calls can also support copy on write functionality allowing processes to share a file in read only mode but to have their own copies of any data they modify. so that access to the shared data is coordinated the processes involved might use one of the mechanisms for achieving mutual exclusion described in chapter . in many ways the sharing of memory mapped files is similar to shared memory as described in section . . . not all systems use the same mechanism for both on unix and linux systems for example memory mapping is accomplished with the mmap system call whereas shared memory is achieved with the posjx compliant shmgeto and shmato systems calls section . . . on windows nt and xp systems however shared memory is accomplished by memory mapping files. on these systems processes can communicate using shared memory by having the communicating processes memory map the same file into their virtual address spaces. the memorymapped file serves as the region of shared meniory between the communicating processes figure . . in the following section we illustrate support in the win api for shared memory using memory mapped files. . . shared memory in the win api the general outline for creating a region of shared memory using memorymapped files in the win api involves first creating a file mapping for the file to be mapped and then establishing a view of the mapped file in a process's virtual address space. a second process can then open and create a view of the mapped file in its virtual address space. the mapped file represents the shared memory object that will enable communication to take place between the processes. we next illustrate these steps in more detail. in this example a producer process first creates a shared memory object using the memory mapping features available in the win api. the producer then writes a message process process shared .. memory mapped riet?nery v file shared memoryv shiaped rnemdry figure . shared memory in windows using memory mapped i o. . memory mapped files to shared memory. after that a consumer process opens a mapping tp the shared memory object and reads the message written by the consumer. to establish a memory mapped file a process first opens the file to be mapped with the createfileo function which returns a handle to the opened file. the process then creates a mapping of this file handle using the createfilemappingo function. once the file mapping is established the process then establishes a view of the mapped file in its virtual address space with the mapviewof filec function. the view of the mapped file represents the portion of the file being mapped in the virtual address space of the process the entire file or only a portion of it may be mapped. we illustrate this ir.clude windows . h irdude stdio.h inn mainfint argc char argv i handle hfile hkapfile lpvcid lpmapaddress hfile createfile temp txt file name generic read generic write read write access no sharing of the file null default security open always . open new or existing file file attributejsiormal routine file attributes null . no file template hkapfile createfilemapping hfile file handle null . default security page readwrite read write access o mapped pages map entire file text sharedobject named shared memory object lpmapaddress mapviewoffile hmapfile mapped object handle file map allj ccess read write access mapped view of entire file . write to shared memory sprintf lpmapaddress shared memory message unmapviewoffile lpmapaddress closehandle hfile closehandle hmapfile figure . producer writing to shared memory using the win api. chapter virtual memory sequence in the program shown in figure . . we eliminate much of the error checking for code brevity. the call to createfilemapping o creates a named shared memory object calledsharedobject. the consumer process will communicate using this shared memory segment by creating a mapping to the same named object. the producer then creates a view of the memory mapped file in its virtual address space. by passing the last three parameters the value it indicates that the mapped view is the entire file. it could instead have passed values specifying an offset and size thus creating a view containing only a subsection of the file. it is important to note that the entire mapping may not be loaded into memory when the mapping is established. rather the mapped file may be demand paged thus bringing pages into memory only as they are accessed. the mapviewdf f i l e function returns a pointer to the shared memory object any accesses to this memory location are thus accesses to the memory mapped file. in this instance the producer process writes the message shared memory message to shared memory. a program illustrating how the consumer process establishes a view of the named shared memory object is shown in figure . . this program is somewhat simpler than the one shown in figure . as all that is necessary is for the process to create a mapping to the existing named shared memory object. the consumer process must also create a view of the mapped file just as the producer process did in the program in figure . . the consumer then include windows.h include stdio.h int main int argc char argv handle hmapfile lpvoid lpmapaddress hmapfile openfilemapping filejcap fl.llj ccess r w access false no inheritance text sharedobject nane of mapped file object lpmapaddress mapviev.'offile hmapfile mapped object handle file ap all access read write access mapped view of entire file read fron shared memory printf read message s ipmapaddress unmapviewoffile ipmapaddress closehandle hmapfile figure . consumer reading from shared memory using the win api