 as computer systems have become more sophisticated and pervasive in their applications the need to protect their integrity has also grown. protection was originally conceived as an adjunct to multiprogramming operating systems so that untrustworthy users might safely share a common logical name space such as a directory of files or share a common physical name space such as memory. modern protection concepts have evolved to increase the reliability of any complex system that makes use of shared resources. we need to provide protection for several reasons. the most obvious is the need to prevent mischievous intentional violation of an access restriction chapter protection by a user. of more general importance however is the need to ensure that each program component active in a system uses system resources only in ways consistent with stated policies. this requirement is an absolute one for a reliable system. protection can improve reliability by detecting latent errors at the interfaces between component subsystems. early detection of interface errors can often prevent contamination of a healthy subsystem by a malfunctioning subsystem. an unprotected resource cannot defend against use or misuse by an unauthorized or incompetent user. a protection oriented system provicies means to distinguish between authorized and unauthorized usage. the role of protection in a computer system is to provide a mechanism for the enforcement of the policies governing resource use. these policies can be established in a variety of ways. some are fixed in the design of the system while others are formulated by the management of a system. still others are defined by the individual users to protect their own files and programs. a protection system must have the flexibility to enforce a variety of policies. policies for resource use may vary by application and they may change over time. for these reasons protection is no longer the concern solely of the designer of an operating system. the application programmer needs to use protection mechanisms as well to guard resources created and supported by an application subsystem against misuse. in this chapter we describe the protection m.echanisms the operating system should provide so that application designers can use them in designing their own protection software. note that mechanisms are distinct horn policies. mechanisms determine how something will be done policies decide what will be done. the separation of policy and mechanism is important for flexibility. policies are likely to change from place to place or time to time. in the worst case every change in policy would require a change in the underlying mechanism. using general mechanisms enables us to avoid such a situation. 