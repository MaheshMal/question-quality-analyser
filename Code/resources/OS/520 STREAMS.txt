 unix system v has an interesting mechanism called streams that enables an application to assemble pipelines of driver code dynamically. a stream is a full duplex connection between a device driver and a user level process. it consists of a stream head that interfaces with the user process a driver end that controls the device and zero or more stream modules between them. the stream head the driver end and each module contain a pair of queues a read queue and a write queue. message passing is used to transfer data between queues. the streams structure is shown in figure . . modules provide the functionality of streams processing they are pushed onto a stream by use of the i o c t l q system call. for example a process can. . streams modules iidrivmertdli ideviee figure . the streams structure. open a serial port device via a stream and can push on a module to handle input editing. because messages are exchanged between queues in adjacent modules a queue in one module may overflow an adjacent queue. to prevent this from occurring a queue may support flow control. without flow control a queue accepts all messages and immediately sends them on to the queue in the adjacent module without buffering them. a queue supporting flow control buffers messages and does not accept messages without sufficient buffer space this process involves exchanges of control messages between queues in adjacent modules. a user process writes data to a device using either the write or putmsgo system call. the w r i t e system call writes raw data to the stream whereas putmsgo allows the user process to specify a message. regardless of the system call used by the user process the stream head copies the data into a message and delivers it to the queue for the next module in line. this copying of messages continues until the message is copied to the driver end and hence the device. similarly the user process reads data from the stream head using either the readq or getmsgo system call. if read is used the stream head gets a message from its adjacent queue and returns ordinary data an unstructured byte stream to the process. if getmsgo is used a message is returned to the process. streams i o is asynchronous or nonblocking except when the user process communicates with the stream head. when writing to the stream the user process will block assuming the next queue uses flow control until there is room to copy the message. likewise the user process will block when reading from the stream until data are available. chapter i o systems the driver end is similar to a stream head or a module in that it has'a read and write queue. however the driver end must respond to interrupts such as one triggered when a frame is ready to be read from a network. unlike the stream head which may block if it is unable to copy a message to the next queue in line the driver end must handle all incoming data. drivers must support flow control as well. however if a device's buffer is full the device typically resorts to dropping incoming messages. consider a network card whose input buffer is full. the network card must simply drop further messages until there is ample buffer space to store incoming messages. the benefit of using streams is that it provides a framework for a modular and incremental approach to writing device drivers and network protocols. modules may be used by different streams and hence by different devices. for example a networking module may be used by both an ethernet network card and a token ring network card. furthermore rather than treating character device i o as an unstructured byte stream streams allows support for message boundaries and control information between modules. support for streams is widespread among most unix variants and it is the preferred method for writing protocols and device drivers. for example system v unix and solaris implement the socket mechanism using streams. 