 y do acquire lock critical section releaselock remainder section while true figure . solution to the critical section problem using locks. . synchronization hardware we have just described one software based solution to the critical section problem. in general we can state that any solution to the critical section problem requires a simple tool a lock. race conditions are prevented by requiring that critical regions be protected by locks. that is a process must acquire a lock before entering a critical section it releases the lock when it exits the critical section. this is illustrated in figure . . in the following discussions we explore several more solutions to the critical section problem using techniques ranging from hardware to softwarebased apis available to application programmers. all these solutions are based on the premise of locking however as we shall see the design of such locks can be quite sophisticated. hardware features can make any programming task easier and improve system efficiency. in this section we present some simple hardware instructions that are available on many systems and show how they can be used effectively in solving the critical section problem. the critical section problem could be solved simply in a uniprocessor environment if we could prevent interrupts from occurring while a shared variable was being modified. in this manner we could be sure that the current sequence of instructions would be allowed to execute in order without preemption. no other instructions would be run so no unexpected modifications could be made to the shared variable. this is the approach taken by nonpreemptive kernels. unfortunately this solution is not as feasible in a multiprocessor environment. disabling interrupts on a multiprocessor can be time consuming as the boolean testandset boolean target boolean rv target target true return rv figure . the definition of the testandset instruction. chapter process synchronization do while testandsetlock lock do nothing critical section lock false remainder section while true figure . mutual exclusion implementation with testands et . message is passed to all the processors. this message passing delays entry into each critical section and system efficiency decreases. also consider the effect on a system's clock if the clock is kept updated by interrupts. many modern computer systems therefore provide special hardware instructions that allow us either to test and modify the content of a word or to swap the contents of two words atomically that is as one uninterruptible unit. we can use these special instructions to solve the critical section problem in a relatively simple manner. rather than discussing one specific instruction for one specific machine we abstract the main concepts behind these types of instructions. the testandset instruction can be defined as shown in figure . . the important characteristic is that this instruction is executed atomically. thus if two testandset c instructions are executed simultaneously each on a different cpu they will be executed sequentially in some arbitrary order. if the machine supports the testandset instruction then we can implement mutual exclusion by declaring a boolean variable lock initialized to f a l s e . the structure of process p is shown in figure . . the swapo instruction in contrast to the testandset instruction operates on the contents of two words it is defined as shown in figure . . like the testandset instruction it is executed atomically. if the machine supports the swapo instruction then mutual exclusion can be provided as follows. a global boolean variable lock is declared and is initialized to f a l s e . in addition each process has a local boolean variable key. the structure of process p is shown in figure . . although these algorithms satisfy the mutual exclusion requirement they do not satisfy the bounded waiting requirement. in figure . we present void swap boolean a boolean b boolean temp a a b b temp figure . the definition of the swap instruction. . synchronization hardware do key true while key true swap lock key critical section lock false remainder section jwhile true figure . mutual exclusion implementation with the swapo instruction. another algorithm using the testandseto instruction that satisfies all the critical section requirements. the common data structures are boolean waiting n boolean lock these data structures are initialized to false. to prove that the mutualexclusion requirement is met we note that process p can enter its critical section only if either waiting i false or key false. the value of key can become false only if the testandseto is executed. the first process to execute the testandset will find key false all others must do waiting i true key true while waiting i key key testandset lock waiting i false critical section j i n while ! i scsc !waiting j j j n if j i lock false else waiting j false remainder section while true figure . bounded waiting mutual exclusion with test a n d s et o . chapter process synchronization wait. the variable waiting i can become false only if another process leaves its critical section only one waiting i is set to false maintaining the mutual exclusion requirement. to prove that the progress requirement is met we note that the arguments presented for mutual exclusion also apply here since a process exiting the critical section either sets lock to false or sets waiting j to false. both allow a process that is waiting to enter its critical section to proceed. to prove that the bounded waiting requirement is met we note that when a process leaves its critical section it scans the array waiting in the cyclic ordering z' i ... n ... i . it designates the first process in this ordering that is in the entry section waiting j true as the next one to enter the critical section. any process waiting to enter its critical section will thus do so within n turns. unfortunately for hardware designers implementing atomic testandsetq instructions on multiprocessors is not a trivial task. such implementations are discussed in books on computer architecture