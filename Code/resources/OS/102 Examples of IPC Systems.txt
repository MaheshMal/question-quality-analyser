 . . an example posix shared memory several ipc mechanisms are available for posix systems including shared memory and message passing. here we explore the posix api for shared memory. a process must first create a shared memory segment using the shmget system call shmget is derived from shared memory get . the following example illustrates the use of shmget segment id shmget ipcjprivate size sjrusr sjvvusr this first parameter specifies the key or identifier of the shared memory segment. if this is set to ipc private a new shared memory segment is created. the second parameter specifies the size in bytes of the shared memory segment. finally the third parameter identifies the mode which indicates how the shared memory segment is to be used that is for reading writing or both. by setting the mode to sjrusr sjvvusr we are indicating that the owner may read or write to the shared memory segment. a successful call to shmget returns an integer identifier for the shared memory segment. other processes that want to use this region of shared memory must specify this identifier. processes that wish to access a shared memory segment must attach it to their address space using the shmat shared memory attach system call. the call to shmat expects three parameters as well. the first is the integer identifier of the shared memory segment being attached and the second is a pointer location in memory indicating where the shared memory will be attached. if we pass a value of null the operating system selects the location on the user's behalf. the third parameter identifies a flag that allows the sharedmemory region to be attached in read only or read write mode by passing a parameter of we allow both reads and writes to the shared region. the third parameter identifies a mode flag. if set the mode flag allows the shared memory region to be attached in read only mode if set to the flag allows both reads and writes to the shared region. we attach a region of shared memory using shmat as follows shared memory char shmat id null if successful shmat returns a pointer to the beginning location in memory where the shared memory region has been attached. once the region of shared memory is attached to a process's address space the process can access the shared memory as a routine memory access using the pointer returned from shmat . in this example shmat returns a pointer to a character string. thus we could write to the shared memory region as follows sprintf sharedjnemory writing to shared memory other processes sharing this segment would see the updates to the sharedmemory segment. typically a process using an existing shared memory segment first attaches the shared memory region to its address space and then accesses and possibly updates the region of shared memory. when a process no longer requires access to the shared memory segment it detaches the segment from its address chapter processes include stdio.h include sys shm.h include sys stat. h int main the identifier for the shared memory segment int segment id a pointer to the shared memory segment char shared memory the size in bytes of the shared memory segment const int size allocate a shared memory segment segmented shmget ipc private size s irusr s iwusr attach the shared memory segment shared.memory char shmat segment id null write a message to the shared memory segment sprint f shared memory hi there! now print out the string from shared memory printf s n shared memory now detach the shared memory segment shmdt shareclmemory now remove the shared memory segment shmctl segment id ipc rmid null return figure . c program illustrating posix shared memory api. space. to detach a region of shared memory the process can pass the pointer of the shared memory region to the shmdt system call as follows shmdt shared memory finally a shared memory segment can be removed from the system with the shmctl system call which is passed the identifier of the shared segment along with the flag ipcjrmid. the program shown in figure . illustrates the posix shared memory apidiscussed above. this program creates a byte shared memory segment. once the region of shared memory is attached the process writes the message hi there! to shared memory. after outputting the contents of the updated memory it detaches and removes the shared memory region. we provide further exercises using the posix shared memory api in the programming exercises at the end of this chapter. . examples of ipc systems . . an example mach ? as an example of a message based operating system we next consider the mach operating system developed at carnegie mellon university. we introduced mach in chapter as part of the mac os x operating system. the mach kernel supports the creation and destruction of multiple tasks which are similar to processes but have multiple threads of control. most communication in mach including most of the system calls and all intertask information is carried out by messages. messages are sent to and received from mailboxes called ports in mach. even system calls are made by messages. when a task is created two special mailboxes the kernel mailbox and the notify mailbox are also created. the kernel mailbox is used by the kernel to communicate with the task. the kernel sends notification of event occurrences to the notify port. only three system calls are needed for message transfer. the msg send call sends a message to a mailbox. a message is received via msg receive . remote procedure calls rpcs are executed via msg rpc which sends a message and waits for exactly one return message from the sender. in this way the rpc models a typical subroutine procedure call but can work between systems hence the term remote. the port allocate system call creates a new mailbox and allocates space for its queue of messages. the maximum size of the message queue defaults to eight messages. the task that creates the mailbox is that mailbox's owner. the owner is also allowed to receive from the mailbox. only one task at a time can either own or receive from a mailbox but these rights can be sent to other tasks if desired. the mailbox has an initially empty queue of messages. as messages are sent to the mailbox the messages are copied into the mailbox. all messages have the same priority. mach guarantees that multiple messages from the same sender are queued in first in first out fifo order but does not guarantee an absolute ordering. for instance messages from two senders may be queued in any order. the messages themselves consist of a fixed length header followed by a variable length data portion. the header indicates the length of the message and includes two mailbox names. one mailbox name is the mailbox to which the message is being sent. commonly the sending thread expects a reply so the mailbox name of the sender is passed on to the receiving task which can use it as a return address. the variable part of a message is a list of typed data items. each entry in the list has a type size and value. the type of the objects specified in the message is important since objects defined by the operating system such as ownership or receive access rights task states and memory segments may be sent in messages. the send and receive operations themselves are flexible. for instance when a message is sent to a mailbox the mailbox may be full. if the mailbox is not full the message is copied to the mailbox and the sending thread continues. if the mailbox is full the sending thread has four options . wait indefinitely until there is room in the mailbox. . wait at most n milliseconds. chapter processes . do not wait at all but rather return immediately. . temporarily cache a message. one message can be given to the operating system to keep even though the mailbox to which it is being sent is full. when the message can be put in the mailbox a message is sent back to the sender only one such message to a full mailbox can be pending at any time for a given sending thread. the final option is meant for server tasks such as a line printer driver. after finishing a request such tasks may need to send a one time reply to the task that had requested service but they must also continue with other service requests even if the reply mailbox for a client is full. the receive operation must specify the mailbox or mailbox set from which a message is to be received a mailbox set is a collection of mailboxes as declared by the task which can be grouped together and treated as one mailbox for the purposes of the task. threads in a task can receive only from a mailbox or mailbox set for which the task has receive access. a port status system call returns the number of messages in a given mailbox. the receive operation attempts to receive from any mailbox in a mailbox set or a specific named mailbox. if no message is waiting to be received the receiving thread can either wait at most n milliseconds or not wait at all. the mach system was especially designed for distributed systems which we discuss in chapters through but mach is also suitable for singleprocessor systems as evidenced by its inclusion in the mac os x system. the major problem with message systems has generally been poor performance caused by double copying of messages the message is copied first from the sender to the mailbox and then from the mailbox to the receiver. the mach message system attempts to avoid double copy operations by using virtual memory management techniques chapter . essentially mach maps the address space containing the sender's message into the receiver's address space. the message itself is never actually copied. this message management technique provides a large performance boost but works for only intrasystem messages. the mach operating system is discussed in an extra chapter posted on our website. . . an example windows xp the windows xp operating system is an example of modern design that employs modularity to increase functionality and decrease the time needed to implement new features. windows xp provides support for multiple operating environments or subsystems with which application programs communicate via a message passing mechanism. the application programs can be considered clients of the windows xp subsystem server. the message passing facility in windows xp is called the local procedurecall lpc facility. the lpc in windows xp communicates between two processes on the same machine. it is similar to the standard rpc mechanism that is widely used but it is optimized for and specific to windows xp. like mach windows xp uses a port object to establish and maintain a connection between two processes. every client that calls a subsystem needs a communication channel which is provided by a port object and is never inherited. windows xp uses two types of ports connection ports and communication ports. they . examples of ipc systems are really the same but are given different names according to how they are used. connection ports are named objects and are visible to all processes sthey give applications a way to set up communication channels chapter . the communication works as follows the client opens a handle to the subsystem's connection port object. the client sends a connection request. the server creates two private communication ports and returns the handle to one of them to the client. the client and server use the corresponding port handle to send messages or callbacks and to listen for replies. windows xp uses two types of message passing techniques over a port that the client specifies when it establishes the channel. the simplest which is used for small messages uses the port's message queue as intermediate storage and copies the message from one process to the other. under this method messages of up to bytes can be sent. if a client needs to send a larger message it passes the message through a section object which sets up a region of shared memory. the client has to decide when it sets up the channel whether or not it will need to send a large message. if the client determines that it does want to send large messages it asks for a section object to be created. similarly if the server decides that replies will be large it creates a section object. so that the section object can be used a small message is sent that contains a pointer and size information about the section object. this method is more complicated than the first method but it avoids data copying. in both cases a callback mechanism can be used when either the client or the server cannot respond immediately to a request. the callback mechanism allows them to perform asynchronous message handling. the structure of local procedure calls in windows xp is shown in figure . . it is important to note that the lpc facility in windows xp is not part of the win api and hence is not visible to the application programmer. rather client server connectior request connection handle port handle client communication port server handle communication port shared section object bytes figure . local procedure calls in windows xp. chapter processes applications using the win api invoke standard remote procedure calls. when the rpc is being invoked on a process on the same system the rpc is indirectly handled through a local procedure call. lpcs are also used in a few other functions that are part of the win api. . communication in client server systems in section . we described how processes can communicate using shared memory and message passing. these techniques can be used for communication in client server systems . . as well. in this section we explore three other strategies for communication in client server systems sockets remote procedure calls rpcs and java's remote method invocation rmi . . . sockets a socket is defined as an endpoint for communication. a pair of processes communicating over a network employ a pair of sockets one for each process. a socket is identified by an ip address concatenated with a port number. in general sockets use a client server architecture. the server waits for incoming client requests by listening to a specified port. once a request is received the server accepts a connection from the client socket to complete the connection. servers implementing specific services such as telnet ftp and http listen to well known ports a telnet server listens to port an ftp server listens to port and a web or http server listens to port . all ports below are considered ivell known we can use them to implement standard services. when a client process initiates a request for a connection it is assigned a port by the host computer. this port is some arbitrary number greater than . for example if a client on host x with ip address . . . wishes to establish a connection with a web server which is listening on port at address . . . host x may be assigned port . the connection will consist of a pair of sockets . . . on host x and . . . on the web server. this situation is illustrated in figure . . the packets hostx . . . socket . . . web server . . . figure . communication using sockets. . communication in client server systems traveling between the hosts are delivered to the appropriate process based on the destination port number. all connections must be unique. therefore if another process also on host x wished to establish another connection with the same web server it would be assigned a port number greater than and not equal to . this ensures that all connections consist of a unique pair of sockets. although most program examples in this text use c we will illustrate sockets using java as it provides a much easier interface to sockets and has a rich library for networking utilities. those interested in socket programming in c or c should consult the bibliographical notes at the end of the chapter. java provides three different types of sockets. connection oriented tcp sockets are implemented with the socket class. connectionless udp sockets use the datagramsocket class. finally the mult icastsocket class is a subclass of the datagramsocket class. a multicast socket allows data to be sent to multiple recipients. our example describes a date server that uses connection oriented tcp sockets. the operation allows clients to request the current date and time from import java.net. import java.io. public class dateserver public static void main string args try serversocket sock new serversocket now listen for connections while true socket client sock.accept printwriter pout new printwriter client.getoutputstream true write the date to the socket pout.println new java.util.date .tostring close the socket and resume listening for connections client.close catch ioexception ioe system.err.println ioe figure . date server. chapter processes the server. the server listens to port although the port could have any arbitrary number greater than . when a connection is received the server returns the date and time to the client. the date server is shown in figure . . the server creates a serversocket that specifies it will listen to port . the server then begins listening to the port with the accept method. the server blocks on the accept o method waiting for a client to request a connection. when a connection request is received accept returns a socket that the server can use to communicate with the client. the details of how the server communicates with the socket are as follows. the server first establishes a p r i n t w r i t e r object that it will use to communicate with the client. a p r i n t w r i t e r object allows the server to write to the socket using the routine p r i n t and print in methods for output. the server process sends the date to the client calling the method p r i n t l n o . once it has written the date to the socket the server closes the socket to the client and resumes listening for more requests. a client communicates with the server by creating a socket and connecting to the port on which the server is listening. we implement such a client in the java program shown in figure . . the client creates a socket and requests import j ava.net. import java.io. public class dateclient public static void main string args try make connection to server socket socket sock new socket . . . inputstream in sock.getlnputstream bufferedreader bin new bufferedreader new inputstreamreader in read the date from the socket string line while line bin.readline ! null system.out.println line ii close the socket connection sock.close catch ioexception ioe system.err.println ioe figure . date client. . communication in client server systems a connection with the server at ip address . . . on port . once the connection is made the client can read front the socket using normal stream i o statements. after it has received the date from the server the client closes the socket and exits. the ip address . . . is a special ip address known as the loopback. when a computer refers to ip address . . . it is referring to itself. this mechanism allows a client and server on the same host to communicate using the tcp ip protocol. the ip address . . . could be replaced with the ip address of another host running the date server. in addition to an ip address an actual host name such as ivrvw.westminstercohege.edu can be used as well. communication using sockets although common and efficient is considered a low level form of communication between distributed processes. one reason is that sockets allow only an unstructured stream of bytes to be exchanged between the communicating threads. it is the responsibility of the client or server application to impose a structure on the data. in the next two subsections we look at two higher level methods of communication remote procedure calls rpcs and remote method invocation rmi . . . remote procedure calls one of the most common forms of remote service is the rpc paradigm which we discussed briefly in section . . . the rpc was designed as a way to abstract the procedure call mechanism for use between systems with network connections. it is similar in many respects to the ipc mechanism described in section . and it is usually built on top of such a system. here however because we are dealing with an environment in which the processes are executing on separate systems we must use a message based communication scheme to provide remote service. in contrast to the ipc facility the messages exchanged in rpc communication are well structured and are thus no longer just packets of data. each message is addressed to an rpc daemon listening to a port on the remote system and each contains an identifier of the function to execute and the parameters to pass to that function. the function is then executed as requested and any output is sent back to the requester in a separate message. a port is simply a number included at the start of a message packet. whereas a system normally has one network address it can have many ports within that address to differentiate the many network services it supports. if a remote process needs a service it addresses a message to the proper port. for instance if a system wished to allow other systems to be able to list its current users it would have a daemon supporting such an rpc attached to a port say port . any remote system could obtain the needed information that is the list of current users by sending an rpc message to port on the server the data would be received in a reply message. the semantics of rpcs allow a client to invoke a procedure on a remote host as it would invoke a procedure locally. the rpc system hides the details that allow communication to take place by providing a stub on the client side. typically a separate stub exists for each separate remote procedure. when the client invokes a remote procedure the rpc system calls the appropriate stub passing it the parameters provided to the remote procedure. this stub locates the port on the server and marshals the parameters. parameter marshalling involves packaging the parameters into a form that can be transmitted over chapter processes a network. the stub then transmits a message to the server using message passing. a similar stub on the server side receives this message and invokes the procedure on the server. if necessary return values are passed back to the client using the same technique. one issue that must be dealt with concerns differences in data representation on the client and server machines. consider the representation of bit integers. some systems known as big endian use the high memory address to store the most significant byte while other systems known as little endian store the least significant byte at the high memory address. to resolve differences like this many rpc systems define a machine independent representation of data. one such representation is known as external data representation xdr . on the client side parameter marshalling involves converting the machinedependent data into xdr before they are sent to the server. on the server side the xdr data are unmarshalled and converted to the machine dependent representation for the server. another important issue involves the semantics of a call. whereas local procedure calls fail only under extreme circumstances rpcs can fail or be duplicated and executed more than once as a result of common network errors. one way to address this problem is for the operating system to ensure that messages are acted on exactly once rather than at most once. most local procedure calls have the exactly once functionality but it is more difficult to implement. first consider at most once . this semantic can be assured by attaching a timestamp to each message. the server must keep a history of all the timestamps of messages it has already processed or a history large enough to ensure that repeated messages are detected. incoming messages that have a timestamp already in the history are ignored. the client can then send a message one or more times and be assured that it only executes once. generation of these timestamps is discussed in section . . for exactly once we need to remove the risk that the server never receives the request. to accomplish this the server must implement the at most once protocol described above but must also acknowledge to the client that the rpc call was received and executed. these ack messages are common throughout networking. the client must resend each rpc call periodically until it receives the ack for that call. another important issue concerns the communication between a server and a client. with standard procedure calls some form of binding takes place during link load or execution time chapter so that a procedure call's name is replaced by the memory address of the procedure call. the rpc scheme requires a similar binding of the client and the server port but how does a client know the port numbers on the server? neither system has full information about the other because they do not share memory. two approaches are common. first the binding information may be predetermined in the form of fixed port addresses. at compile time an rpc call has a fixed port number associated with it. once a program is compiled the server cannot change the port number of the requested service. second binding can be done dynamically by a rendezvous mechanism. typically an operating system provides a rendezvous also called a matchmaker daemon on a fixed rpc port. a client then sends a message containing the name of the rpc to the rendezvous daemon requesting the port address of the rpc it . communication in client server systems client messages server j user calls kernel to send rpc message to procedure x kernel sends from matchmaker message to to seirver receives matchmaker to message looks find port number up answer kernel places matchmaker port pin user pprtt kernel replies to client rpc message pie fipg?x with port p p rt p from client daemon kernel sends to server listening to rpc port port p port p receives contents message from rpc daemon kernel receives port p processes reply passes to client request and it to user port kernel processes send output output figure . execution of a remote procedure call rpc . needs to execute. the port number is returned and the rpc calls can be sent to that port until the process terminates or the server crashes . this method requires the extra overhead of the initial request but is more flexible than the first approach. figure . shows a sample interaction. the rpc scheme is useful in implementing a distributed file system chapter . such a system can be implemented as a set of rpc daemons and clients. the messages are addressed to the distributed file system port on a server on which a file operation is to take place. the message contains the disk operation to be performed. the disk operation might be read write rename d e l e t e or s t a t u s corresponding to the usual file related system calls. the return message contains any data resulting from that call which is executed by the dfs daemon on behalf of the client. for instance a message might contain a request to transfer a whole file to a client or be limited to a simple block request. in the latter case several such requests may be needed if a whole file is to be transferred. chapter processes . . remote method invocation remote method invocation rmi is a java feature similar to rpcs. rmi allows a thread to invoke a method on a remote object. objects are considered remote if they reside in a different java virtual machine jvm . therefore the remote object may be in a different jvm on the same computer or on a remote host connected by a network. this situation is illustrated in figure . . rmi and rpcs differ in two fundamental ways. first rpcs support procedural programming whereby only remote procedures or functions can be called. in contrast rmi is object based it supports invocation of methods on remote objects. second the parameters to remote procedures are ordinary data structures in rpc with rmi it is possible to pass objects as parameters to remote methods. by allowing a java program to invoke methods on remote objects rmi makes it possible for users to develop java applications that are distributed across a network. to make remote methods transparent to both the client and the server rmi implements the remote object using stubs and skeletons. a stub is a proxy for the remote object it resides with the client. when a client invokes a remote method the stub for the remote object is called. this client side stub is responsible for creating a parcel consisting of the name of the method to be invoked on the server and the marshalled parameters for the method. the stub then sends this parcel to the server where the skeleton for the remote object receives it. the skeleton is responsible for unmarshalling the parameters and invoking the desired method on the server. the skeleton then marshals the return value or exception if any into a parcel and returns this parcel to the client. the stub unmarshals the return value and passes it to the client. lets look more closely at how this process works. assume that a client wishes to invoke a method on a remote object server with a signature somemethod object object that returns a boolean value. the client executes the statement boolean val server.somemethod a b the call to somemethod with the parameters a and b invokes the stub for the remote object. the stub marshals into a parcel the parameters a and b and the name of the method that is to be invoked on the server then sends this parcel to the server. the skeleton on the server unmarshals the parameters and invokes the method somemethod . the actual implementation of somemethod resides on the server. once the method is completed the skeleton marshals jvm jvm figure . remote method invocation