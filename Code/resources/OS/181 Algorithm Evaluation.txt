 that are more interactive typically have longer sleep times and therefore are more likely to have adjustments closer to as the scheduler favors interactive tasks. the result of such adjtistments will be higher priorities for these tasks. conversely tasks with shorter sleep times are often more cpu bound and thus will have their priorities lowered. the recalculation of a task's dynamic priority occurs when the task has exhausted its time quantum and is to be moved to the expired array. thus when the two arrays are exchanged all tasks in the new active array have been assigned new priorities and corresponding time slices. . algorithm evaluation how do we select a cpu scheduling algorithm for a particular system? as we saw in section . there are many scheduling algorithms each with its own parameters. as a result selecting an algorithm can be difficult. the first problem is defining the criteria to be used in selecting an algorithm. as we saw in section . criteria are often defined in terms of cpu utilization response time or throughput. to select an algorithm we must first define the relative importance of these measures. our criteria may include several measures such as maximizing cpu utilization under the constraint that the maximum response time is second maximizing throughput such that turnaround time is on average linearly proportional to total execution time once the selection criteria have been defined we want to evaluate the algorithms under consideration. we next describe the various evaluation methods we can use. . . deterministic modeling one major class of evaluation methods is analytic evaluation. analytic evaluation uses the given algorithm and the system workload to produce a formula or number that evaluates the performance of the algorithm for that workload. one type of analytic evaluation is deterministic modeling. this method takes a particular predetermined workload and defines the performance of each algorithm for that workload. for example assume that we have the workload shown below. all five processes arrive at time in the order given with the length of the cpu burst given in milliseconds process burst time pi p p pi p chapter cpu scheduling consider the fcfs sjf and rr quantum milliseconds scheduling algorithms for this set of processes. which algorithm would give the minimum average waiting time? for the fcfs algorithm we would execute the processes as pi p p p p the waiting time is milliseconds for process pi milliseconds for process p? milliseconds for process p milliseconds for process p and milliseconds for process p . thus the average waiting time is milliseconds. with nonpreemptive sjf scheduling we execute the processes as p p px p p the waiting time is milliseconds for process p milliseconds for process p milliseconds for process p milliseconds for process p and milliseconds for process p . thus the average waiting time is milliseconds. with the rr algorithm we execute the processes as pi p p p ps p ps p the waiting time is milliseconds for process pi milliseconds for process p milliseconds for process p milliseconds for process p and milliseconds for process p . thus the average waiting time is milliseconds. we see that in this case the average waiting time obtained with the sjf policy is less than half that obtained with fcfs scheduling the rr algorithm gives us an intermediate value. deterministic modeling is simple and fast. it gives us exact numbers allowing us to compare the algorithms. however it requires exact numbers for input and its answers apply only to those cases. the main uses of deterministic modeling are in describing scheduling algorithms and providing examples. in cases where we are running the same program over and over again and can measure the program's processing requirements exactly we may be able to use deterministic modeling to select a scheduling algorithm. furthermore over a set of examples deterministic modeling may indicate trends that can then be analyzed and proved separately. for example it can be shown that for the environment described all processes and their times available at time the sjf policy will always result in the minimum waiting time. . algorithm evaluation . . queueing models on many systems the processes that are run vary from day to day so there is no static set of processes or times to use for deterministic modeling. what can be determined however is the distribution of cpu and i o bursts. these distributions can be measured and then approximated or simply estimated. the result is a mathematical formula describing the probability of a particular cpu burst. commonly this distribution is exponential and is described by its mean. similarly we can describe the distribution of times when processes arrive in the system the arrival time distribution . from these two distributions it is possible to compute the average throughput utilization waiting time and so on for most algorithms. the computer system is described as a network of servers. each server has a queue of waiting processes. the cpu is a server with its ready queue as is the i o system with its device queues. knowing arrival rates and service rates we can compute utilization average queue length average wait time and so on. this area of study is called queueing network analysis. as an example let n be the average queue length excluding the process being serviced let w be the average waiting time in the queue and let x be the average arrival rate for new processes in the queue such as three processes per second . we expect that during the time w that a process waits x w new processes will arrive in the queue. if the system is in a steady state then the number of processes leaving the queue must be equal to the number of processes that arrive. thus this equation known as little's formula is particularly useful because it is valid for any scheduling algorithm and arrival distribution. we can use little's formula to compute one of the three variables if we know the other two. for example if we know that processes arrive every second on average and that there are normally processes in the queue then we can compute the average waiting time per process as seconds. queueing analysis can be useful in comparing scheduling algorithms but it also has limitations. at the moment the classes of algorithms and distributions that can be handled are fairly limited. the mathematics of complicated algorithms and distributions can be difficult to work with. thus arrival and service distributions are often defined in mathematically tractable but unrealistic ways. it is also generally necessary to make a number of independent assumptions which may not be accurate. as a result of these difficulties queueing models are often only approximations of real systems and the accuracy of the computed results may be questionable. . . simulations to get a more accurate evaluation of scheduling algorithms we can use simulations. running simulations involves programming a model of the computer system. software data structures represent the major components of the system. the simulator has a variable representing a clock as this variable's value is increased the simulator modifies the system state to reflect the activities of the devices the processes and the scheduler. as the simulation chapter cpu scheduling performance statistics for fcfs ' ' slffltitatio!i b performance execution statistics for sjf if sje nl trace tape performance lisirhtilqtior statistics forrr g figure . evaluation of cpu schedulers by simulation. executes statistics that indicate algorithm performance are gathered and printed. the data to drive the simulation can be generated in several ways. the most common method uses a random number generator which is programmed to generate processes cpu burst times arrivals departures and so on according to probability distributions. the distributions can be defined mathematically uniform exponential poisson or empirically. if a distribution is to be defined empirically measurements of the actual system under study are taken. the results define the distribution of events in the real system this distribution can then be used to drive the simulation. a distribution driven simulation may be inaccurate however because of relationships between successive events in the real system. the frequency distribution indicates only how many instances of each event occur it does not indicate anything about the order of their occurrence. to correct this problem we can use trace tapes. we create a trace tape by monitoring the real system and recording the sequence of actual events figure . . we then use this sequence to drive the simulation. trace tapes provide an excellent way to compare two algorithms on exactly the same set of real inputs. this method can produce accurate results for its inputs. simulations can be expensive often requiring hours of computer time. a more detailed simulation provides more accurate results but it also requires more computer time. in addition trace tapes can require large amounts of storage space. finally the design coding and debugging of the simulator can be a major task. . . implementation even a simulation is of limited accuracy. the only completely accurate way to evaluate a scheduling algorithm is to code it up put it in the operating system and see how it works. this approach puts the actual algorithm in the real system for evaluation under real operating conditions