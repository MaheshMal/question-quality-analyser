 of threads in the kernel specifically for interrupt handling linux uses a kernel thread for managing the amount of free memory in the system. . . benefits the benefits of multithreaded programming can be broken down into four major categories . responsiveness. multithreading an interactive application may allow a program to continue running even if part of it is blocked or is performing a lengthy operation thereby increasing responsiveness to the user. for instance a multithreaded web browser could still allow user interaction in one thread while an image was being loaded in another thread. . resource sharing. by default threads share the memory and the resources of the process to which they belong. the benefit of sharing code and data is that it allows an application to have several different threads of activity within the same address space. . economy. allocating memory and resources for process creation is costly. because threads share resources of the process to which they belong it is more economical to create and context switch threads. empirically gauging the difference in overhead can be difficult but in general it is much more time consuming to create and manage processes than threads. in solaris for example creating a process is about thirty times slower than is creating a thread and context switching is about five times slower. . utilization of multiprocessor architectures. the benefits of multithreading can be greatly increased in a multiprocessor architecture where threads may be running in parallel on different processors. a singlethreaded process can only run on one cpu no matter how many are available. multithreading on a multi cpu machine increases concurrency. . multithreading models our discussion so far has treated threads in a generic sense. however support for threads may be provided either at the user level for user threads or by the kernel for kernel threads. user threads are supported above the kernel and are managed without kernel support whereas kernel threads are supported and managed directly by the operating system. virtually all contemporary operating systems including windows xp linux mac os x solaris and tru unix formerly digital unix support kernel threads. ultimately there must exist a relationship between user threads and kernel threads. in this section we look at three common ways of establishing this relationship. . . many to one model the many to one model figure . maps many user level threads to one kernel thread. thread management is done by the thread library in user space so it is efficient but the entire process will block if a thread makes a chapter threads user thread kernel thread figure . many to one model. blocking system call. also because only one thread can access the kernel at a time multiple threads are unable to run in parallel on multiprocessors. green threads a thread library available for solaris uses this model as does gnu portable threads. . . one to one model the one to one model figure . maps each user thread to a kernel thread. it provides more concurrency than the many to one model by allowing another thread to run when a thread makes a blocking system call it also allows multiple threads to run in parallel on multiprocessors. the only drawback to this model is that creating a user thread requires creating the corresponding kernel thread. because the overhead of creating kernel threads can burden the performance of an application most implementations of this model restrict the number of threads supported by the system. linux along with the family of windows operating systems including windows nt and xp implement the one to one model. . . many to many model the many to many model figure . multiplexes many user level threads to a smaller or equal number of kernel threads. the number of kernel threads may be specific to either a particular application or a particular machine an user thread kernel thread figure . one to one model