 how can the access matrix be implemented effectively? in general the matrix will be sparse that is most of the entries will be empty. although datastructure techniques are available for representing sparse matrices they are not particularly useful for this application because of the way in which the protection facility is used. here we first describe several methods of implementing the access matrix and then compare the methods. . . global table the simplest implementation of the access matrix is a global table consisting of a set of ordered triples domain object rights set . whenever an operation m is executed on an object o within domain d the global table is searched for a triple d o rk with m e r . if this triple is found the operation is allowed to continue otherwise an exception or error condition is raised. this implementation suffers from several drawbacks. the table is usually large and thus cannot be kept in main memory so additional i o is needed. virtual memory techniques are often used for managing this table. in addition it is difficult to take advantage of special groupings of objects or domains. for example if everyone can read a particular object it must have a separate entry in every domain. . . access lists for objects each column in the access matrix can be implemented as an access list for one object as described in section . . . obviously the empty entries can be discarded. the resulting list for each object consists of ordered pairs rfomnin rights set which define all domains with a nonempty set of access rights for that object. this approach can be extended easily to define a list plus a default set of access rights. when an operation m on an object is attempted in domain . implementation of access matrix dj we search the access list for object o. looking for an entry d r with m e kj. if the entry is found we allow the operation if it is not we check the default set. if m is in the default set we allow the access. otherwise access is denied and an exception condition occurs. for efficiency we may check the default set first and then search the access list. . . capability lists for domains rather than associating the columns of the access matrix with the objects as access lists we can associate each row with its domain. a capability list for a domain is a list of objects together with the operations allowed on those objects. an object is often represented by its physical name or address called a capability. to execute operation m on object the process executes the operation m specifying the capability or pointer for object o as a parameter. simple possession of the capability means that access is allowed. the capability list is associated with a domain but it is never directly accessible to a process executing in that domain. rather the capability list is itself a protected object maintained by the operating system and accessed by the user only indirectly. capability based protection relies on the fact that the capabilities are never allowed to migrate into any address space directly accessible by a user process where they could be modified . if all capabilities are secure the object they protect is also secure against unauthorized access. capabilities were originally proposed as a kind of secure pointer to meet the need for resource protection that was foreseen as multiprogrammed computer systems came of age. the idea of an inherently protected pointer provides a foundation for protection that canbe extended up to the applications level. to provide inherent protection we must distinguish capabilities from other kinds of objects and they must be interpreted by an abstract machine on which higher level programs run. capabilities are usually distinguished from other data in one of two ways each object has a tag to denote its type either as a capability or as accessible data. the tags themselves must not be directly accessible by an application program. hardware or firmware support may be used to enforce this restriction. although only bit is necessary to distinguish between capabilities and other objects more bits are often used. this extension allows all objects to be tagged with their types by the hardware. thus the hardware can distinguish integers floating point numbers pointers booleans characters instructions capabilities and uninitialized values by their tags. alternatively the address space associated with a program can be split into two parts. one part is accessible to the program and contains the program's normal data and instructions. the other part containing the capability list is accessible only by the operating system. a segmented memory space section . is useful to support this approach. several capability based protection systems have been developed we describe them briefly in section . . the mach operating system also uses a version of capability based protection it is described in appendix b. chapter protection . . a lock key mechanism the lock key scheme is a compromise between access lists and capability lists. each object has a list of unique bit patterns called locks. similarly each domain has a list of unique bit patterns called keys. a process executing in a domain can access an object only if that domain has a key that matches one of the locks of the object. as with capability lists the list of keys for a domain must be managed by the operating system on behalf of the domain. users are not allowed to examine or modify the list of keys or locks directly. . . comparison we now compare the various techniques for implementing an access matrix. using a global table is simple however the table can be quite large and often cannot take advantage of special groupings of objects or domains. access lists correspond directly to the needs of users. when a user creates an object he can specify which domains can access the object as well as the operations allowed. however because access rights information for a particular domain is not localized determining the set of access rights for each domain is difficult. in addition every access to the object must be checked requiring a search of the access list. in a large system with long access lists this search can be time consuming. capability lists do not correspond directly to the needs of users they are useful however for localizing information for a given process. the process attempting access must present a capability for that access. then the protection system needs only to verify that the capability is valid. revocation of capabilities however may be inefficient section . . the lock key mechanism as mentioned is a compromise between access lists and capability lists. the mechanism can be both effective and flexible depending on the length of the keys. the keys can be passed freely from domain to domain. in addition access privileges can be effectively revoked by the simple technique of changing some of the locks associated with the object section . . most systems use a combination of access lists and capabilities. when a process first tries to access an object the access list is searched. if access is denied an exception condition occurs. otherwise a capability is created and attached to the process. additional references use the capability to demonstrate swiftly that access is allowed. after the last access the capability is destroyed. this strategy is used in the m.ultics system and in the cal system. as an example of how such a strategy works consider a file system in which each file has an associated access list. when a process opens a file the directory structure is searched to find the file access permission is checked and buffers are allocated. all this information is recorded in a new entry in a file table associated with the process. the operation returns an index into this table for the newly opened file. all operations on the file are made by specification of the index into the file table. the entry in the file table then points to the file and its buffers. when the file is closed the file table entry is deleted. since the file table is maintained by the operating system the user cannot accidentally corrupt it. thus the user can access only those files that have been opened