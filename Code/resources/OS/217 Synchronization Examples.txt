 a process might attempt to release a resource that it never requestecj. a process might request the same resource twice without first releasing the resource . the same difficulties are encountered with the use of semaphores and these difficulties are similar in nature to those that encouraged us to develop the monitor constructs in the first place. previously we had to worry about the correct use of semaphores. now we have to worry about the correct use of higher level programmer defined operations with which the compiler can no longer assist us. one possible solution to the current problem is to include the resourceaccess operations within the resourceallocator monitor. however using this solution will mean that scheduling is done according to the built in monitor scheduling algorithm rather than the one we have coded. to ensure that the processes observe the appropriate sequences we must inspect all the programs that make use of the resourceallocator monitor and its managed resource. we must check two conditions to establish the correctness of this system. first user processes must always make their calls on the monitor in a correct sequence. second we must be sure that an uncooperative process does not simply ignore the mutual exclusion gateway provided by the monitor and try to access the shared resource directly without using the access protocols. only if these two conditions can be ensured can we guarantee that no time dependent errors will occur and that the scheduling algorithm will not be defeated. although this inspection may be possible for a small static system it is not reasonable for a large system or a dynamic system. this access control problem can be solved only by additional mechanisms that will be described in chapter . many programming languages have incorporated the idea of the monitor as described in this section including concurrent pascal mesa c pronounced c sharp and java. other languages such as erlang provide some type of concurrency support using a similar mechanism. . synchronization examples we next describe the synchronization mechanisms provided by the solaris windows xp and linux operating systems as well as the pthreads api. we have chosen these three systems because they provide good examples of different approaches for synchronizing the kernel and we have included the pthreads api because it is widely used for thread creation and synchronization by developers on unix and linux systems. as you will see in this section the synchronization methods available in these differing systems vary in subtle and significant ways. . . synchronization in solaris to control access to critical sections solaris provides adaptive mutexes condition variables semaphores reader writer locks and turnstiles. solaris implements semaphores and condition variables essentially as they are presented chapter process synchronization java monitors java pros de .a monitor like concurrency mechani. m tor thread synchronization l verv nhjivl in ja a has as. ouated with it a single lurk.. when a method i declared to be synchron l zed calling thi method requires ouning the lovk tor the objivl. we declare a synchronized method by pkxing iiil synclirrm . zod ke vvd in the method definition. i in. following defines the safemelhcdo as synchronized for example ulii.j yyiiciiorii r.e.ri void r . .f 'u' lio..i . ltpli mi r i . .r ion n ijtshj'.nudu next .l i uiiu m crciilc on object instnncc of sircploclass lidi as siir.pleclass sc new simpleclasso invoking lln sc.safeketliod nu tliod n quirt owning ilio lock on liuobject inslaikl sc. if tlu lock is already ownod b anollk r thn id. the thread calling the synchronizfij mclhod blocks and is pl.u.ed in the entry sol lor ilio object's lock. the unlrv si l rqiresitrn the sel of lhn.md nailing lor tin luck to becomu available. if the lock is available vvhun a ayi chrondr ed method is called the calling ihivad lh. omh's the owner of the object' lo k and can enter the mclhod. the lock i released vvhon the lha ad exit i he inetlmd a thread from theenln sel is then sek cled . hie new owner of the lock. java also provides w a i t o and n o t i f y melhods. which are similar in function to t h r w a i t o and signal. o slalements lor a monitor. release l. i of the java virhial fachine pro ides aim support for semaphores condition variables jnd mute locks among other loncurreikv ineih.inisins' in the j a v a . irti . cor.currenl package. in sections . and . . in this section we describe adaptive mutexes readerwriter locks and turnstiles. an adaptive mutex protects access to every critical data item. on a multiprocessor system an adaptive mutex starts as a standard semaphore implemented as a spinlock. if the data are locked and therefore already in use the adaptive mutex does one of two things. if the lock is held by a thread that is currently running on another cpu the thread spins while waiting for the lock to become available because the thread holding the lock is likely to finish soon. if the thread holding the lock is not currently in run state the thread blocks going to sleep until it is awakened by the release of the lock. it is put to sleep so that it will not spin while waiting since the lock will not be freed very soon. a lock held by a sleeping thread is likely to be in this category. on a single processor system the thread holding the lock is never running if the . synchronization examples lock is being tested by another thread because only one thread can rijn at a time. therefore on this type of system threads always sleep rather than spin if they encounter a lock. solaris uses the adaptive mutex method to protect only data that are accessed by short code segments. that is a mutex is used if a lock will be held for less than a few hundred instructions. if the code segment is longer than that spin waiting will be exceedingly inefficient. for these longer code segments condition variables and semaphores are used. if the desired lock is already held the thread issues a wait and sleeps. when a thread frees the lock it issues a signal to the next sleeping thread in the queue. the extra cost of putting a thread to sleep and waking it and of the associated context switches is less than the cost of wasting several hundred instructions waiting in a spinlock. reader writer locks are used to protect data that are accessed frequently but are usually accessed in a read only manner. in these circumstances reader writer locks are more efficient than semaphores because multiple threads can read data concurrently whereas semaphores always serialize access to the data. reader writer locks are relatively expensive to implement so again they are used on only long sections of code. solaris uses turnstiles to order the list of threads waiting to acquire either an adaptive mutex or a reader writer lock. a turnstile is a queue structure containing threads blocked on a lock. for example if one thread currently owns the lock for a synchronized object all other threads trying to acquire the lock will block and enter the turnstile for that lock. when the lock is released the kernel selects a thread from the turnstile as the next owner of the lock. each synchronized object with at least one thread blocked on the object's lock requires a separate turnstile. however rather than associating a turnstile with each synchronized object solaris gives each kernel thread its own turnstile. because a thread can be blocked only on one object at a time this is more efficient than having a turnstile per object. the turnstile for the first thread to block on a synchronized object becomes the turnstile for the object itself. subsequent threads blocking on the lock will be added to this turnstile. when the initial thread ultimately releases the lock it gains a new turnstile from a list of free turnstiles maintained by the kernel. to prevent a priority inversion turnstiles are organized according to a priorityinheritance protocol section . . this means that if a lower priority thread currently holds a lock that a higher priority thread is blocked on the thread with the lower priority will temporarily inherit the priority of the higherpriority thread. upon releasing the lock the thread will revert to its original priority. note that the locking mechanisms used by the kernel are implemented for user level threads as well so the same types of locks are available inside and outside the kernel. a crucial implementation difference is the priorityinheritance protocol. kernel locking routines adhere to the kernel priorityinheritance methods used by the scheduler as described in section . user level thread locking mechanisms do not provide this functionality. to optimize solaris performance developers have refined and fine tuned the locking methods. because locks are used frequently and typically are used for crucial kernel functions tuning their implementation and use can produce great performance gains. chapter process synchronization . . synchronization in windows xp ? the windows xp operating system is a multithreaded kernel that provides support for real time applications and multiple processors. when the windows xp kernel accesses a global resource on a uniprocessor system it temporarily masks interrupts for all interrupt handlers that may also access the global resource. on a multiprocessor system windows xp protects access to global resources using spinlocks. just as in solaris the kernel uses spinlocks only to protect short code segments. furthermore for reasons of efficiency the kernel ensures that a thread will never be preempted while holding a spinlock. for thread synchronization outside the kernel windows xp provides dispatcher objects. using a dispatcher object threads synchronize according to several different mechanisms including mutexes semaphores events and timers. the system protects shared data by requiring a thread to gain ownership of a mutex to access the data and to release ownership when it is finished. semaphores behave as described in section . . events are similar to condition variables that is they may notify a waiting thread when a desired condition occurs. finally timers are used to notify one or more than one thread that a specified amount of time has expired. dispatcher objects may be in either a signaled state or a nonsignaled state. a signaled state indicates that an object is available and a thread will not block when acquiring the object. a nonsignaled state indicates that an object is not available and a thread will block when attempting to acquire the object. we illustrate the state transitions of a mutex lock dispatcher object in figure . . a relationship exists between the state of a dispatcher object and the state of a thread. when a thread blocks on a nonsignaled dispatcher object its state changes from ready to waiting and the thread is placed in a waiting queue for that object. when the state for the dispatcher object moves to signaled the kernel checks whether any threads are waiting on the object. if so the kernel moves one thread or possibly more threads from the waiting state to the ready state where they can resume executing. the number of threads the kernel selects from the waiting queue depends on the type of dispatcher object it is waiting on. the kernel will select only one thread from the waiting queue for a mutex since a mutex object may be owned by only a single thread. for an event object the kernel will select all threads that are waiting for the event. we can use a mutex lock as an illustration of dispatcher objects and thread states. if a thread tries to acquire a mutex dispatcher object that is in a nonsignaled state that thread will be suspended and placed in a waiting queue for the mutex object. when the mutex moves to the signaled state because another thread has released the lock on the mutex the thread waiting at the owner thread releases mutex lock thread acquires mutex lock figure . mutex dispatcher object. . synchronization examples front of the queue will be moved from the waiting state to the ready state and will acquire the mutex lock. we provide a programming project at the end of this chapter that uses mutex locks and semaphores in the win api. . . synchronization in linux prior to version . linux was a nonpreemptive kernel meaning that a process running in kernel mode could not be preempted even if a higher priority process became available to run. now however the linux kernel is fully preemptive so a task can be preempted when it is running in the kernel. the linux kernel provides spinlocks and semaphores as well as reader writer versions of these two locks for locking in the kernel. on smp machines the fundamental locking mechanism is a spinlock and the kernel is designed so that the spinlock is held only for short durations. on single processor machines spinlocks are inappropriate for use and are replaced by enabling and disabling kernel preemption. that is on single processor machines rather than holding a spinlock the kernel disables kernel preemption and rather than releasing the spinlock it enables kernel preemption. this is summarized below single processor multiple processors disable kernel preemption. acquire spin lock. enable kernel preemption. release spin lock. linux uses an interesting approach to disable and enable kernel preemption. it provides two simple system calls preempt disable and preempt .enable for disabling and enabling kernel preemption. in addition however the kernel is not preemptible if a kernel mode task is holding a lock. to enforce this each task in the system has a t h r e a d i n f o structure containing a counter preempt .count to indicate the number of locks being held by the task. when a lock is acquired preempt xount is incremented. it is decremented when a lock is released. if the value of preempt count for the task currently running is greater than zero it is not safe to preempt the kernel as this task currently holds a lock. if the count is zero the kernel can safely be interrupted assuming there are no outstanding calls to preempt disable . spinlocks along with enabling and disabling kernel preemption are used in the kernel only when a lock or disabling kernel preemption is held for a short duration. when a lock must be held for a longer period semaphores are appropriate for use. . . synchronization in pthreads the pthreads api provides mutex locks condition variables and read write locks for thread synchronization. this api is available for programmers and is not part of any particular kernel. mutex locks represent the fundamental synchronization technique used with pthreads. a mutex lock is used to protect critical sections of code that is a thread acquires the lock before entering a critical section and releases it upon exiting the critical section. condition variables in pthreads behave much as described in section . . read write chapter process synchronization locks behave similarly to the locking mechanism described in section . . . many systems that implement pthreads also provide semaphores although they are not part of the pthreads standard and instead belong to the posix sem extension. other extensions to the pthreads api include spinlocks although not all extensions are considered portable from one implementation to another. we provide a programming project at the end of this chapter that uses pthreads mutex locks and semaphores