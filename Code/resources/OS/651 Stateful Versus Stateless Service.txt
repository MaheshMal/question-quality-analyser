 the cache consistency problem is the major drawback of caching. when access patterns exhibit infrequent writes caching is superior. however when writes are frequent the mechanisms employed to overcome the consistency problem incur substantial overhead in terms of performance network traffic and server load. so that caching will confer a benefit execution should be carried out on machines that have either local disks or large main memories. remote access on diskless small memory capacity machines should be done through the remote service method. in caching since data are transferred en masse between the server and the client rather than in response to the specific needs of a file operation the lower level intermachine interface is different from the upper level user interface. the remote service paradigm in contrast is just an extension of the local file system interface across the network. thus the intermachine interface mirrors the user interface. . stateful versus stateless service there are two approaches for storing server side information when a client accesses remote files either the server tracks each file being accessed byeach client or it simply provides blocks as they are requested by the client without knowledge of how those blocks are used. in the former case the service provided is stateful in the latter case it is stateless. the typical scenario of a stateful file service is as follows a client must perform an open operation on a file before accessing that file. the server fetches information about the file from its disk stores it in its memory and gives the client a connection identifier that is unique to the client and the open file. in umix terms the server fetches the mode and gives the client a file descriptor which serves as an index to an in core table of inodes. this identifier is used for subsequent accesses until the session ends. a stateful service is characterized as a connection between the client and the server during a session. either on closing the file or by a garbage collection mechanism the server must reclaim the main memory space used by clients that are no longer active. the key point regarding fault tolerance in a stateful service approach is that the server keeps main memory information about its clients. afs is a stateful file service. a stateless file service avoids state information by making each request self contained. that is each request identifies the file and the position in the file for read and write accesses in full. the server does not need to keep a table of open files in main memory although it usually does so for efficiencyreasons. moreover there is no need to establish and terminate a connection through open and close operations. they are totally redundant since each file operation stands on its own and is not considered part of a session. a client process would open a file and that open would not result in the sending of a remote message. reads and writes would take place as remote messages or cache lookups . the final close by the client would again result in only a local operation. nfs is a stateless file service. the advantage of a stateful over a stateless service is increased performance. file information is cached in main memory and can be accessed easily chapter distributed file systems via the connection identifier thereby saving disk accesses. in addition a s ateful server knows whether a file is open for sequential access and can therefore read ahead the next blocks. stateless servers cannot do so since they have no knowledge of the purpose of the client's requests. the distinction between stateful and stateless service becomes more evident when we consider the effects of a crash that occurs during a service activity. a stateful server loses all its volatile state in a crash. ensuring the graceful recovery of such a server involves restoring this state usually by a recovery protocol based on a dialog with clients. less graceful recovery requires that the operations that were underway when the crash occurred be aborted. a different problem is caused by client failures. the server needs to become aware of such failures so that it can reclaim space allocated to record the state of crashed client processes. this phenomenon is sometimes referred to as orphan detection and elimination. a stateless computer server avoids these problems since a newly reincarnated server can respond to a self contained request without any difficulty. therefore the effects of server failures and recovery are almost unnotkeable. there is no difference between a slow server and a recovering server from a client's point of view. the client keeps retransmitting its request if it receives no response. the penalty for using the robust stateless service is longer request messages and slower processing of requests since there is no in core information to speed the processing. in addition stateless service imposes additional constraints on the design of the dfs. first since each request identifies the target file a uniform system wide low level naming scheme should be used. translating remote to local names for each request would cause even slower processing of the requests. second since clients retransmit requests for file operations these operations must be idempotent that is each operation must have the same effect and return the same output if executed several times consecutively. self contained read and write accesses are idempotent as long as they use an absolute byte count to indicate the position within the file they access and do not rely on an incremental offset as done in unix read and write system calls . however we must be careful when implementing destructive operations such as deleting a file to make them idempotent too. in some environments a stateful service is a necessity. if the server employs the server initiated method for cache validation it cannot provide stateless service since it maintains a record of which files are cached by which clients. the way unix uses file descriptors and implicit offsets is inherently stateful. servers must maintain tables to map the file descriptors to inodes and must store the current offset within a file. this requirement is why nfs which employs a stateless service does not use file descriptors and does include an explicit offset in every access