 logical record last name number as tis p p smith . . . . index file relative file j igure . example of index and relative files. with large files the index file itself may become too large to be kept in memory. one solution is to create an index for the index file. the primary index file would contain pointers to secondary index files which would point to the actual data items. for example ibm's indexed sequential access method isam uses a small master index that points to disk blocks of a secondary index. the secondary index blocks point to the actual file blocks. the file is kept sorted on a defined key. to find a particular item we first make a binary search of the master index which provides the block number of the secondary index. this block is read in and again a binary search is used to find the block containing the desired record. finally this block is searched sequentially. in this way any record can be located from its key by at most two direct access reads. figure . shows a similar situation as implemented by vms index and relative files. . directory structure up to this point we have been discussing a file system. in reality systems may have zero or more file systems and the file systems may be of varying types. for example a typical solaris system may have a few ufs file systems a vfs file system and some nfs file systems. the details of file system implementation are found in chapter . the file systems of computers then can be extensive. some systems store millions of files on terabytes of disk. to manage all these data we need to organize them. this organization involves the use of directories. in this section we explore the topic of directory structure. first though we explain some basic features of storage structure. . . storage structure a disk or any storage device that is large enough can be used in its entirety for a file system. sometimes though it is desirable to place multiple file systems chapter file system interface dkectory i. directory' partition a y disk jjiijjij disk ream j partitioned lies partition b a files i i disk figure . a typical file system organization. on a disk or to use parts of a disk for a file system and other parts for other things such as swap space or unformatted raw disk space. these parts are known variously as partitions slices or in the ibm world minidisks. a file system can be created on each of these parts of the disk. as we shall see in the next chapter the parts can also be combined to form larger structures known as volumes and file systems can be created on these as well. for now for clarity we simply refer to a chunk of storage that holds a file system as a volume. each volume can be thought of as a virtual disk. volumes can also store multiple operating systems allowing a system to boot and run more than one. each volume that contains a file system must also contain information about the files in the system. this information is kept in entries in a device directory or volume table of contents. the device directory more commonly known simply as a directory records information such as name location size and type for all files on that volume. figure . shows a typical file system organization. . . directory overview the directory can be viewed as a symbol table that translates file names into their directory entries. if we take such a view we see that the directory itself can be organized in many ways. we want to be able to insert entries to delete entries to search for a named entry and to list all the entries in the directory. in this section we examine several schemes for defining the logical structure of the directory system. when considering a particular directory structure we need to keep in mind the operations that are to be performed on a directory search for a file. we need to be able to search a directory structure to find the entry for a particular file. since files have symbolic names and similar names may indicate a relationship between files we may want to be able to find all files whose names match a particular pattern. create a file. new files need to be created and added to the directory. . directory structure delete a file. when a file is no longer needed we want to be able to remove it from the directory. list a directory. we need to be able to list the files in a directory and the contents of the directory entry for each file in the list. rename a file. because the name of a file represents its contents to its users we must be able to change the name when the contents or use of the file changes. renaming a file may also allow its position within the directory structure to be changed. traverse the file system. we may wish to access every directory and every file within a directory structure. for reliability it is a good idea to save the contents and structure of the entire file system at regular intervals. often we do this by copying all files to magnetic tape. this technique provides a backup copy in case of system failure. in addition if a file is no longer in use. the file can be copied to tape and the disk space of that file released for reuse by another file. in the following sections we describe the most common schemes for defining the logical structure of a directory. . . single level directory the simplest directory structure is the single level directory. all files are contained in the same directory which is easy to support and understand figure . . a single level directory has significant limitations however when the number of files increases or when the system has more than one user. since all files are in the same directory they must have unique names. if two users call their data file test then the unique name rule is violated. for example in one programming class students called the program for their second assignment progl another called i assign!. although file names are generally selected to reflect the content of the file they are often limited in length complicating the task of making file names unique. the ms dos operating system allows only character file names unix in contrast allows characters. even a single user on a single level directory may find it difficult to remember the names of all the files as the number of files increases. it is not uncommon for a user to have hundreds of files on one computer system and an equal number of additional files on another system. keeping track of so many files is a daunting task. directory c. ' figure . single level directory. s chapter file system interface . . two level directory as we have seen a single level directory often leads to confusion of file names among different users. the standard solution is to create a separate directory for each user. in the two level directory structure each user has his own user file directory ltd . the ufds have similar structures but each lists only the files of a single user. when a user job starts or a user logs in the system's master file directory mfd is searched. the mfd is indexed by user name or account number and each entry points to the ufd for that user figure . . when a user refers to a particular file only his own ufd is searched. thus different users may have files with the same name as long as all the file names within each ufd are unique. to create a file for a user the operating system searches only that user's ufd to ascertain whether another file of that name exists. to delete a file the operating system confines its search to the local ufd thus it cannot accidentally delete another user's file that has the same name. the user directories themselves must be created and deleted as necessary. a special system program is run with the appropriate user name and account information. the program creates a new ufd and adds an entry for it to the pvlfd. the execution of this program might be restricted to system administrators. the allocation of disk space for user directories can be handled with the techniques discussed in chapter for files themselves. although the two level directory structure solves the name collision problem it still has disadvantages. this structure effectively isolates one user from another. isolation is an advantage wrhen the users are completely independent but is a disadvantage when the users want to cooperate on some task and to access one another's files. some systems simply do not allow local user files to be accessed by other users. if access is to be permitted one user must have the ability to name a file in another user's directory. to name a particular file uniquely in a two level directory we must give both the user name and the file name. a two level directory can be thought of as a tree or an inverted tree of height . the root of the tree is the mfd. its direct descendants are the ufds. the descendants of the ufds are the files themselves. the files are the leaves of the tree. specifying a user name and a file name defines a path in the tree from the root the mfd to a leaf the specified file . thus a user name and a file name define a path master file car .bo a tesi a d ila i a tost x aata a o figure . two level directory structure. . directory structure name. every file in the system has a path name. to name a file uniquely a user must know the path name of the file desired. for example if user a wishes to access her own test file named test she can simply refer to test. to access the file named test of user b with directory entry name userb however she might have to refer to userb test. every system has its own syntax for naming files in directories other than the user's own. additional syntax is needed to specify the volume of a file. for instance in ms dos a volume is specified by a letter followed by a colon. thus a file specification might be c userb test. some systems go even further and separate the volume directory name and file name parts of the specification. for instance in vms the file login.com might be specified as u sst.jdeckllogin.com l where u is the name of the volume sst is the name of the directory jdeck is the name of the subdirectory and is the version number. other systems simply treat the volume name as part of the directory name. the first name given is that of the volume and the rest is the directory and file. for instance u pbg test might specify volume it directory pbg and file test. a special case of this situation occurs with the system files. programs provided as part of the system loaders assemblers compilers utility routines libraries and so on are generally defined as files. when the appropriate commands are given to the operating system these files are read by the loader and executed. many command interpreters simply treat such a command as the name of a file to load and execute. as the directory system is defined presently this file name would be searched for in the current ufd. one solution would be to copy the system files into each ufd. however copying all the system files would waste an enormous amount of space. if the system files require mb then supporting users would require x mb just for copies of the system files. the standard solution is to complicate the search procedure slightly. a special user directory is defined to contain the system files for example user . whenever a file name is given to be loaded the operating system first searches the local ufd. if the file is found it is used. if it is not found the system automatically searches the special user directory that contains the system files. the sequence of directories searched when a file is named is called the search path. the search path can be extended to contain an unlimited list of directories to search when a command name is given. this method is the one most used in unix and ms dos. systems can also be designed so that each user has his own search path. . . tree structured directories once we have seen how to view a two level directory as a two level tree the natural generalization is to extend the directory structure to a tree of arbitrary height figure . . this generalization allows users to create their own subdirectories and to organize their files accordingly. a tree is the most common directory structure. the tree has a root directory and every file in the system has a unique path name. a directory or subdirectory contains a set of files or subdirectories. a directory is simply another file but it is treated in a special way. all directories have the same internal format. one bit in each directory entry defines the entry chapter file system interface root tft'c ' figure . tree structured directory structure. as a file or as a subdirectory . special system calls are used to create and delete directories. in normal use each process has a current directory. the current directory should contain most of the files that are of current interest to the process. when reference is made to a file the current directory is searched. if a file is needed that is not in the current directory then the user usually must either specify a path name or change the current directory to be the directory holding that file. to change directories a system call is provided that takes a directory name as a parameter and uses it to redefine the current directory. thus the user can change his current directory whenever he desires. from one change d i r e c t o r y system call to the next all open system calls search the current directory for the specified file. note that the search path may or may not contain a special entry that stands for the current directory. the initial current directory of the login shell of a user is designated when the user job starts or the user logs in. the operating system searches the accounting file or some other predefined location to find an entry for this user for accounting purposes . in the accounting file is a pointer to or the name of the user's initial directory. this pointer is copied to a local variable for this user that specifies the user's initial current directory. from that shell other processes can be spawned. the current directory of any subprocess is usually the current directory of the parent when it was spawned. path names can be of two types absolute and relative. an absolute path name begins at the root and follows a path down to the specified file giving the directory names on the path. a relative path name defines a path from the current directory. for example in the tree structured file system of figure . if the current directory is root spell' mail then the relative path name prt first refers to the same file as does the absolute path name root spcll mail prt first. . directory structure allowing a user to define her own subdirectories permits her to impose a structure on her files. this structure might result in separate directories for files associated with different topics for example a subdirectory was created to hold the text of this book or different forms of information for example the directory programs may contain source programs the directory bin may store ail the binaries . an interesting policy decision in a tree structured directory concerns how to handle the deletion of a directory. if a directory is empty its entry in the directory that contains it can simply be deleted. however suppose the directory to be deleted is not empty but contains several files or subdirectories. one of two approaches can be taken. some systems such as ms dos will not delete a directory unless it is empty. thus to delete a directory the user must first delete all the files in that directory. if any subdirectories exist this procedure must be applied recursively to them so that they can be deleted also. this approach can result in a substantial amount of work. an alternative approach such as that taken by the unix rm command is to provide an option when a request is made to delete a directory all that directory's files and subdirectories are also to be deleted. either approach is fairly easy to implement the choice is one of policy. the latter policy is more convenient but it is also more dangerous because an entire directory structure can be removed with one command. if that command is issued in error a large number of files and directories will need to be restored assuming a backup exists . with a tree structured directory system users can be allowed to access in addition to their files the files of other users. for example user b can access a file of user a by specifying its path names. user b can specify either an absolute or a relative path name. alternatively user b can change her current directory to be user a's directory and access the file by its file names. a path to a file in a tree structured directory can be longer than a path in a two level directory. to allow users to access programs without having to remember these long paths the macintosh operating system automates the search for executable programs. it maintains a file called the desktop file containing the names and locations of all executable programs it has seen. when a new hard disk or floppy disk is added to the system or the network is accessed the operating system traverses the directory structure searching for executable programs on the device and recording the pertinent information. this mechanism supports the double click execution functionality described previously. a double click on a file causes its creator attribute to be read and the desktop file to be searched for a match. once the match is found the appropriate executable program is started with the clicked on file as its input. the microsoft windows family of operating systems nt xp maintains an extended two level directory structure with devices and. volumes assigned drive letters section . . . . acyclic graph directories consider two programmers who are working on a joint project. the files associated with that project can be stored in a subdirectory separating them from other projects and files of the two programmers. but since both programmers are equally responsible for the project both want the subdirectory to be in chapter file system interface figure . acyclic graph directory structure. their own directories. the common subdirectory should be shared. a shared directory or file will exist in the file system in two or more places at once. a tree structure prohibits the sharing of files or directories. an acyclic graph that is a graph with no cycles allows directories to share subdirectories and files figure . . the same file or subdirectory may be in two different directories. the acyclic graph is a natural generalization of the tree structured directory scheme. it is important to note that a shared file or directory is not the same as two copies of the file. with two copies each programmer can view the copy rather than the original but if one programmer changes the file the changes will not appear in the other's copy. with a shared file only one actual file exists so any changes made by one person are immediately visible to the other. sharing is particularly important for subdirectories a new file created by one person will automatically appear in all the shared subdirectories. when people are working as a team all the files they want to share can be put into one directory. the ufd of each team member will contain this directory of shared files as a subdirectory. even in the case of a single user the user's file organization may require that some file be placed in different subdirectories. for example a program written for a particular project should be both in the directory of all programs and in the directory for that project. shared files and subdirectories can be implemented in several ways. a common way exemplified by many of the unix systems is to create a new directory entry called a link. a link is effectively a pointer to another file or subdirectory. for example a link may be implemented as an absolute or a relative path name. when a reference to a file is made we search the directory. if the directory entry is marked as a link then the name of the real file is included in the link information. we resolve the link by using that path name to locate the real file. links are easily identified by their format in the directory entry or by their having a special type on systems that support types and are . directory structure effectively named indirect pointers. the operating system ignores these links when traversing directory trees to preserve the acyclic structure of the system. another common approach to implementing shared files is simply to duplicate all information about them in both sharing directories. thus both entries are identical and equal. a link is clearly different from the original directory entry thus the two are not equal. duplicate directory entries however make the original and the copy indistinguishable. a .major problem with duplicate directory entries is maintaining consistency when a file is modified. an acyclic graph directory structure is more flexible than is a simple tree structure but it is also more complex. several problems must be considered carefully. a file may now have multiple absolute path names. consequently distinct file names may refer to the same file. this situation is similar to the aliasing problem for programming languages. if we are trying to traverse the entire file system to find a file to accumulate statistics on all files or to copy all files to backup storage this problem becomes significant since we do not want to traverse shared structures more than once. another problem involves deletion. when can the space allocated to a shared file be deallocated and reused? one possibility is to remove the file whenever anyone deletes it but this action may leave dangling pointers to the now nonexistent file. worse if the remaining file pointers contain actual disk addresses and the space is subsequently reused for other files these dangling pointers may point into the middle of other files. in a system where sharing is implemented by symbolic links this situation is somewhat easier to handle. the deletion of a link need not affect the original file only the link is removed. if the file entry itself is deleted the space for the file is deallocated leaving the links dangling. we can search for these links and remove them as well but unless a list of the associated links is kept with each file this search can be expensive. alternatively we can leave the links until an attempt is made to use them. at that time we can determine that the file of the name given by the link does not exist and can fail to resolve the link name the access is treated just as with any other illegal file name. in this case the system designer should consider carefully what to do when a file is deleted and another file of the same name is created before a symbolic link to the original file is used. in the case of unix symbolic links are left when a file is deleted and it is up to the user to realize that the original file is gone or has been replaced. microsoft windows all flavors uses the same approach. another approach to deletion is to preserve the file until all references to it are deleted. to implement this approach we must have some mechanism for determining that the last reference to the file has been deleted. we could keep a list of all references to a file directory entries or symbolic links . when a link or a copy of the directory entry is established a new entry is added to the file reference list. when a link or directory entry is deleted we remove its entry on the list. the file is deleted when its file reference list is empty. the trouble with this approach is the variable and potentially large size of the file reference list. however we really do not need to keep the entire list we need to keep only a count of the number of references. adding a new link or directory entry increments the reference count deleting a link or entry decrements the count. when the count is the file can be deleted there are no remaining references to it. the unix operating system uses this approach chapter file system interface for nonsymboiic links or hard links keeping a reference count in tile file information block or inode see appendix a. . . by effectively prohibiting multiple references to directories we maintain an acyclic graph structure. to avoid problems such as the ones just discussed some systems do not allow shared directories or links. for example in ms dos the directory structure is a tree structure rather than an acyclic graph. . . general graph directory a serious problem with using an acyclic graph structure is ensuring that there are no cycles. if we start with a two level directory and allow users to create subdirectories a tree structured directory results. it should be fairly easy to see that simply adding new files and subdirectories to an existing tree structured directory preserves the tree structured nature. however when we add links to an existing tree structured directory the tree structure is destroyed resulting in a simple graph structure figure . . the primary advantage of an acyclic graph is the relative simplicity of the algorithms to traverse the graph and to determine when there are no more references to a file. we want to avoid traversing shared sections of an acyclic graph twice mainly for performance reasons. if we have just searched a major shared subdirectory for a particular file without finding it we want to avoid searching that subdirectory again the second search would be a waste of time. if cycles are allowed to exist in the directory we likewise want to avoid searching any component twice for reasons of correctness as well as performance. a poorly designed algorithm might result in an infinite loop continually searching through the cycle and never terminating. one solution is to limit arbitrarily the number of directories that will be accessed during a search. a similar problem exists when we are trying to determine when a file can be deleted. with acyclic graph directory structures a value of in the reference count means that there are no more references to the file or directory root aw ic jim book iml unhcv hyp figure . general graph directory