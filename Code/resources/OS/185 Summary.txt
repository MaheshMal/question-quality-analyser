 the major difficulty with this approach is the high cost. the expense is incurred not only in coding the algorithm and modifying the operating system to support it along with its required data structures but also in the reaction of the users to a constantly changing operating system. most users are not interested in building a better operating system they merely want to get their processes executed and use their results. a constantly changing operating system does not help the users to get their work done. another difficulty is that the environment in which the algorithm is used will change. the environment will change not only in the usual way as new programs are written and the types of problems change but also as a result of the performance of the scheduler. if short processes are given priority then users may break larger processes into sets of smaller processes. if interactive processes are given priority over noninteractive processes then users may switch to interactive use. for example researchers designed one system that classified interactive and noninteractive processes automatically by looking at the amount of terminal i o. if a process did not input or output to the terminal in a second interval the process was classified as noninteractive and was moved to a lower priority queue. in response to this policy one programmer modified his programs to write an arbitrary character to the terminal at regular intervals of less than second. the system gave his programs a high priority even though the terminal output was completely meaningless. the most flexible scheduling algorithms are those that can be altered by the system managers or by the users so that they can be tuned for a specific application or set of applications. for instance a workstation that performs high end graphical applications may have scheduling needs different from those of a web server or file server. some operating systems particularly several versions of unix allow the system manager to fine tune the scheduling parameters for a particular system configuration. for example solaris provides the dispadmin command to allow the system administrator to modify the parameters of the scheduling classes described in section . . . another approach is to use apis that modify the priority of a process or thread. the java posix and winapi provide such functions. the downfall of this approach is that performance tuning a system or application most often does not result in improved performance in more general situations. . summary cpu scheduling is the task of selecting a waiting process from the ready queue and allocating the cpu to it. the cpu is allocated to the selected process by the dispatcher. first come first served fcfs scheduling is the simplest scheduling algorithm but it can cause short processes to wait for very long processes. shortestjob first sjf scheduling is provably optimal providing the shortest average waiting time. implementing sjf scheduling is difficult however because predicting the length of the next cpu burst is difficult. the sjf algorithm is a special case of the general priority scheduling algorithm which simply allocates the cpu to the highest priority process. both priority and sjf scheduling may suffer from starvation. aging is a technique to prevent starvation. chapter cpu scheduling round robin rr scheduling is more appropriate for a time shared interactive system. rr scheduling allocates the cpu to the first process in the ready queue for q time units where q is the time quantum. after q time units if the process has not relinquished the cpu it is preempted and the process is put at the tail of the ready queue. the major problem is the selection of the time quantum. if the quantum is too large rr scheduling degenerates to fcfs scheduling if the quantum is too small scheduling overhead in the form of context switch time becomes excessive. the fcfs algorithm is nonpreemptive the rr algorithm is preemptive. the sjf and priority algorithms may be either preemptive or nonpreemptive. multilevel queue algorithms allow different algorithms to be used for different classes of processes. the most common model includes a foreground interactive queue that uses rr scheduling and a background batch queue that vises fcfs scheduling. multilevel feedback queues allow processes to move from one queue to another. many contemporary computer systems support multiple processors and allow each processor to schedule itself independently. typically each processor maintains its own private queue of processes or threads all of which are available to run. issues related to multiprocessor scheduling include processor affinity and load balancing. operating systems supporting threads at the kernel level must schedule threads not processes for execution. this is the case with solaris and windows xp. both of these systems schedule threads using preemptive priority based scheduling algorithms including support for real time threads. the linux process scheduler uses a priority based algorithm with real time support as well. the scheduling algorithms for these three operating systems typically favor interactive over batch and cpu bound processes. the wide variety of scheduling algorithms demands that we have methods to select among algorithms. analytic methods use mathematical analysis to determine the performance of an algorithm. simulation methods determine performance by imitating the scheduling algorithm on a representative'' sample of processes and computing the resulting performance. however simulation can at best provide an approximation of actual system performance the only reliable technique for evaluating a scheduling algorithm is to implement the algorithm on an actual system and monitor its performance in a real world environment. exercises . why is it important for the scheduler to distinguish i o bound programs from cpu bound programs? . discuss how the following pairs of scheduling criteria conflict in certain settings. a. cpu utilization and response time b. average turnaround time and maximum waiting time c. i o device utilization and cpu utilization exercises . consider the exponential average formula used to predict the length of the next cpu burst. what are the implications of assigning the following values to the parameters used by the algorithm? a. a and to milliseconds b. a . and tq milliseconds . consider the following set of processes with the length of the cpu burst given in milliseconds process burst time priority pt p p p p the processes are assumed to have arrived in the order pi p p p p all at time . a. draw four gantt charts that illustrate the execution of these processes using the following scheduling algorithms fcfs sjf nonpreemptive priority a smaller priority number implies a higher priority and rr quantum . b. what is the turnaround time of each process for each of the scheduling algorithms in part a? c. what is the waiting time of each process for each of the scheduling algorithms in part a? d. which of the algorithms in part a results in the minimum average waiting time over all processes ? . which of the following scheduling algorithms could result in starvation? a. first come first served b. shortest job first c. round robin d. priority . consider a variant of the rr scheduling algorithm in which the entries in the ready queue are pointers to the pcbs. a. what would be the effect of putting two pointers to the same process in the ready queue? b. what would be two major advantages and two disadvantages of this scheme? c. how would you modify the basic rr algorithm to achieve the same effect without the duplicate pointers? chapter cpu scheduling . consider a system running ten i obound tasks and one cpu bound task. assume that the i o bound tasks issue an i o operation once for every millisecond of cpu computing and that each i o operation takes milliseconds to complete. also assume that the context switching overhead is . millisecond and that all processes are long running tasks. what is the cpu utilization for a round robin scheduler when a. the time quantum is millisecond b. the time quantum is milliseconds . consider a system implementing multilevel queue scheduling. what strategy can a computer user employ to maximize the amount of cpu time allocated to the user's process? . consider a preemptive priority scheduling algorithm based on dynamically changing priorities. larger priority numbers imply higher priority. when a process is waiting for the cpu in the ready queue but not running its priority changes at a rate a when it is running its priority changes at a rate . all processes are given a priority of when they enter the ready queue. the parameters a and p can be set to give many different scheduling algorithms. a. what is the algorithm that results from a ? b. what is the algorithm that results from a pi ? . explain the differences in the degree to which the following scheduling algorithms discriminate in favor of short processes a. fcfs b. rr c. multilevel feedback queues . using the windows xp scheduling algorithm what is the numeric priority of a thread for the following scenarios? a. a thread in the realtime priority.class with a relative priority of highest b. a thread in the normal priority.class with a relative priority of normal c. a thread in the high priority class with a relative priority of abovejvormal . consider the scheduling algorithm in the solaris operating system for time sharing threads. a. what is the time quantum in milliseconds for a thread with priority ? with priority ? b. assume that a thread with priority has used its entire time quantum without blocking. what new priority will the scheduler assign this thread? bibliographical notes c. assume that a thread with priority blocks for i o before its time quantum has expired. what new priority will the scheduler assign this thread? . the traditional unix scheduler enforces an inverse relationship between priority numbers and priorities the higher the number the lower the priority. the scheduler recalculates process priorities once per second using the following function priority recent cpu usage base where base and recent cpu usage refers to a value indicating how often a process has used the cpu since priorities were last recalculated. assume that recent cpu usage for process pi is process pi is and process p is . what will be the new priorities for these three processes when priorities are recalculated? based on this information does the traditional unix scheduler raise or lower the relative priority of a cpu bound process? bibliographical notes feedback queues were originally implemented on the ctss system described in corbato et al. . this feedback queue scheduling system was analyzed by schrage . the preemptive priority scheduling algorithm of exercise . was suggested by kleinrock . anderson et al. lewis and berg and philbin et al. talked about thread scheduling. multiprocessor scheduling was discussed by tucker and gupta zahorjan and mccann feitelson and rudolph leutenegger and vernon blumofe and leiserson polychronopoulos and kuck and lucco . scheduling techniques that take into account information regarding process execution times from previous runs were described in fisher hall et al. and lowney etal. . scheduling in real time systems was discussed by liu and layland abbot jensen et al. hong et al. and khanna et al. . a special issue of operating system review on real time operating systems was edited by zhao . fair share schedulers were covered by henry woodside and kay and lauder . scheduling policies used in the unix v operating system were described by bach those for unix bsd . were presented by mckusick et al. and those for the mach operating system were discussed by black bovet and cesati covered scheduling in linux. solaris scheduling was described by mauro and mcdougall . solomon and solomon and russinovich discussed scheduling in windows nt and windows respectively. butenhof and lewis and berg described scheduling in pthreads systems. apter