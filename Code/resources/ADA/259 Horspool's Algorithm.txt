consider as an example searching for the pattern barber in some text s ... c ... sn b a r b e r starting with the last r of the pattern and moving right to left we compare the corresponding pairs of characters in the pattern and the text. if all the pattern's characters match successfully a matching substring is found. then the search can be either stopped altogether or continued if another occurrence of the same pattern is desired. if a mismatch occurs we need to shift the pattern to the right. clearly we would like to make as large a shift as possible without risking the possibility of missing a matching substring in the text. horspool's algorithm determines the size of such a shift by looking at the character c of the text that is aligned against the last character of the pattern. this is the case even if character c itself matches its counterpart in the pattern. in general the following four possibilities can occur. case if there are no c's in the pattern e.g. c is letter s in our example we can safely shift the pattern by its entire length if we shift less some character of the pattern would be aligned against the text's character c that is known not to be in the pattern s ... s ... sn b a r b e r b a r b e r case if there are occurrences of character c in the pattern but it is not the last one there e.g. c is letter b in our example the shift should align the rightmost occurrence of c in the pattern with the c in the text s ... b ... sn b a r b e r b a r b e r case if c happens to be the last character in the pattern but there are no c's among its other m characters e.g. c is letter r in our example the situation is similar to that of case and the pattern should be shifted by the entire pattern's length m s ... m e r ... sn l e a d e r l e a d e r case finally if c happens to be the last character in the pattern and there are other c's among its first m characters e.g. c is letter r in our example the situation is similar to that of case and the rightmost occurrence of c among the first m characters in the pattern should be aligned with the text's c s ... a r ... sn r e o r d e r r e o r d e r these examples clearly demonstrate that right to left character comparisons can lead to farther shifts of the pattern than the shifts by only one position always made by the brute force algorithm. however if such an algorithm had to check all the characters of the pattern on every trial it would lose much of this superiority. fortunately the idea of input enhancement makes repetitive comparisons unnecessary. we can precompute shift sizes and store them in a table. the table will be indexed by all possible characters that can be encountered in a text including for natural language texts the space punctuation symbols and other special characters. note that no other information about the text in which eventual searching will be done is required. the table's entries will indicate the shift sizes computed by the formula the pattern's length m if c is not among the first m characters of the pattern t c . the distance from the rightmost c among the first m characters of the pattern to its last character otherwise. for example for the pattern barber all the table's entries will be equal to except for the entries for e b r and a which will be and respectively. here is a simple algorithm for computing the shift table entries. initialize all the entries to the pattern's length m and scan the pattern left to right repeating the following step m times for the j th character of the pattern j m overwrite its entry in the table with m j which is the character's distance to the last character of the pattern. note that since the algorithm scans the pattern from left to right the last overwrite will happen for the character's rightmost occurrence exactly as we would like it to be. algorithm shifttable p ..m fills the shift table used by horspool's and boyer moore algorithms input pattern p ..m and an alphabet of possible characters output table ..size indexed by the alphabet's characters and filled with shift sizes computed by formula . for i to size do table i m for j to m do table p j m j return table now we can summarize the algorithm as follows horspool's algorithm step for a given pattern of length m and the alphabet used in both the pattern and text construct the shift table as described above. step align the pattern against the beginning of the text. step repeat the following until either a matching substring is found or the pattern reaches beyond the last character of the text. starting with the last character in the pattern compare the corresponding characters in the pattern and text until either all m characters are matched then stop or a mismatching pair is encountered. in the latter case retrieve the entry t c from the c's column of the shift table where c is the text's character currently aligned against the last character of the pattern and shift the pattern by t c characters to the right along the text. here is pseudocode of horspool's algorithm. algorithm horspoolmatching p ..m t ..n implements horspool's algorithm for string matching input pattern p ..m and text t ..n output the index of the left end of the first matching substring or if there are no matches shifttable p ..m generate table of shifts i m position of the pattern's right end while i n do k number of matched characters while k m and p m k t i k do kk if k m return i m else i i table t i return example as an example of a complete application of horspool's algorithm consider searching for the pattern barber in a text that comprises english letters and spaces denoted by underscores . the shift table as we mentioned is filled as follows character c a b c d e f ... r ... z shift t c the actual search in a particular text proceeds as follows j i m s a w m e i n a b a r b e r s h o p b a r b e r b a r b e r b a r b e r b a r b e r b a r b e r b a r b e r a simple example can demonstrate that the worst case efficiency of horspool's algorithm is in o nm problem in this section's exercises . but for random texts it is in n and although in the same efficiency class horspool's algorithm is obviously faster on average than the brute force algorithm. in fact as mentioned it is often at least as efficient as its more sophisticated predecessor discovered by r. boyer and j. moore. 