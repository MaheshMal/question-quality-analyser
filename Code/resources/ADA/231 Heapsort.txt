now we can describe heapsort an interesting sorting algorithm discovered by j. w. j. williams wil . this is a two stage algorithm that works as follows. stage heap construction construct a heap for a given array. stage maximum deletions apply the root deletion operation n times to the remaining heap. as a result the array elements are eliminated in decreasing order. but since under the array implementation of heaps an element being deleted is placed last the resulting array will be exactly the original array sorted in increasing order. heapsort is traced on a specific input in figure . . the same input as the one stage heap construction stage maximum deletions figure . sorting the array by heapsort. in figure . is intentionally used so that you can compare the tree and array implementations of the bottom up heap construction algorithm. since we already know that the heap construction stage of the algorithm is in o n we have to investigate just the time efficiency of the second stage. for the number of key comparisons c n needed for eliminating the root keys from the heaps of diminishing sizes from n to we get the following inequality n c n log n log n . . . log log i i n log n n log n n log n. i this means that c n o n log n for the second stage of heapsort. for both stages we get o n o n log n o n log n . a more detailed analysis shows that the time efficiency of heapsort is in fact in n log n in both the worst and average cases. thus heapsort's time efficiency falls in the same class as that of mergesort. unlike the latter heapsort is in place i.e. it does not require any extra storage. timing experiments on random files show that heapsort runs more slowly than quicksort but can be competitive with mergesort. exercises . . a. construct a heap for the list by the bottom up algorithm. b. construct a heap for the list by successive key insertions top down algorithm . c. is it always true that the bottom up and top down algorithms yield the same heap for the same input? . outline an algorithm for checking whether an array h ..n is a heap and determine its time efficiency. . a. find the smallest and the largest number of keys that a heap of height h can contain. b. prove that the height of a heap with n nodes is equal to log n . . prove the following equality used in section . h h i i n log n where n h . i . a. design an efficient algorithm for finding and deleting an element of the smallest value in a heap and determine its time efficiency. b. design an efficient algorithm for finding and deleting an element of a given value v in a heap h and determine its time efficiency. . indicate the time efficiency classes of the three main operations of the priority queue implemented as a. an unsorted array. b. a sorted array. c. a binary search tree. d. an avl tree. e. a heap. . sort the following lists by heapsort by using the array representation of heaps. a. in increasing order b. in increasing order c. s o r t i n g in alphabetical order . is heapsort a stable sorting algorithm? . what variety of the transform and conquer technique does heapsort represent? . which sorting algorithm other than heapsort uses a priority queue? . implement three advanced sorting algorithms mergesort quicksort and heapsort in the language of your choice and investigate their performance on arrays of sizes n and . for each of these sizes consider a. randomly generated files of integers in the range ..n . b. increasing files of integers . . . n. c. decreasing files of integers n n . . . . . spaghetti sort imagine a handful of uncooked spaghetti individual rods whose lengths represent numbers that need to be sorted. a. outline a spaghetti sort a sorting algorithm that takes advantage of this unorthodox representation. b. what does this example of computer science folklore see dew have to do with the topic of this chapter in general and heapsort in particular? 