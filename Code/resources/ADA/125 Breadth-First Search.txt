if depth first search is a traversal for the brave the algorithm goes as far from home as it can breadth first search is a traversal for the cautious. it proceeds in a concentric manner by visiting first all the vertices that are adjacent to a starting vertex then all unvisited vertices two edges apart from it and so on until all the vertices in the same connected component as the starting vertex are visited. if there still remain unvisited vertices the algorithm has to be restarted at an arbitrary vertex of another connected component of the graph. it is convenient to use a queue note the difference from depth first search! to trace the operation of breadth first search. the queue is initialized with the traversal's starting vertex which is marked as visited. on each iteration the algorithm identifies all unvisited vertices that are adjacent to the front vertex marks them as visited and adds them to the queue after that the front vertex is removed from the queue. similarly to a dfs traversal it is useful to accompany a bfs traversal by constructing the so called breadth first search forest. the traversal's starting vertex serves as the root of the first tree in such a forest. whenever a new unvisited vertex is reached for the first time the vertex is attached as a child to the vertex it is being reached from with an edge called a tree edge. if an edge leading to a previously visited vertex other than its immediate predecessor i.e. its parent in the tree is encountered the edge is noted as a cross edge. figure . provides an example of a breadth first search traversal with the traversal queue and corresponding breadth first search forest shown. g h a g a e c f a c d e f b c d e h j g h j i d b f b i j i a b c figure . example of a bfs traversal. a graph. b traversal queue with the numbers indicating the order in which the vertices are visited i.e. added to and removed from the queue. c bfs forest with the tree and cross edges shown with solid and dotted lines respectively. here is pseudocode of the breadth first search. algorithm bfs g implements a breadth first search traversal of a given graph input graph g v e output graph g with its vertices marked with consecutive integers in the order they are visited by the bfs traversal mark each vertex in v with as a mark of being unvisited count for each vertex v in v do if v is marked with bfs v bfs v visits all the unvisited vertices connected to vertex v by a path and numbers them in the order they are visited via global variable count count count mark v with count and initialize a queue with v while the queue is not empty do for each vertex w in v adjacent to the front vertex do if w is marked with count count mark w with count add w to the queue remove the front vertex from the queue a a b c d b e e f g h c f d g a b figure . illustration of the bfs based algorithm for finding a minimum edge path. a graph. b part of its bfs tree that identifies the minimum edge path from a to g. breadth first search has the same efficiency as depth first search it is in v for the adjacency matrix representation and in v e for the adjacency list representation. unlike depth first search it yields a single ordering of vertices because the queue is a fifo first in first out structure and hence the order in which vertices are added to the queue is the same order in which they are removed from it. as to the structure of a bfs forest of an undirected graph it can also have two kinds of edges tree edges and cross edges. tree edges are the ones used to reach previously unvisited vertices. cross edges connect vertices to those visited before but unlike back edges in a dfs tree they connect vertices either on the same or adjacent levels of a bfs tree. bfs can be used to check connectivity and acyclicity of a graph essentially in the same manner as dfs can. it is not applicable however for several less straightforward applications such as finding articulation points. on the other hand it can be helpful in some situations where dfs cannot. for example bfs can be used for finding a path with the fewest number of edges between two given vertices. to do this we start a bfs traversal at one of the two vertices and stop it as soon as the other vertex is reached. the simple path from the root of the bfs tree to the second vertex is the path sought. for example path a b c g in the graph in figure . has the fewest number of edges among all the paths between vertices a and g. although the correctness of this application appears to stem immediately from the way bfs operates a mathematical proof of its validity is not quite elementary see e.g. cor section . . table . summarizes the main facts about depth first search and breadth first search. table . main facts about depth first search dfs and breadth first search bfs dfs bfs data structure a stack a queue number of vertex orderings two orderings one ordering edge types undirected graphs tree and back edges tree and cross edges applications connectivity connectivity acyclicity acyclicity articulation points minimum edge paths efficiency for adjacency matrix v v efficiency for adjacency lists v e v e exercises . . consider the following graph. f b c g d a e a. write down the adjacency matrix and adjacency lists specifying this graph. assume that the matrix rows and columns and vertices in the adjacency lists follow in the alphabetical order of the vertex labels. b. starting at vertex a and resolving ties by the vertex alphabetical order traverse the graph by depth first search and construct the corresponding depth first search tree. give the order in which the vertices were reached for the first time pushed onto the traversal stack and the order in which the vertices became dead ends popped off the stack . . if we define sparse graphs as graphs for which e o v which implementation of dfs will have a better time efficiency for such graphs the one that uses the adjacency matrix or the one that uses the adjacency lists? . let g be a graph with n vertices and m edges. a. true or false all its dfs forests for traversals starting at different vertices will have the same number of trees? b. true or false all its dfs forests will have the same number of tree edges and the same number of back edges? . traverse the graph of problem by breadth first search and construct the corresponding breadth first search tree. start the traversal at vertex a and resolve ties by the vertex alphabetical order. . prove that a cross edge in a bfs tree of an undirected graph can connect vertices only on either the same level or on two adjacent levels of a bfs tree. . a. explain how one can check a graph's acyclicity by using breadth first search. b. does either of the two traversals dfs or bfs always find a cycle faster than the other? if you answer yes indicate which of them is better and explain why it is the case if you answer no give two examples supporting your answer. . explain how one can identify connected components of a graph by using a. a depth first search. b. a breadth first search. . a graph is said to be bipartite if all its vertices can be partitioned into two disjoint subsets x and y so that every edge connects a vertex in x with a vertex in y . one can also say that a graph is bipartite if its vertices can be colored in two colors so that every edge has its vertices colored in different colors such graphs are also called colorable. for example graph i is bipartite while graph ii is not. x y x a b y x y c d i ii a. design a dfs based algorithm for checking whether a graph is bipartite. b. design a bfs based algorithm for checking whether a graph is bipartite. . write a program that for a given graph outputs a. vertices of each connected component b. its cycle or a message that the graph is acyclic . one can model a maze by having a vertex for a starting point a finishing point dead ends and all the points in the maze where more than one path can be taken and then connecting the vertices according to the paths in the maze. a. construct such a graph for the following maze. b. which traversal dfs or bfs would you use if you found yourself in a maze and why? . three jugs sime on denis poisson a famous french mathematician and physicist is said to have become interested in mathematics after encountering some version of the following old puzzle. given an pint jug full of water and two empty jugs of and pint capacity get exactly pints of water in one of the jugs by completely filling up and or emptying jugs into others. solve this puzzle by using breadth first search. summary brute force is a straightforward approach to solving a problem usually directly based on the problem statement and definitions of the concepts involved. the principal strengths of the brute force approach are wide applicability and simplicity its principal weakness is the subpar efficiency of most brute force algorithms. a first application of the brute force approach often results in an algorithm that can be improved with a modest amount of effort. the following noted algorithms can be considered as examples of the bruteforce approach . definition based algorithm for matrix multiplication . selection sort . sequential search . straightforward string matching algorithm exhaustive search is a brute force approach to combinatorial problems. it suggests generating each and every combinatorial object of the problem selecting those of them that satisfy all the constraints and then finding a desired object. the traveling salesman problem the knapsack problem and the assignment problem are typical examples of problems that can be solved at least theoretically by exhaustive search algorithms. exhaustive search is impractical for all but very small instances of problems it can be applied to. depth first search dfs and breadth first search bfs are two principal graph traversal algorithms. by representing a graph in a form of a depth first or breadth first search forest they help in the investigation of many important properties of the graph. both algorithms have the same time efficiency v for the adjacency matrix representation and v e for the adjacency list representation. 