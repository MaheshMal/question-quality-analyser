from a more general perspective most backtracking algorithms fit the following description. an output of a backtracking algorithm can be thought of as an n tuple x x . . . xn where each coordinate xi is an element of some finite linearly ordered set si. for example for the n queens problem each si is the set of integers column numbers through n. the tuple may need to satisfy some additional constraints e.g. the nonattacking requirements in the n queens problem . depending on the problem all solution tuples can be of the same length the n queens and the hamiltonian circuit problem and of different lengths the subset sum problem . a backtracking algorithm generates explicitly or implicitly a state space tree its nodes represent partially constructed tuples with the first i coordinates defined by the earlier actions of the algorithm. if such a tuple x x . . . xi is not a solution the algorithm finds the next element in si that is consistent with the values of x x . . . xi and the problem's constraints and adds it to the tuple as its i st coordinate. if such an element does not exist the algorithm backtracks to consider the next value of xi and so on. to start a backtracking algorithm the following pseudocode can be called for i x .. represents the empty tuple. algorithm backtrack x ..i gives a template of a generic backtracking algorithm input x ..i specifies first i promising components of a solution output all the tuples representing the problem's solutions if x ..i is a solution write x ..i else see problem in this section's exercises for each element x si consistent with x ..i and the constraints do x i x backtrack x ..i our success in solving small instances of three difficult problems earlier in this section should not lead you to the false conclusion that backtracking is a very efficient technique. in the worst case it may have to generate all possible candidates in an exponentially or faster growing state space of the problem at hand. the hope of course is that a backtracking algorithm will be able to prune enough branches of its state space tree before running out of time or memory or both. the success of this strategy is known to vary widely not only from problem to problem but also from one instance to another of the same problem. there are several tricks that might help reduce the size of a state space tree. one is to exploit the symmetry often present in combinatorial problems. for example the board of the n queens problem has several symmetries so that some solutions can be obtained from others by reflection or rotation. this implies in particular that we need not consider placements of the first queen in the last n columns because any solution with the first queen in square i n i n can be obtained by reflection which? from a solution with the first queen in square n i . this observation cuts the size of the tree by about half. another trick is to preassign values to one or more components of a solution as we did in the hamiltonian circuit example. data presorting in the subset sum example demonstrates potential benefits of yet another opportunity rearrange data of an instance given. it would be highly desirable to be able to estimate the size of the state space tree of a backtracking algorithm. as a rule this is too difficult to do analytically however. knuth knu suggested generating a random path from the root to a leaf and using the information about the number of choices available during the path generation for estimating the size of the tree. specifically let c be the number of values of the first component x that are consistent with the problem's constraints. we randomly select one of these values with equal probability c to move to one of the root's c children. repeating this operation for c possible values for x that are consistent with x and the other constraints we move to one of the c children of that node. we continue this process until a leaf is reached after randomly selecting values for x x . . . xn. by assuming that the nodes on level i have ci children on average we estimate the number of nodes in the tree as c c c . . . c c . . . cn. generating several such estimates and computing their average yields a useful estimation of the actual size of the tree although the standard deviation of this random variable can be large. in conclusion three things on behalf of backtracking need to be said. first it is typically applied to difficult combinatorial problems for which no efficient algorithms for finding exact solutions possibly exist. second unlike the exhaustivesearch approach which is doomed to be extremely slow for all instances of a problem backtracking at least holds a hope for solving some instances of nontrivial sizes in an acceptable amount of time. this is especially true for optimization problems for which the idea of backtracking can be further enhanced by evaluating the quality of partially constructed solutions. how this can be done is explained in the next section. third even if backtracking does not eliminate any elements of a problem's state space and ends up generating all its elements it provides a specific technique for doing so which can be of value in its own right. exercises . . a. continue the backtracking search for a solution to the four queens problem which was started in this section to find the second solution to the problem. b. explain how the board's symmetry can be used to find the second solution to the four queens problem. . a. which is the last solution to the five queens problem found by the backtracking algorithm? b. use the board's symmetry to find at least four other solutions to the problem. . a. implement the backtracking algorithm for the n queens problem in the language of your choice. run your program for a sample of n values to get the numbers of nodes in the algorithm's state space trees. compare these numbers with the numbers of candidate solutions generated by the exhaustivesearch algorithm for this problem see problem in exercises . . b. for each value of n for which you run your program in part a estimate the size of the state space tree by the method described in section . and compare the estimate with the actual number of nodes you obtained. . design a linear time algorithm that finds a solution to the n queens problem for any n . . apply backtracking to the problem of finding a hamiltonian circuit in the following graph. a b c d e f g . apply backtracking to solve the coloring problem for the graph in figure . a. . generate all permutations of by backtracking. . a. apply backtracking to solve the following instance of the subset sum problem a and d . b. will the backtracking algorithm work correctly if we use just one of the two inequalities to terminate a node as nonpromising? . the general template for backtracking algorithms which is given in the section works correctly only if no solution is a prefix to another solution to the problem. change the template's pseudocode to work correctly without this restriction. . write a program implementing a backtracking algorithm for a. the hamiltonian circuit problem. b. the m coloring problem. . puzzle pegs this puzzle like game is played on a board with small holes arranged in an equilateral triangle. in an initial position all but one of the holes are occupied by pegs as in the example shown below. a legal move is a jump of a peg over its immediate neighbor into an empty square opposite the jump removes the jumped over neighbor from the board. design and implement a backtracking algorithm for solving the following versions of this puzzle. a. starting with a given location of the empty hole find a shortest sequence of moves that eliminates pegs with no limitations on the final position of the remaining peg. b. starting with a given location of the empty hole find a shortest sequence of moves that eliminates pegs with the remaining peg at the empty hole of the initial board. 