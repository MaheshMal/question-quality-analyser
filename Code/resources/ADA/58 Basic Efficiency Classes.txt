even though the efficiency analysis framework puts together all the functions whose orders of growth differ by a constant multiple there are still infinitely many such classes. for example the exponential functions an have different orders of growth for different values of base a. therefore it may come as a surprise that the time efficiencies of a large number of algorithms fall into only a few classes. these classes are listed in table . in increasing order of their orders of growth along with their names and a few comments. you could raise a concern that classifying algorithms by their asymptotic efficiency would be of little practical use since the values of multiplicative constants are usually left unspecified. this leaves open the possibility of an algorithm in a worse efficiency class running faster than an algorithm in a better efficiency class for inputs of realistic sizes. for example if the running time of one algorithm is n while the running time of the other is n the cubic algorithm will outperform the quadratic algorithm unless n exceeds . a few such anomalies are indeed known. fortunately multiplicative constants usually do not differ that drastically. as a rule you should expect an algorithm from a better asymptotic efficiency class to outperform an algorithm from a worse class even for moderately sized inputs. this observation is especially true for an algorithm with a better than exponential running time versus an exponential or worse algorithm. exercises . . use the most appropriate notation among o and to indicate the time efficiency class of sequential search see section . a. in the worst case. b. in the best case. c. in the average case. . use the informal definitions of o and to determine whether the following assertions are true or false. table . basic asymptotic efficiency classes class name comments constant short of best case efficiencies very few reasonable examples can be given since an algorithm's running time typically goes to infinity when its input size grows infinitely large. log n logarithmic typically a result of cutting a problem's size by a constant factor on each iteration of the algorithm see section . . note that a logarithmic algorithm cannot take into account all its input or even a fixed fraction of it any algorithm that does so will have at least linear running time. n linear algorithms that scan a list of size n e.g. sequential search belong to this class. n log n linearithmic many divide and conquer algorithms see chapter including mergesort and quicksort in the average case fall into this category. n quadratic typically characterizes efficiency of algorithms with two embedded loops see the next section . elementary sorting algorithms and certain operations on n n matrices are standard examples. n cubic typically characterizes efficiency of algorithms with three embedded loops see the next section . several nontrivial algorithms from linear algebra fall into this class. n exponential typical for algorithms that generate all subsets of an n element set. often the term exponential is used in a broader sense to include this and larger orders of growth as well. n! factorial typical for algorithms that generate all permutations of an n element set. a. n n o n b. n n o n c. n n n d. n n n . for each of the following functions indicate the class g n the function belongs to. use the simplest g n possible in your answers. prove your assertions. a. n b. n n c. n lg n n lg n d. n n e. log n . a. table . contains values of several functions that often arise in the analysis of algorithms. these values certainly suggest that the functions log n n n log n n n n n! are listed in increasing order of their order of growth. do these values prove this fact with mathematical certainty? b. prove that the functions are indeed listed in increasing order of their order of growth. . list the following functions according to their order of growth from the lowest to the highest n ! lg n n . n n ln n n n. . a. prove that every polynomial of degree k p n aknk ak nk . . . a with ak belongs to nk . b. prove that exponential functions an have different orders of growth for different values of base a . . prove the following assertions by using the definitions of the notations involved or disprove them by giving a specific counterexample. a. if t n o g n then g n t n . b. g n g n where . c. g n o g n g n . d. for any two nonnegative functions t n and g n defined on the set of nonnegative integers either t n o g n or t n g n or both. . prove the section's theorem for a. notation. b. notation. . we mentioned in this section that one can check whether all elements of an array are distinct by a two part algorithm based on the array's presorting. a. if the presorting is done by an algorithm with a time efficiency in n log n what will be a time efficiency class of the entire algorithm? b. if the sorting algorithm used for presorting needs an extra array of size n what will be the space efficiency class of the entire algorithm? . the range of a finite nonempty set of n real numbers s is defined as the difference between the largest and smallest elements of s. for each representation of s given below describe in english an algorithm to compute the range. indicate the time efficiency classes of these algorithms using the most appropriate notation o or . a. an unsorted array b. a sorted array c. a sorted singly linked list d. a binary search tree . lighter or heavier? you have n identical looking coins and a two pan balance scale with no weights. one of the coins is a fake but you do not know whether it is lighter or heavier than the genuine coins which all weigh the same. design a algorithm to determine whether the fake coin is lighter or heavier than the others. . door in a wall you are facing a wall that stretches infinitely in both directions. there is a door in the wall but you know neither how far away nor in which direction. you can see the door only when you are right next to it. design an algorithm that enables you to reach the door by walking at most o n steps where n is the unknown to you number of steps between your initial position and the door. par 