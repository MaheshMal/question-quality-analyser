we usually want our algorithms to possess several qualities. after correctness by far the most important is efficiency. in fact there are two kinds of algorithm efficiency time efficiency indicating how fast the algorithm runs and space efficiency indicating how much extra memory it uses. a general framework and specific techniques for analyzing an algorithm's efficiency appear in chapter . another desirable characteristic of an algorithm is simplicity. unlike efficiency which can be precisely defined and investigated with mathematical rigor simplicity like beauty is to a considerable degree in the eye of the beholder. for example most people would agree that euclid's algorithm is simpler than the middle school procedure for computing gcd m n but it is not clear whether euclid's algorithm is simpler than the consecutive integer checking algorithm. still simplicity is an important algorithm characteristic to strive for. why? because simpler algorithms are easier to understand and easier to program consequently the resulting programs usually contain fewer bugs. there is also the undeniable aesthetic appeal of simplicity. sometimes simpler algorithms are also more efficient than more complicated alternatives. unfortunately it is not always true in which case a judicious compromise needs to be made. yet another desirable characteristic of an algorithm is generality. there are in fact two issues here generality of the problem the algorithm solves and the set of inputs it accepts. on the first issue note that it is sometimes easier to design an algorithm for a problem posed in more general terms. consider for example the problem of determining whether two integers are relatively prime i.e. whether their only common divisor is equal to . it is easier to design an algorithm for a more general problem of computing the greatest common divisor of two integers and to solve the former problem check whether the gcd is or not. there are situations however where designing a more general algorithm is unnecessary or difficult or even impossible. for example it is unnecessary to sort a list of n numbers to find its median which is its n th smallest element. to give another example the standard formula for roots of a quadratic equation cannot be generalized to handle polynomials of arbitrary degrees. as to the set of inputs your main concern should be designing an algorithm that can handle a set of inputs that is natural for the problem at hand. for example excluding integers equal to as possible inputs for a greatest common divisor algorithm would be quite unnatural. on the other hand although the standard formula for the roots of a quadratic equation holds for complex coefficients we would normally not implement it on this level of generality unless this capability is explicitly required. if you are not satisfied with the algorithm's efficiency simplicity or generality you must return to the drawing board and redesign the algorithm. in fact even if your evaluation is positive it is still worth searching for other algorithmic solutions. recall the three different algorithms in the previous section for computing the greatest common divisor generally you should not expect to get the best algorithm on the first try. at the very least you should try to fine tune the algorithm you already have. for example we made several improvements in our implementation of the sieve of eratosthenes compared with its initial outline in section . . can you identify them? you will do well if you keep in mind the following observation of antoine de saint exupe ry the french writer pilot and aircraft designer a designer knows he has arrived at perfection not when there is no longer anything to add but when there is no longer anything to take away. 