we will be able to apply the branch and bound technique to instances of the traveling salesman problem if we come up with a reasonable lower bound on tour lengths. one very simple lower bound can be obtained by finding the smallest element in the intercity distance matrix d and multiplying it by the number of cities n. but there is a less obvious and more informative lower bound for instances with symmetric matrix d which does not require a lot of work to compute. it is not difficult to show problem in this section's exercises that we can compute a lower bound on the length l of any tour as follows. for each city i i n find the sum si of the distances from city i to the two nearest cities compute the sum s of these n numbers divide the result by and if all the distances are integers round up the result to the nearest integer lb s . . for example for the instance in figure . a formula . yields lb . moreover for any subset of tours that must include particular edges of a given graph we can modify lower bound . accordingly. for example for all the hamiltonian circuits of the graph in figure . a that must include edge a d we get the following lower bound by summing up the lengths of the two shortest edges incident with each of the vertices with the required inclusion of edges a d and d a . we now apply the branch and bound algorithm with the bounding function given by formula . to find the shortest hamiltonian circuit for the graph in a b a lb a b a c a d a e c d lb lb lb x x x b is not lb l lb l before c e of node of node a a b c a b d a b e lb lb lb x lb l of node a b c d a b c e a b d c a b d e e a d a e a c a l l l l first tour better tour inferior tour optimal tour b figure . a weighted graph. b state space tree of the branch and bound algorithm to find a shortest hamiltonian circuit in this graph. the list of vertices in a node specifies a beginning part of the hamiltonian circuits represented by the node. figure . a. to reduce the amount of potential work we take advantage of two observations made in section . . first without loss of generality we can consider only tours that start at a. second because our graph is undirected we can generate only tours in which b is visited before c. in addition after visiting n cities a tour has no choice but to visit the remaining unvisited city and return to the starting one. the state space tree tracing the algorithm's application is given in figure . b. the comments we made at the end of the preceding section about the strengths and weaknesses of backtracking are applicable to branch and bound as well. to reiterate the main point these state space tree techniques enable us to solve many large instances of difficult combinatorial problems. as a rule however it is virtually impossible to predict which instances will be solvable in a realistic amount of time and which will not. incorporation of additional information such as a symmetry of a game's board can widen the range of solvable instances. along this line a branch andbound algorithm can be sometimes accelerated by a knowledge of the objective function's value of some nontrivial feasible solution. the information might be obtainable say by exploiting specifics of the data or even for some problems generated randomly before we start developing a state space tree. then we can use such a solution immediately as the best one seen so far rather than waiting for the branch and bound processing to lead us to the first feasible solution. in contrast to backtracking solving a problem by branch and bound has both the challenge and opportunity of choosing the order of node generation and finding a good bounding function. though the best first rule we used above is a sensible approach it may or may not lead to a solution faster than other strategies. artificial intelligence researchers are particularly interested in different strategies for developing state space trees. finding a good bounding function is usually not a simple task. on the one hand we want this function to be easy to compute. on the other hand it cannot be too simplistic otherwise it would fail in its principal task to prune as many branches of a state space tree as soon as possible. striking a proper balance between these two competing requirements may require intensive experimentation with a wide variety of instances of the problem in question. exercises . . what data structure would you use to keep track of live nodes in a best first branch and bound algorithm? . solve the same instance of the assignment problem as the one solved in the section by the best first branch and bound algorithm with the bounding function based on matrix columns rather than rows. . a. give an example of the best case input for the branch and bound algorithm for the assignment problem. b. in the best case how many nodes will be in the state space tree of the branch and bound algorithm for the assignment problem? . write a program for solving the assignment problem by the branch and bound algorithm. experiment with your program to determine the average size of the cost matrices for which the problem is solved in a given amount of time say minute on your computer. . solve the following instance of the knapsack problem by the branch andbound algorithm item weight value w . a. suggest a more sophisticated bounding function for solving the knapsack problem than the one used in the section. b. use your bounding function in the branch and bound algorithm applied to the instance of problem . . write a program to solve the knapsack problem with the branch and bound algorithm. . a. prove the validity of the lower bound given by formula . for instances of the traveling salesman problem with symmetric matrices of integer intercity distances. b. how would you modify lower bound . for nonsymmetric distance matrices? . apply the branch and bound algorithm to solve the traveling salesman problem for the following graph a b c d we solved this problem by exhaustive search in section . . . as a research project write a report on how state space trees are used for programming such games as chess checkers and tic tac toe. the two principal algorithms you should read about are the minimax algorithm and alpha beta pruning. 