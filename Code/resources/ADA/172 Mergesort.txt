mergesort is a perfect example of a successful application of the divide andconquer technique. it sorts a given array a ..n by dividing it into two halves a .. n and a n ..n sorting each of them recursively and then merging the two smaller sorted arrays into a single sorted one. algorithm mergesort a ..n sorts array a ..n by recursive mergesort input an array a ..n of orderable elements output array a ..n sorted in nondecreasing order if n copy a .. n to b .. n copy a n ..n to c .. n mergesort b .. n mergesort c .. n merge b c a see below the merging of two sorted arrays can be done as follows. two pointers array indices are initialized to point to the first elements of the arrays being merged. the elements pointed to are compared and the smaller of them is added to a new array being constructed after that the index of the smaller element is incremented to point to its immediate successor in the array it was copied from. this operation is repeated until one of the two given arrays is exhausted and then the remaining elements of the other array are copied to the end of the new array. algorithm merge b ..p c ..q a ..p q merges two sorted arrays into one sorted array input arrays b ..p and c ..q both sorted output sorted array a ..p q of the elements of b and c i j k while i p and j q do if b i c j a k b i i i else a k c j j j kk if i p copy c j..q to a k..p q else copy b i..p to a k..p q the operation of the algorithm on the list is illustrated in figure . . figure . example of mergesort operation. how efficient is mergesort? assuming for simplicity that n is a power of the recurrence relation for the number of key comparisons c n is c n c n cmerge n for n c . let us analyze cmerge n the number of key comparisons performed during the merging stage. at each step exactly one comparison is made after which the total number of elements in the two arrays still needing to be processed is reduced by . in the worst case neither of the two arrays becomes empty before the other one contains just one element e.g. smaller elements may come from the alternating arrays . therefore for the worst case cmerge n n and we have the recurrence cworst n cworst n n for n cworst . hence according to the master theorem cworst n n log n why? . in fact it is easy to find the exact solution to the worst case recurrence for n k cworst n n log n n . the number of key comparisons made by mergesort in the worst case comes very close to the theoretical minimum that any general comparison based sorting algorithm can have. for large n the number of comparisons made by this algorithm in the average case turns out to be about . n less see gon p. and hence is also in n log n . a noteworthy advantage of mergesort over quicksort and heapsort the two important advanced sorting algorithms to be discussed later is its stability see problem in this section's exercises . the principal shortcoming of mergesort is the linear amount of extra storage the algorithm requires. though merging can be done in place the resulting algorithm is quite complicated and of theoretical interest only. there are two main ideas leading to several variations of mergesort. first the algorithm can be implemented bottom up by merging pairs of the array's elements then merging the sorted pairs and so on. if n is not a power of only slight bookkeeping complications arise. this avoids the time and space overhead of using a stack to handle recursive calls. second we can divide a list to be sorted in more than two parts sort each recursively and then merge them together. this scheme which is particularly useful for sorting files residing on secondary memory devices is called multiway mergesort. exercises . . a. write pseudocode for a divide and conquer algorithm for finding the position of the largest element in an array of n numbers. b. what will be your algorithm's output for arrays with several elements of the largest value? c. set up and solve a recurrence relation for the number of key comparisons made by your algorithm. d. how does this algorithm compare with the brute force algorithm for this problem? . a. write pseudocode for a divide and conquer algorithm for finding values of both the largest and smallest elements in an array of n numbers. b. set up and solve for n k a recurrence relation for the number of key comparisons made by your algorithm. c. how does this algorithm compare with the brute force algorithm for this problem? . a. write pseudocode for a divide and conquer algorithm for the exponentiation problem of computing an where n is a positive integer. b. set up and solve a recurrence relation for the number of multiplications made by this algorithm. . as we shall see in section . this theoretical minimum is log n! n log n . n . c. how does this algorithm compare with the brute force algorithm for this problem? . as mentioned in chapter logarithm bases are irrelevant in most contexts arising in analyzing an algorithm's efficiency class. is this true for both assertions of the master theorem that include logarithms? . find the order of growth for solutions of the following recurrences. a. t n t n n t b. t n t n n t c. t n t n n t . apply mergesort to sort the list e x a m p l e in alphabetical order. . is mergesort a stable sorting algorithm? . a. solve the recurrence relation for the number of key comparisons made by mergesort in the worst case. you may assume that n k. b. set up a recurrence relation for the number of key comparisons made by mergesort on best case inputs and solve it for n k. c. set up a recurrence relation for the number of key moves made by the version of mergesort given in section . . does taking the number of key moves into account change the algorithm's efficiency class? . let a ..n be an array of n real numbers. a pair a i a j is said to be an inversion if these numbers are out of order i.e. i j but a i a j . design an o n log n algorithm for counting the number of inversions. . implement the bottom up version of mergesort in the language of your choice. . tromino puzzle a tromino more accurately a right tromino is an l shaped tile formed by three squares. the problem is to cover any n n chessboard with a missing square with trominoes. trominoes can be oriented in an arbitrary way but they should cover all the squares of the board except the missing one exactly and with no overlaps. gol design a divide and conquer algorithm for this problem. 