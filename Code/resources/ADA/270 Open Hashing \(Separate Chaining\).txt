in open hashing keys are stored in linked lists attached to cells of a hash table. each list contains all the keys hashed to its cell. consider as an example the following list of words a fool and his money are soon parted. as a hash function we will use the simple function for strings mentioned above i.e. we will add the positions of a word's letters in the alphabet and compute the sum's remainder after division by . we start with the empty table. the first key is the word a its hash value is h a mod . the second key the word fool is installed in the ninth cell since mod and so on. the final result of this process is given in figure . note a collision of the keys are and soon because h are mod and h soon mod . how do we search in a dictionary implemented as such a table of linked lists? we do this by simply applying to a search key the same procedure that was used for creating the table. to illustrate if we want to search for the key kid in the hash table of figure . we first compute the value of the same hash function for the key h kid . since the list attached to cell is not empty its linked list may contain the search key. but because of possible collisions we cannot tell whether this is the case until we traverse this linked list. after comparing the string kid first with the string are and then with the string soon we end up with an unsuccessful search. in general the efficiency of searching depends on the lengths of the linked lists which in turn depend on the dictionary and table sizes as well as the quality keys a fool and his money are soon parted hash addresses a and money fool his are parted soon figure . example of a hash table construction with separate chaining. of the hash function. if the hash function distributes n keys among m cells of the hash table about evenly each list will be about n m keys long. the ratio n m called the load factor of the hash table plays a crucial role in the efficiency of hashing. in particular the average number of pointers chain links inspected in successful searches s and unsuccessful searches u turns out to be s and u . respectively under the standard assumptions of searching for a randomly selected element and a hash function distributing keys uniformly among the table's cells. these results are quite natural. indeed they are almost identical to searching sequentially in a linked list what we have gained by hashing is a reduction in average list size by a factor of m the size of the hash table. normally we want the load factor to be not far from . having it too small would imply a lot of empty lists and hence inefficient use of space having it too large would mean longer linked lists and hence longer search times. but if we do have the load factor around we have an amazingly efficient scheme that makes it possible to search for a given key for on average the price of one or two comparisons! true in addition to comparisons we need to spend time on computing the value of the hash function for a search key but it is a constant time operation independent from n and m. note that we are getting this remarkable efficiency not only as a result of the method's ingenuity but also at the expense of extra space. the two other dictionary operations insertion and deletion are almost identical to searching. insertions are normally done at the end of a list but see problem in this section's exercises for a possible modification of this rule . deletion is performed by searching for a key to be deleted and then removing it from its list. hence the efficiency of these operations is identical to that of searching and they are all in the average case if the number of keys n is about equal to the hash table's size m. 