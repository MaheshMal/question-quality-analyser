there are several well known games that share the following features. there are two players who move in turn. no randomness or hidden information is permitted all players know all information about gameplay. a game is impartial each player has the same moves available from the same game position. each of a finite number of available moves leads to a smaller instance of the same game. the game ends with a win by one of the players there are no ties . the winner is the last player who is able to move. a prototypical example of such games is nim. generally the game is played with several piles of chips but we consider the one pile version first. thus there is a single pile of n chips. two players take turns by removing from the pile at least one and at most m chips the number of chips taken may vary from one move to another but both the lower and upper limits stay the same. who wins the game by taking the last chip the player moving first or second if both players make the best moves possible? let us call an instance of the game a winning position for the player to move next if that player has a winning strategy i.e. a sequence of moves that results in a victory no matter what moves the opponent makes. let us call an instance of the game a losing position for the player to move next if every move available for that player leads to a winning position for the opponent. the standard approach to determining which positions are winning and which are losing is to investigate small values of n first. it is logical to consider the instance of n as a losing one for the player to move next because this player is the first one who cannot make a move. any instance with n m chips is obviously a winning position for the player to move next why? . the instance with n m chips is a losing one because taking any allowed number of chips puts the opponent in a winning position. see an illustration for m in figure . . any instance with m n m chips is a winning position for the player to move next because there is a move that leaves the opponent with m chips which is a losing figure . illustration of one pile nim with the maximum number of chips that may be taken on each move m . the numbers indicate n the number of chips in the pile. the losing positions for the player to move are circled. only winning moves from the winning positions are shown in bold . position. m m chips is the next losing position and so on. it is not difficult to see the pattern that can be formally proved by mathematical induction an instance with n chips is a winning position for the player to move next if and only if n is not a multiple of m . the winning strategy is to take n mod m chips on every move any deviation from this strategy puts the opponent in a winning position. one pile nim has been known for a very long time. it appeared in particular as the summation game in the first published book on recreational mathematics authored by claude gaspar bachet a french aristocrat and mathematician in a player picks a positive integer less than say and then his opponent and he take turns adding any integer less than the first player to reach exactly is the winner dud . in general nim is played with i piles of chips of sizes n n . . . ni . on each move a player can take any available number of chips including all of them from any single pile. the goal is the same to be the last player able to make a move. note that for i it is easy to figure out who wins this game and how. here is a hint the answer for the game's instances with n n differs from the answer for those with n n . a solution to the general case of nim is quite unexpected because it is based on the binary representation of the pile sizes. let b b . . . bi be the pile sizes in binary. compute their binary digital sum also known as the nim sum defined as the sum of binary digits discarding any carry. in other words a binary digit si in the sum is if the number of 's in the ith position in the addends is even and it is if the number of 's is odd. it turns out that an instance of nim is a winning one for the player to move next if and only if its nim sum contains at least one consequently nim's instance is a losing instance if and only if its nim sum contains only zeros. for example for the commonly played instance with n n n the nim sum is since this sum contains a the instance is a winning one for the player moving first. to find a winning move from this position the player needs to change one of the three bit strings so that the new nim sum contains only 's. it is not difficult to see that the only way to accomplish this is to remove two chips from the first pile. this ingenious solution to the game of nim was discovered by harvard mathematics professor c. l. bouton more than years ago. since then mathematicians have developed a much more general theory of such games. an excellent account of this theory with applications to many specific games is given in the monograph by e. r. berlekamp j. h. conway and r. k. guy ber . exercises . . a. if we measure an instance size of computing the greatest common divisor of m and n by the size of the second number n by how much can the size decrease after one iteration of euclid's algorithm? b. prove that an instance size will always decrease at least by a factor of two after two successive iterations of euclid's algorithm. . apply quickselect to find the median of the list of numbers . . write pseudocode for a nonrecursive implementation of quickselect. . derive the formula underlying interpolation search. . give an example of the worst case input for interpolation search and show that the algorithm is linear in the worst case. . a. find the smallest value of n for which log log n is greater than . b. determine which if any of the following assertions are true i. log log n o log n ii. log log n log n iii. log log n log n . a. outline an algorithm for finding the largest key in a binary search tree. would you classify your algorithm as a variable size decrease algorithm? b. what is the time efficiency class of your algorithm in the worst case? . a. outline an algorithm for deleting a key from a binary search tree. would you classify this algorithm as a variable size decrease algorithm? b. what is the time efficiency class of your algorithm in the worst case? . outline a variable size decrease algorithm for constructing an eulerian circuit in a connected graph with all vertices of even degrees. . mise re one pile nim consider the so called mise re version of the one pile nim in which the player taking the last chip loses the game. all the other conditions of the game remain the same i.e. the pile contains n chips and on each move a player takes at least one but no more than m chips. identify the winning and losing positions for the player to move next in this game. . a. moldy chocolate two players take turns by breaking an m n chocolate bar which has one spoiled square. each break must be a single straight line cutting all the way across the bar along the boundaries between the squares. after each break the player who broke the bar last eats the piece that does not contain the spoiled square. the player left with the spoiled square loses the game. is it better to go first or second in this game? b. write an interactive program to play this game with the computer. your program should make a winning move in a winning position and a random legitimate move in a losing position. . flipping pancakes there are n pancakes all of different sizes that are stacked on top of each other. you are allowed to slip a flipper under one of the pancakes and flip over the whole stack above the flipper. the purpose is to arrange pancakes according to their size with the biggest at the bottom. you can see a visualization of this puzzle on the interactive mathematics miscellany and puzzles site bog . design an algorithm for solving this puzzle. . you need to search for a given number in an n n matrix in which every row and every column is sorted in increasing order. can you design a o n algorithm for this problem? laa summary decrease and conquer is a general algorithm design technique based on exploiting a relationship between a solution to a given instance of a problem and a solution to a smaller instance of the same problem. once such a relationship is established it can be exploited either top down usually recursively or bottom up. there are three major variations of decrease and conquer . decrease by a constant most often by one e.g. insertion sort . decrease by a constant factor most often by the factor of two e.g. binary search . variable size decrease e.g. euclid's algorithm insertion sort is a direct application of the decrease by one and conquer technique to the sorting problem. it is a n algorithm both in the worst and average cases but it is about twice as fast on average than in the worst case. the algorithm's notable advantage is a good performance on almost sorted arrays. a digraph is a graph with directions on its edges. the topological sorting problem asks to list vertices of a digraph in an order such that for every edge of the digraph the vertex it starts at is listed before the vertex it points to. this problem has a solution if and only if a digraph is a dag directed acyclic graph i.e. it has no directed cycles. there are two algorithms for solving the topological sorting problem. the first one is based on depth first search the second is based on a direct application of the decrease by one technique. the decrease by one technique is a natural approach to developing algorithms for generating elementary combinatorial objects. the most efficient class of such algorithms are minimal change algorithms. however the number of combinatorial objects grows so fast that even the best algorithms are of practical interest only for very small instances of such problems. binary search is a very efficient algorithm for searching in a sorted array. it is a principal example of a decrease by a constant factor algorithm. other examples include exponentiation by squaring identifying a fake coin with a balance scale russian peasant multiplication and the josephus problem. for some decrease and conquer algorithms the size reduction varies from one iteration of the algorithm to another. examples of such variable sizedecrease algorithms include euclid's algorithm the partition based algorithm for the selection problem interpolation search and searching and insertion in a binary search tree. nim exemplifies games that proceed through a series of diminishing instances of the same game. 