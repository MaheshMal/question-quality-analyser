kruskal's algorithm is one of a number of applications that require a dynamic partition of some n element set s into a collection of disjoint subsets s s . . . sk. after being initialized as a collection of n one element subsets each containing a different element of s the collection is subjected to a sequence of intermixed union and find operations. note that the number of union operations in any such sequence must be bounded above by n because each union increases a subset's size at least by and there are only n elements in the entire set s. thus we are dealing here with an abstract data type of a collection of disjoint subsets of a finite set with the following operations makeset x creates a one element set x . it is assumed that this operation can be applied to each of the elements of set s only once. find x returns a subset containing x. union x y constructs the union of the disjoint subsets sx and sy containing x and y respectively and adds it to the collection to replace sx and sy which are deleted from it. for example let s . then makeset i creates the set i and applying this operation six times initializes the structure to the collection of six singleton sets . performing union and union yields and if followed by union and then by union we end up with the disjoint subsets . most implementations of this abstract data type use one element from each of the disjoint subsets in a collection as that subset's representative. some implementations do not impose any specific constraints on such a representative others do so by requiring say the smallest element of each subset to be used as the subset's representative. also it is usually assumed that set elements are or can be mapped into integers. there are two principal alternatives for implementing this data structure. the first one called the quick find optimizes the time efficiency of the find operation the second one called the quick union optimizes the union operation. the quick find uses an array indexed by the elements of the underlying set s the array's values indicate the representatives of the subsets containing those elements. each subset is implemented as a linked list whose header contains the pointers to the first and last elements of the list along with the number of elements in the list see figure . for an example . under this scheme the implementation of makeset x requires assigning the corresponding element in the representative array to x and initializing the corresponding linked list to a single node with the x value. the time efficiency of this operation is obviously in and hence the initialization of n singleton subsets is in n . the efficiency of find x is also in all we need to do is to retrieve the x's representative in the representative array. executing union x y takes longer. a straightforward solution would simply append the y's list to the end of the x's list update the information about their representative for all the elements in the subset representatives element index representative size last first list null list null null list null list null null list null null list null null figure . linked list representation of subsets and obtained by quick find after performing union union union and union . the lists of size are considered deleted from the collection. y list and then delete the y's list from the collection. it is easy to verify however that with this algorithm the sequence of union operations union union . . . union i i . . . union n n runs in n time which is slow compared with several known alternatives. a simple way to improve the overall efficiency of a sequence of union operations is to always append the shorter of the two lists to the longer one with ties broken arbitrarily. of course the size of each list is assumed to be available by say storing the number of elements in the list's header. this modification is called the a b figure . a forest representation of subsets and used by quick union. b result of union . union by size. though it does not improve the worst case efficiency of a single application of the union operation it is still in n the worst case running time of any legitimate sequence of union by size operations turns out to be in o n log n . here is a proof of this assertion. let ai be an element of set s whose disjoint subsets we manipulate and let ai be the number of times ai's representative is updated in a sequence of union by size operations. how large can ai get if set s has n elements? each time ai's representative is updated ai must be in a smaller subset involved in computing the union whose size will be at least twice as large as the size of the subset containing ai. hence when ai's representative is updated for the first time the resulting set will have at least two elements when it is updated for the second time the resulting set will have at least four elements and in general if it is updated ai times the resulting set will have at least ai elements. since the entire set s has n elements ai n and hence ai log n. therefore the total number of possible updates of the representatives for all n elements in s will not exceed n log n. thus for union by size the time efficiency of a sequence of at most n unions and m finds is in o n log n m . the quick union the second principal alternative for implementing disjoint subsets represents each subset by a rooted tree. the nodes of the tree contain the subset's elements one per node with the root's element considered the subset's representative the tree's edges are directed from children to their parents figure . . in addition a mapping of the set elements to their tree nodes implemented say as an array of pointers is maintained. this mapping is not shown in figure . for the sake of simplicity. for this implementation makeset x requires the creation of a single node tree which is a operation hence the initialization of n singleton subsets is in n . a union x y is implemented by attaching the root of the y's tree to the root of the x's tree and deleting the y's tree from the collection by making the pointer to its root null . the time efficiency of this operation is clearly . a find x is . this is a specific example of the usefulness of the amortized efficiency we mentioned back in chapter . x t t t x t t t t t figure . path compression. performed by following the pointer chain from the node containing x to the tree's root whose element is returned as the subset's representative. accordingly the time efficiency of a single find operation is in o n because a tree representing a subset can degenerate into a linked list with n nodes. this time bound can be improved. the straightforward way for doing so is to always perform a union operation by attaching a smaller tree to the root of a larger one with ties broken arbitrarily. the size of a tree can be measured either by the number of nodes this version is called union by size or by its height this version is called union by rank . of course these options require storing for each node of the tree either the number of node descendants or the height of the subtree rooted at that node respectively. one can easily prove that in either case the height of the tree will be logarithmic making it possible to execute each find in o log n time. thus for quick union the time efficiency of a sequence of at most n unions and m finds is in o n m log n . in fact an even better efficiency can be obtained by combining either variety of quick union with path compression. this modification makes every node encountered during the execution of a find operation point to the tree's root figure . . according to a quite sophisticated analysis that goes beyond the level of this book see tar this and similar techniques improve the efficiency of a sequence of at most n unions and m finds to only slightly worse than linear. exercises . . apply kruskal's algorithm to find a minimum spanning tree of the following graphs. a. b c a d e b. a b c d e f g h i j k l . indicate whether the following statements are true or false a. if e is a minimum weight edge in a connected weighted graph it must be among edges of at least one minimum spanning tree of the graph. b. if e is a minimum weight edge in a connected weighted graph it must be among edges of each minimum spanning tree of the graph. c. if edge weights of a connected weighted graph are all distinct the graph must have exactly one minimum spanning tree. d. if edge weights of a connected weighted graph are not all distinct the graph must have more than one minimum spanning tree. . what changes if any need to be made in algorithm kruskal to make it find a minimum spanning forest for an arbitrary graph? a minimum spanning forest is a forest whose trees are minimum spanning trees of the graph's connected components. . does kruskal's algorithm work correctly on graphs that have negative edge weights? . design an algorithm for finding a maximum spanning tree a spanning tree with the largest possible edge weight of a weighted connected graph. . rewrite pseudocode of kruskal's algorithm in terms of the operations of the disjoint subsets' adt. . prove the correctness of kruskal's algorithm. . prove that the time efficiency of find x is in o log n for the union by size version of quick union. . find at least two web sites with animations of kruskal's and prim's algorithms. discuss their merits and demerits. . design and conduct an experiment to empirically compare the efficiencies of prim's and kruskal's algorithms on random graphs of different sizes and densities. . steiner tree four villages are located at the vertices of a unit square in the euclidean plane. you are asked to connect them by the shortest network of roads so that there is a path between every pair of the villages along those roads. find such a network. . write a program generating a random maze based on a. prim's algorithm. b. kruskal's algorithm. 