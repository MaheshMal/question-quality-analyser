the simplest method of obtaining a lower bound class is based on counting the number of items in the problem's input that must be processed and the number of output items that need to be produced. since any algorithm must at least read all the items it needs to process and write all its outputs such a count yields a trivial lower bound. for example any algorithm for generating all permutations of n distinct items must be in n! because the size of the output is n!. and this bound is tight because good algorithms for generating permutations spend a constant time on each of them except the initial one see section . . as another example consider the problem of evaluating a polynomial of degree n p x anxn an xn . . . a at a given point x given its coefficients an an . . . a . it is easy to see that all the coefficients have to be processed by any polynomial evaluation algorithm. indeed if it were not the case we could change the value of an unprocessed coefficient which would change the value of the polynomial at a nonzero point x. this means that any such algorithm must be in n . this lower bound is tight because both the right to left evaluation algorithm problem in exercises . and horner's rule section . are both linear. in a similar vein a trivial lower bound for computing the product of two n n matrices is n because any such algorithm has to process n elements in the input matrices and generate n elements of the product. it is still unknown however whether this bound is tight. trivial lower bounds are often too low to be useful. for example the trivial bound for the traveling salesman problem is n because its input is n n intercity distances and its output is a list of n cities making up an optimal tour. but this bound is all but useless because there is no known algorithm with the running time being a polynomial function of any degree. there is another obstacle to deriving a meaningful lower bound by this method. it lies in determining which part of an input must be processed by any algorithm solving the problem in question. for example searching for an element of a given value in a sorted array does not require processing all its elements why? . as another example consider the problem of determining connectivity of an undirected graph defined by its adjacency matrix. it is plausible to expect that any such algorithm would have to check the existence of each of the n n potential edges but the proof of this fact is not trivial. 