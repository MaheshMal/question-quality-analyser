in this section we shall see how decision trees can be used for establishing lower bounds on the number of key comparisons in searching a sorted array of n keys a a . . . a n . the principal algorithm for this problem is binary search. as we saw in section . the number of comparisons made by binary search in the worst case cwbsorst n is given by the formula cwbsorst n log n log n . . a a a a a a a a a a a a a a a a figure . ternary decision tree for binary search in a four element array. we will use decision trees to determine whether this is the smallest possible number of comparisons. since we are dealing here with three way comparisons in which search key k is compared with some element a i to see whether k a i k a i or k a i it is natural to try using ternary decision trees. figure . presents such a tree for the case of n . the internal nodes of that tree indicate the array's elements being compared with the search key. the leaves indicate either a matching element in the case of a successful search or a found interval that the search key belongs to in the case of an unsuccessful search. we can represent any algorithm for searching a sorted array by three way comparisons with a ternary decision tree similar to that in figure . . for an array of n elements all such decision trees will have n leaves n for successful searches and n for unsuccessful ones . since the minimum height h of a ternary tree with l leaves is log l we get the following lower bound on the number of worst case comparisons cworst n log n . this lower bound is smaller than log n the number of worst case comparisons for binary search at least for large values of n and smaller than or equal to log n for every positive integer n see problem in this section's exercises . can we prove a better lower bound or is binary search far from being optimal? the answer turns out to be the former. to obtain a better lower bound we should consider binary rather than ternary decision trees such as the one in figure . . internal nodes in such a tree correspond to the same threeway comparisons as before but they also serve as terminal nodes for successful searches. leaves therefore represent only unsuccessful searches and there are n of them for searching an n element array. a a a a a a a a a a a a figure . binary decision tree for binary search in a four element array. as comparison of the decision trees in figures . and . illustrates the binary decision tree is simply the ternary decision tree with all the middle subtrees eliminated. applying inequality . to such binary decision trees immediately yields cworst n log n . . this inequality closes the gap between the lower bound and the number of worstcase comparisons made by binary search which is also log n . a much more sophisticated analysis see e.g. knuiii section . . shows that under the standard assumptions about searches binary search makes the smallest number of comparisons on the average as well. the average number of comparisons made by this algorithm turns out to be about log n and log n for successful and unsuccessful searches respectively. exercises . . prove by mathematical induction that a. h log l for any binary tree with height h and the number of leaves l. b. h log l for any ternary tree with height h and the number of leaves l. . consider the problem of finding the median of a three element set a b c of orderable items. a. what is the information theoretic lower bound for comparison based algorithms solving this problem? b. draw a decision tree for an algorithm solving this problem. c. if the worst case number of comparisons in your algorithm is greater than the information theoretic lower bound do you think an algorithm matching the lower bound exists? either find such an algorithm or prove its impossibility. . draw a decision tree and find the number of key comparisons in the worst and average cases for a. the three element basic bubble sort. b. the three element enhanced bubble sort which stops if no swaps have been made on its last pass . . design a comparison based algorithm for sorting a four element array with the smallest number of element comparisons possible. . design a comparison based algorithm for sorting a five element array with seven comparisons in the worst case. . draw a binary decision tree for searching a four element sorted list by sequential search. . compare the two lower bounds for searching a sorted array log n and log n to show that a. log n log n for every positive integer n. b. log n log n for every positive integer n n . . what is the information theoretic lower bound for finding the maximum of n numbers by comparison based algorithms? is this bound tight? . a tournament tree is a complete binary tree reflecting results of a knockout tournament its leaves represent n players entering the tournament and each internal node represents a winner of a match played by the players represented by the node's children. hence the winner of the tournament is represented by the root of the tree. a. what is the total number of games played in such a tournament? b. how many rounds are there in such a tournament? c. design an efficient algorithm to determine the second best player using the information produced by the tournament. how many extra games does your algorithm require? . advanced fake coin problem there are n coins identical in appearance either all are genuine or exactly one of them is fake. it is unknown whether the fake coin is lighter or heavier than the genuine one. you have a balance scale with which you can compare any two sets of coins. that is by tipping to the left to the right or staying even the balance scale will tell whether the sets weigh the same or which of the sets is heavier than the other but not by how much. the problem is to find whether all the coins are genuine and if not to find the fake coin and establish whether it is lighter or heavier than the genuine ones. a. prove that any algorithm for this problem must make at least log n weighings in the worst case. b. draw a decision tree for an algorithm that solves the problem for n coins in two weighings. c. prove that there exists no algorithm that solves the problem for n coins in two weighings. d. draw a decision tree for an algorithm that solves the problem for n coins in two weighings by using an extra coin known to be genuine. e. draw a decision tree for an algorithm that solves the classic version of the problem that for n coins in three weighings with no extra coins being used . . jigsaw puzzle a jigsaw puzzle contains n pieces. a section of the puzzle is a set of one or more pieces that have been connected to each other. a move consists of connecting two sections. what algorithm will minimize the number of moves required to complete the puzzle? 