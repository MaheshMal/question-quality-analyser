a binary search tree is one of the most important data structures in computer science. one of its principal applications is to implement a dictionary a set of elements with the operations of searching insertion and deletion. if probabilities a b b a c c d d figure . two out of possible binary search trees with keys a b c and d. of searching for elements of a set are known e.g. from accumulated data about past searches it is natural to pose a question about an optimal binary search tree for which the average number of comparisons in a search is the smallest possible. for simplicity we limit our discussion to minimizing the average number of comparisons in a successful search. the method can be extended to include unsuccessful searches as well. as an example consider four keys a b c and d to be searched for with probabilities . . . and . respectively. figure . depicts two out of possible binary search trees containing these keys. the average number of comparisons in a successful search in the first of these trees is . . . . . . . . . and for the second one it is . . . . . . . . . . neither of these two trees is in fact optimal. can you tell which binary tree is optimal? for our tiny example we could find the optimal tree by generating all binary search trees with these keys. as a general algorithm this exhaustive search approach is unrealistic the total number of binary search trees with n keys is equal to the nth catalan number c n n for n c n n which grows to infinity as fast as n n . see problem in this section's exercises . so let a . . . an be distinct keys ordered from the smallest to the largest and let p . . . pn be the probabilities of searching for them. let c i j be the smallest average number of comparisons made in a successful search in a binary search tree tij made up of keys ai . . . aj where i j are some integer indices i j n. following the classic dynamic programming approach we will find values of c i j for all smaller instances of the problem although we are interested just in c n . to derive a recurrence underlying a dynamic programming algorithm we will consider all possible ways to choose a root ak among the keys ai . . . aj . for such a binary search tree figure . the root contains key ak the left subtree tik contains keys ai . . . ak optimally arranged and the right subtree tkj ak optimal optimal bst for bst for ai . . . ak ak . . . aj figure . binary search tree bst with root ak and two optimal binary search subtrees tik and tkj . contains keys ak . . . aj also optimally arranged. note how we are taking advantage of the principle of optimality here. if we count tree levels starting with to make the comparison numbers equal the keys' levels the following recurrence relation is obtained k c i j min pk . ps . level of as in tik ikj s i j ps . level of as in tkj s k k j j min ps . level of as in tik ps . level of as in tkj ps ikj s i s k s i j min c i k c k j ps . ikj s i thus we have the recurrence j c i j min c i k c k j ps for i j n. . ikj s i we assume in formula . that c i i for i n which can be interpreted as the number of comparisons in the empty tree. note that this formula implies that c i i pi for i n as it should be for a one node binary search tree containing ai. j n p goal p i c i j pn n figure . table of the dynamic programming algorithm for constructing an optimal binary search tree. the two dimensional table in figure . shows the values needed for computing c i j by formula . they are in row i and the columns to the left of column j and in column j and the rows below row i. the arrows point to the pairs of entries whose sums are computed in order to find the smallest one to be recorded as the value of c i j . this suggests filling the table along its diagonals starting with all zeros on the main diagonal and given probabilities pi i n right above it and moving toward the upper right corner. the algorithm we just sketched computes c n the average number of comparisons for successful searches in the optimal binary tree. if we also want to get the optimal tree itself we need to maintain another two dimensional table to record the value of k for which the minimum in . is achieved. the table has the same shape as the table in figure . and is filled in the same manner starting with entries r i i i for i n. when the table is filled its entries indicate indices of the roots of the optimal subtrees which makes it possible to reconstruct an optimal tree for the entire set given. example let us illustrate the algorithm by applying it to the four key set we used at the beginning of this section key a b c d probability . . . . the initial tables look like this main table root table . . . . let us compute c k c c ps . . . c min s k c c ps . . . s . . thus out of two possible binary trees containing the first two keys a and b the root of the optimal tree has index i.e. it contains b and the average number of comparisons in a successful search in this tree is . . we will ask you to finish the computations in the exercises. you should arrive at the following final tables main table root table . . . . . . . . . . thus the average number of key comparisons in the optimal tree is equal to . . since r the root of the optimal tree contains the third key i.e. c. its left subtree is made up of keys a and b and its right subtree contains just key d why? . to find the specific structure of these subtrees we find first their roots by consulting the root table again as follows. since r the root of the optimal tree containing a and b is b with a being its left child and the root of the onenode tree r . since r the root of this one node optimal tree is its only key d. figure . presents the optimal tree in its entirety. c b d a figure . optimal binary search tree for the example. here is pseudocode of the dynamic programming algorithm. algorithm optimalbst p ..n finds an optimal binary search tree by dynamic programming input an array p ..n of search probabilities for a sorted list of n keys output average number of comparisons in successful searches in the optimal bst and table r of subtrees' roots in the optimal bst for i to n do c i i c i i p i r i i i c n n for d to n do diagonal count for i to n d do j i d minval for k i to j do if c i k c k j minval minval c i k c k j kmin k r i j kmin sum p i for s i to j do sum sum p s c i j minval sum return c n r the algorithm's space efficiency is clearly quadratic the time efficiency of this version of the algorithm is cubic why? . a more careful analysis shows that entries in the root table are always nondecreasing along each row and column. this limits values for r i j to the range r i j . . . r i j and makes it possible to reduce the running time of the algorithm to n . exercises . . finish the computations started in the section's example of constructing an optimal binary search tree. . a. why is the time efficiency of algorithm optimalbst cubic? b. why is the space efficiency of algorithm optimalbst quadratic? . write pseudocode for a linear time algorithm that generates the optimal binary search tree from the root table. . devise a way to compute the sums j ps which are used in the dynamic s i programming algorithm for constructing an optimal binary search tree in constant time per sum . . true or false the root of an optimal binary search tree always contains the key with the highest search probability? . how would you construct an optimal binary search tree for a set of n keys if all the keys are equally likely to be searched for? what will be the average number of comparisons in a successful search in such a tree if n k? . a. show that the number of distinct binary search trees b n that can be constructed for a set of n orderable keys satisfies the recurrence relation n b n b k b n k for n b . k b. it is known that the solution to this recurrence is given by the catalan numbers. verify this assertion for n . . . . c. find the order of growth of b n . what implication does the answer to this question have for the exhaustive search algorithm for constructing an optimal binary search tree? . design a n algorithm for finding an optimal binary search tree. . generalize the optimal binary search algorithm by taking into account unsuccessful searches. . write pseudocode of a memory function for the optimal binary search tree problem. you may limit your function to finding the smallest number of key comparisons in a successful search. . matrix chain multiplication consider the problem of minimizing the total number of multiplications made in computing the product of n matrices a . a . . . . . an whose dimensions are d d d d . . . dn dn respectively. assume that all intermediate products of two matrices are computed by the bruteforce definition based algorithm. a. give an example of three matrices for which the number of multiplications in a . a . a and a . a . a differ at least by a factor of . b. how many different ways are there to compute the product of n matrices? c. design a dynamic programming algorithm for finding an optimal order of multiplying n matrices. 