in the beginning of this section we established that it is reasonable to measure an algorithm's efficiency as a function of a parameter indicating the size of the algorithm's input. but there are many algorithms for which running time depends not only on an input size but also on the specifics of a particular input. consider as an example sequential search. this is a straightforward algorithm that searches for a given item some search key k in a list of n elements by checking successive elements of the list until either a match with the search key is found or the list is exhausted. here is the algorithm's pseudocode in which for simplicity a list is implemented as an array. it also assumes that the second condition a i k will not be checked if the first one which checks that the array's index does not exceed its upper bound fails. algorithm sequentialsearch a ..n k searches for a given value in a given array by sequential search input an array a ..n and a search key k output the index of the first element in a that matches k or if there are no matching elements i while i n and a i k do i i if i n return i else return clearly the running time of this algorithm can be quite different for the same list size n. in the worst case when there are no matching elements or the first matching element happens to be the last one on the list the algorithm makes the largest number of key comparisons among all possible inputs of size n cworst n n. the worst case efficiency of an algorithm is its efficiency for the worst case input of size n which is an input or inputs of size n for which the algorithm runs the longest among all possible inputs of that size. the way to determine the worst case efficiency of an algorithm is in principle quite straightforward analyze the algorithm to see what kind of inputs yield the largest value of the basic operation's count c n among all possible inputs of size n and then compute this worst case value cworst n . for sequential search the answer was obvious. the methods for handling less trivial situations are explained in subsequent sections of this chapter. clearly the worst case analysis provides very important information about an algorithm's efficiency by bounding its running time from above. in other words it guarantees that for any instance of size n the running time will not exceed cworst n its running time on the worst case inputs. the best case efficiency of an algorithm is its efficiency for the best case input of size n which is an input or inputs of size n for which the algorithm runs the fastest among all possible inputs of that size. accordingly we can analyze the bestcase efficiency as follows. first we determine the kind of inputs for which the count c n will be the smallest among all possible inputs of size n. note that the best case does not mean the smallest input it means the input of size n for which the algorithm runs the fastest. then we ascertain the value of c n on these most convenient inputs. for example the best case inputs for sequential search are lists of size n with their first element equal to a search key accordingly cbest n for this algorithm. the analysis of the best case efficiency is not nearly as important as that of the worst case efficiency. but it is not completely useless either. though we should not expect to get best case inputs we might be able to take advantage of the fact that for some algorithms a good best case performance extends to some useful types of inputs close to being the best case ones. for example there is a sorting algorithm insertion sort for which the best case inputs are already sorted arrays on which the algorithm works very fast. moreover the best case efficiency deteriorates only slightly for almost sorted arrays. therefore such an algorithm might well be the method of choice for applications dealing with almost sorted arrays. and of course if the best case efficiency of an algorithm is unsatisfactory we can immediately discard it without further analysis. it should be clear from our discussion however that neither the worst case analysis nor its best case counterpart yields the necessary information about an algorithm's behavior on a typical or random input. this is the information that the average case efficiency seeks to provide. to analyze the algorithm's averagecase efficiency we must make some assumptions about possible inputs of size n. let's consider again sequential search. the standard assumptions are that a the probability of a successful search is equal to p p and b the probability of the first match occurring in the ith position of the list is the same for every i. under these assumptions the validity of which is usually difficult to verify their reasonableness notwithstanding we can find the average number of key comparisons cavg n as follows. in the case of a successful search the probability of the first match occurring in the ith position of the list is p n for every i and the number of comparisons made by the algorithm in such a situation is obviously i. in the case of an unsuccessful search the number of comparisons will be n with the probability of such a search being p . therefore cavg n . p . p . . . i . p . . . n . p n . p n n n n p . . . i . . . n n p n p n n n p p n n p . n this general formula yields some quite reasonable answers. for example if p the search must be successful the average number of key comparisons made by sequential search is n that is the algorithm will inspect on average about half of the list's elements. if p the search must be unsuccessful the average number of key comparisons will be n because the algorithm will inspect all n elements on all such inputs. as you can see from this very elementary example investigation of the average case efficiency is considerably more difficult than investigation of the worst case and best case efficiencies. the direct approach for doing this involves dividing all instances of size n into several classes so that for each instance of the class the number of times the algorithm's basic operation is executed is the same. what were these classes for sequential search? then a probability distribution of inputs is obtained or assumed so that the expected value of the basic operation's count can be found. the technical implementation of this plan is rarely easy however and probabilistic assumptions underlying it in each particular case are usually difficult to verify. given our quest for simplicity we will mostly quote known results about the average case efficiency of algorithms under discussion. if you are interested in derivations of these results consult such books as baa sed knui knuii and knuiii . it should be clear from the preceding discussion that the average case efficiency cannot be obtained by taking the average of the worst case and the best case efficiencies. even though this average does occasionally coincide with the average case cost it is not a legitimate way of performing the average case analysis. does one really need the average case efficiency information? the answer is unequivocally yes there are many important algorithms for which the averagecase efficiency is much better than the overly pessimistic worst case efficiency would lead us to believe. so without the average case analysis computer scientists could have missed many important algorithms. yet another type of efficiency is called amortized efficiency. it applies not to a single run of an algorithm but rather to a sequence of operations performed on the same data structure. it turns out that in some situations a single operation can be expensive but the total time for an entire sequence of n such operations is always significantly better than the worst case efficiency of that single operation multiplied by n. so we can amortize the high cost of such a worst case occurrence over the entire sequence in a manner similar to the way a business would amortize the cost of an expensive item over the years of the item's productive life. this sophisticated approach was discovered by the american computer scientist robert tarjan who used it among other applications in developing an interesting variation of the classic binary search tree see tar for a quite readable nontechnical discussion and tar for a technical account . we will see an example of the usefulness of amortized efficiency in section . when we consider algorithms for finding unions of disjoint sets. 