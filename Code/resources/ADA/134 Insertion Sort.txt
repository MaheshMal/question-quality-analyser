in this section we consider an application of the decrease by one technique to sorting an array a ..n . following the technique's idea we assume that the smaller problem of sorting the array a ..n has already been solved to give us a sorted array of size n a . . . a n . how can we take advantage of this solution to the smaller problem to get a solution to the original problem by taking into account the element a n ? obviously all we need is to find an appropriate position for a n among the sorted elements and insert it there. this is usually done by scanning the sorted subarray from right to left until the first element smaller than or equal to a n is encountered to insert a n right after that element. the resulting algorithm is called straight insertion sort or simply insertion sort. though insertion sort is clearly based on a recursive idea it is more efficient to implement this algorithm bottom up i.e. iteratively. as shown in figure . starting with a and ending with a n a i is inserted in its appropriate place among the first i elements of the array that have been already sorted but unlike selection sort are generally not in their final positions . here is pseudocode of this algorithm. algorithm insertionsort a ..n sorts a given array by insertion sort input an array a ..n of n orderable elements output array a ..n sorted in nondecreasing order for i to n do v a i j i while j and a j v do a j a j j j a j v a . . . a j a j . . . a i a i . . . a n smaller than or equal to a i greater than a i figure . iteration of insertion sort a i is inserted in its proper position among the preceding elements previously sorted. figure . example of sorting with insertion sort. a vertical bar separates the sorted part of the array from the remaining elements the element being inserted is in bold. the operation of the algorithm is illustrated in figure . . the basic operation of the algorithm is the key comparison a j v. why not j ? because it is almost certainly faster than the former in an actual computer implementation. moreover it is not germane to the algorithm a better implementation with a sentinel see problem in this section's exercises eliminates it altogether. the number of key comparisons in this algorithm obviously depends on the nature of the input. in the worst case a j v is executed the largest number of times i.e. for every j i . . . . since v a i it happens if and only if a j a i for j i . . . . note that we are using the fact that on the ith iteration of insertion sort all the elements preceding a i are the first i elements in the input albeit in the sorted order. thus for the worst case input we get a a for i a a for i . . . a n a n for i n . in other words the worst case input is an array of strictly decreasing values. the number of key comparisons for such an input is n i n n n cworst n i n . i j i thus in the worst case insertion sort makes exactly the same number of comparisons as selection sort see section . . in the best case the comparison a j v is executed only once on every iteration of the outer loop. it happens if and only if a i a i for every i . . . n i.e. if the input array is already sorted in nondecreasing order. though it makes sense that the best case of an algorithm happens when the problem is already solved it is not always the case as you are going to see in our discussion of quicksort in chapter . thus for sorted arrays the number of key comparisons is n cbest n n n . i this very good performance in the best case of sorted arrays is not very useful by itself because we cannot expect such convenient inputs. however almost sorted files do arise in a variety of applications and insertion sort preserves its excellent performance on such inputs. a rigorous analysis of the algorithm's average case efficiency is based on investigating the number of element pairs that are out of order see problem in this section's exercises . it shows that on randomly ordered arrays insertion sort makes on average half as many comparisons as on decreasing arrays i.e. cavg n n n . this twice as fast average case performance coupled with an excellent efficiency on almost sorted arrays makes insertion sort stand out among its principal competitors among elementary sorting algorithms selection sort and bubble sort. in addition its extension named shellsort after its inventor d. l. shell she gives us an even better algorithm for sorting moderately large files see problem in this section's exercises . exercises . . ferrying soldiers a detachment of n soldiers must cross a wide and deep river with no bridge in sight. they notice two year old boys playing in a rowboat by the shore. the boat is so tiny however that it can only hold two boys or one soldier. how can the soldiers get across the river and leave the boys in joint possession of the boat? how many times need the boat pass from shore to shore? . alternating glasses a. there are n glasses standing next to each other in a row the first n of them filled with a soda drink and the remaining n glasses empty. make the glasses alternate in a filled empty filled empty pattern in the minimum number of glass moves. gar b. solve the same problem if n glasses n with a drink and n empty are initially in a random order. . marking cells design an algorithm for the following task. for any even n mark n cells on an infinite sheet of graph paper so that each marked cell has an odd number of marked neighbors. two cells are considered neighbors if they are next to each other either horizontally or vertically but not diagonally. the marked cells must form a contiguous region i.e. a region in which there is a path between any pair of marked cells that goes through a sequence of marked neighbors. kor . design a decrease by one algorithm for generating the power set of a set of n elements. the power set of a set s is the set of all the subsets of s including the empty set and s itself. . consider the following algorithm to check connectivity of a graph defined by its adjacency matrix. algorithm connected a ..n ..n input adjacency matrix a ..n ..n of an undirected graph g output true if g is connected and false if it is not if n return one vertex graph is connected by definition else if not connected a ..n ..n return else for j to n do if a n j return return does this algorithm work correctly for every undirected graph with n vertices? if you answer yes indicate the algorithm's efficiency class in the worst case if you answer no explain why. . team ordering you have the results of a completed round robin tournament in which n teams played each other once. each game ended either with a victory for one of the teams or with a tie. design an algorithm that lists the teams in a sequence so that every team did not lose the game with the team listed immediately after it. what is the time efficiency class of your algorithm? . apply insertion sort to sort the list e x a m p l e in alphabetical order. . a. what sentinel should be put before the first element of an array being sorted in order to avoid checking the in bound condition j on each iteration of the inner loop of insertion sort? b. is the sentinel version in the same efficiency class as the original version? . is it possible to implement insertion sort for sorting linked lists? will it have the same o n time efficiency as the array version? . compare the text's implementation of insertion sort with the following version. algorithm insertsort a ..n for i to n do j i while j and a j a j do swap a j a j j j what is the time efficiency of this algorithm? how is it compared to that of the version given in section . ? . let a ..n be an array of n sortable elements. for simplicity you may assume that all the elements are distinct. a pair a i a j is called an inversion if i j and a i a j . a. what arrays of size n have the largest number of inversions and what is this number? answer the same questions for the smallest number of inversions. b. show that the average case number of key comparisons in insertion sort is given by the formula cavg n n . . shellsort more accurately shell's sort is an important sorting algorithm that works by applying insertion sort to each of several interleaving sublists of a given list. on each pass through the list the sublists in question are formed by stepping through the list with an increment hi taken from some predefined decreasing sequence of step sizes h . . . hi . . . which must end with . the algorithm works for any such sequence though some sequences are known to yield a better efficiency than others. for example the sequence . . . used of course in reverse is known to be among the best for this purpose. a. apply shellsort to the list s h e l l s o r t i s u s e f u l b. is shellsort a stable sorting algorithm? c. implement shellsort straight insertion sort selection sort and bubble sort in the language of your choice and compare their performance on random arrays of sizes n for n and as well as on increasing and decreasing arrays of these sizes. 