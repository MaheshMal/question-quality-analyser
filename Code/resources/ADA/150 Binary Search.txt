binary search is a remarkably efficient algorithm for searching in a sorted array. it works by comparing a search key k with the array's middle element a m . if they match the algorithm stops otherwise the same operation is repeated recursively for the first half of the array if k a m and for the second half if k a m k a . . . a m a m a m . . . a n . search here if search here if k a m k a m as an example let us apply binary search to searching for k in the array the iterations of the algorithm are given in the following table index value iteration l m r iteration l m r iteration l m r though binary search is clearly based on a recursive idea it can be easily implemented as a nonrecursive algorithm too. here is pseudocode of this nonrecursive version. algorithm binarysearch a ..n k implements nonrecursive binary search input an array a ..n sorted in ascending order and a search key k output an index of the array's element that is equal to k or if there is no such element l r n while l r do m l r if k a m return m else if k a m r m else l m return the standard way to analyze the efficiency of binary search is to count the number of times the search key is compared with an element of the array. moreover for the sake of simplicity we will count the so called three way comparisons. this assumes that after one comparison of k with a m the algorithm can determine whether k is smaller equal to or larger than a m . how many such comparisons does the algorithm make on an array of n elements? the answer obviously depends not only on n but also on the specifics of a particular instance of the problem. let us find the number of key comparisons in the worst case cworst n . the worst case inputs include all arrays that do not contain a given search key as well as some successful searches. since after one comparison the algorithm faces the same situation but for an array half the size we get the following recurrence relation for cworst n cworst n cworst n for n cworst . . stop and convince yourself that n must be indeed rounded down and that the initial condition must be written as specified. we already encountered recurrence . with a different initial condition in section . see recurrence . and its solution there for n k . for the initial condition cworst we obtain cworst k k log n . . further similarly to the case of recurrence . problem in exercises . the solution given by formula . for n k can be tweaked to get a solution valid for an arbitrary positive integer n cworst n log n log n . . formula . deserves attention. first it implies that the worst case time efficiency of binary search is in log n . second it is the answer we should have fully expected since the algorithm simply reduces the size of the remaining array by about half on each iteration the number of such iterations needed to reduce the initial size n to the final size has to be about log n. third to reiterate the point made in section . the logarithmic function grows so slowly that its values remain small even for very large values of n. in particular according to formula . it will take no more than log three way comparisons to find an element of a given value or establish that there is no such element in any sorted array of one thousand elements and it will take no more than log comparisons to do it for any sorted array of size one million! what can we say about the average case efficiency of binary search? a sophisticated analysis shows that the average number of key comparisons made by binary search is only slightly smaller than that in the worst case cavg n log n. more accurate formulas for the average number of comparisons in a successful and an unsuccessful search are cayvegs n log n and canvog n log n respectively. though binary search is an optimal searching algorithm if we restrict our operations only to comparisons between keys see section . there are searching algorithms see interpolation search in section . and hashing in section . with a better average case time efficiency and one of them hashing does not even require the array to be sorted! these algorithms do require some special calculations in addition to key comparisons however. finally the idea behind binary search has several applications beyond searching see e.g. ben . in addition it can be applied to solving nonlinear equations in one unknown we discuss this continuous analogue of binary search called the method of bisection in section . . 