in this section we consider the fibonacci numbers a famous sequence . . . . that can be defined by the simple recurrence f n f n f n for n . and two initial conditions f f . . the fibonacci numbers were introduced by leonardo fibonacci in as a solution to a problem about the size of a rabbit population problem in this section's exercises . many more examples of fibonacci like numbers have since been discovered in the natural world and they have even been used in predicting the prices of stocks and commodities. there are some interesting applications of the fibonacci numbers in computer science as well. for example worst case inputs for euclid's algorithm discussed in section . happen to be consecutive elements of the fibonacci sequence. in this section we briefly consider algorithms for computing the nth element of this sequence. among other benefits the discussion will provide us with an opportunity to introduce another method for solving recurrence relations useful for analysis of recursive algorithms. to start let us get an explicit formula for f n . if we try to apply the method of backward substitutions to solve recurrence . we will fail to get an easily discernible pattern. instead we can take advantage of a theorem that describes solutions to a homogeneous second order linear recurrence with constant coefficients ax n bx n cx n . where a b and c are some fixed real numbers a called the coefficients of the recurrence and x n is the generic term of an unknown sequence to be found. applying this theorem to our recurrence with the initial conditions given see appendix b we obtain the formula f n n n . where . and . . it is hard to believe that formula . which includes arbitrary integer powers of irrational numbers yields nothing else but all the elements of fibonacci sequence . but it does! one of the benefits of formula . is that it immediately implies that f n grows exponentially remember fibonacci's rabbits? i.e. f n n . this . constant is known as the golden ratio. since antiquity it has been considered the most pleasing ratio of a rectangle's two sides to the human eye and might have been consciously used by ancient architects and sculptors. follows from the observation that is a fraction between and and hence n gets infinitely small as n goes to infinity. in fact one can prove that the impact of the second term n on the value of f n can be obtained by rounding off the value of the first term to the nearest integer. in other words for every nonnegative integer n f n n rounded to the nearest integer. . in the algorithms that follow we consider for the sake of simplicity such operations as additions and multiplications at unit cost. since the fibonacci numbers grow infinitely large and grow very rapidly a more detailed analysis than the one offered here is warranted. in fact it is the size of the numbers rather than a time efficient method for computing them that should be of primary concern here. still these caveats notwithstanding the algorithms we outline and their analysis provide useful examples for a student of the design and analysis of algorithms. to begin with we can use recurrence . and initial conditions . for the obvious recursive algorithm for computing f n . algorithm f n computes the nth fibonacci number recursively by using its definition input a nonnegative integer n output the nth fibonacci number if n return n else return f n f n before embarking on its formal analysis can you tell whether this is an efficient algorithm? well we need to do a formal analysis anyway. the algorithm's basic operation is clearly addition so let a n be the number of additions performed by the algorithm in computing f n . then the numbers of additions needed for computing f n and f n are a n and a n respectively and the algorithm needs one more addition to compute their sum. thus we get the following recurrence for a n a n a n a n for n . a a . the recurrence a n a n a n is quite similar to recurrence f n f n f n but its right hand side is not equal to zero. such recurrences are called inhomogeneous. there are general techniques for solving inhomogeneous recurrences see appendix b or any textbook on discrete mathematics but for this particular recurrence a special trick leads to a faster solution. we can reduce our inhomogeneous recurrence to a homogeneous one by rewriting it as a n a n a n and substituting b n a n b n b n b n b b . this homogeneous recurrence can be solved exactly in the same manner as recurrence . was solved to find an explicit formula for f n . but it can actually be avoided by noting that b n is in fact the same recurrence as f n except that it starts with two 's and thus runs one step ahead of f n . so b n f n and a n b n f n n n . hence a n n and if we measure the size of n by the number of bits b log n in its binary representation the efficiency class will be even worse namely doubly exponential a b b . the poor efficiency class of the algorithm could be anticipated by the nature of recurrence . . indeed it contains two recursive calls with the sizes of smaller instances only slightly smaller than size n. have you encountered such a situation before? we can also see the reason behind the algorithm's inefficiency by looking at a recursive tree of calls tracing the algorithm's execution. an example of such a tree for n is given in figure . . note that the same values of the function are being evaluated here again and again which is clearly extremely inefficient. we can obtain a much faster algorithm by simply computing the successive elements of the fibonacci sequence iteratively as is done in the following algorithm. algorithm fib n computes the nth fibonacci number iteratively by using its definition input a nonnegative integer n output the nth fibonacci number f f for i to n do f i f i f i return f n f f f f f f f f f f f f f f f figure . tree of recursive calls for computing the th fibonacci number by the definition based algorithm. this algorithm clearly makes n additions. hence it is linear as a function of n and only exponential as a function of the number of bits b in n's binary representation. note that using an extra array for storing all the preceding elements of the fibonacci sequence can be avoided storing just two values is necessary to accomplish the task see problem in this section's exercises . the third alternative for computing the nth fibonacci number lies in using formula . . the efficiency of the algorithm will obviously be determined by the efficiency of an exponentiation algorithm used for computing n. if it is done by simply multiplying by itself n times the algorithm will be in n b . there are faster algorithms for the exponentiation problem. for example we will discuss log n b algorithms for this problem in chapters and . note also that special care should be exercised in implementing this approach to computing the nth fibonacci number. since all its intermediate results are irrational numbers we would have to make sure that their approximations in the computer are accurate enough so that the final round off yields a correct result. finally there exists a log n algorithm for computing the nth fibonacci number that manipulates only integers. it is based on the equality f n f n n f n f n for n and an efficient way of computing matrix powers. exercises . . find a web site dedicated to applications of the fibonacci numbers and study it. . fibonacci's rabbits problem a man put a pair of rabbits in a place surrounded by a wall. how many pairs of rabbits will be there in a year if the initial pair of rabbits male and female are newborn and all rabbit pairs are not fertile during their first month of life but thereafter give birth to one new male female pair at the end of every month? . climbing stairs find the number of different ways to climb an n stair staircase if each step is either one or two stairs. for example a stair staircase can be climbed three ways and . . how many even numbers are there among the first n fibonacci numbers i.e. among the numbers f f . . . f n ? give a closed form formula valid for every n . . check by direct substitutions that the function n n indeed satisfies recurrence . and initial conditions . . . the maximum values of the java primitive types int and long are and respectively. find the smallest n for which the nth fibonacci number is not going to fit in a memory allocated for a. the type int. b. the type long. . consider the recursive definition based algorithm for computing the nth fibonacci number f n . let c n and z n be the number of times f and f are computed respectively. prove that a. c n f n . b. z n f n . . improve algorithm f ib of the text so that it requires only space. . prove the equality f n f n n f n f n for n . . how many modulo divisions are made by euclid's algorithm on two consecutive fibonacci numbers f n and f n as the algorithm's input? . dissecting a fibonacci rectangle given a rectangle whose sides are two consecutive fibonacci numbers design an algorithm to dissect it into squares with no more than two squares being the same size. what is the time efficiency class of your algorithm? . in the language of your choice implement two algorithms for computing the last five digits of the nth fibonacci number that are based on a the recursive definition based algorithm f n b the iterative definition based algorithm fib n . perform an experiment to find the largest value of n for which your programs run under minute on your computer. 