a tree more accurately a free tree is a connected acyclic graph figure . a . a graph that has no cycles but is not necessarily connected is called a forest each of its connected components is a tree figure . b . . a subgraph of a given graph g v e is a graph g v e such that v v and e e. a b a b h c d c d e i f g f g j a b figure . a tree. b forest. i d a c a e b d e b c g f h g f h i a b figure . a free tree. b its transformation into a rooted tree. trees have several important properties other graphs do not have. in particular the number of edges in a tree is always one less than the number of its vertices e v . as the graph in figure . demonstrates this property is necessary but not sufficient for a graph to be a tree. however for connected graphs it is sufficient and hence provides a convenient way of checking whether a connected graph has a cycle. rooted trees another very important property of trees is the fact that for every two vertices in a tree there always exists exactly one simple path from one of these vertices to the other. this property makes it possible to select an arbitrary vertex in a free tree and consider it as the root of the so called rooted tree. a rooted tree is usually depicted by placing its root on the top level of the tree the vertices adjacent to the root below it level the vertices two edges apart from the root still below level and so on. figure . presents such a transformation from a free tree to a rooted tree. rooted trees play a very important role in computer science a much more important one than free trees do in fact for the sake of brevity they are often referred to as simply trees. an obvious application of trees is for describing hierarchies from file directories to organizational charts of enterprises. there are many less obvious applications such as implementing dictionaries see below efficient access to very large data sets section . and data encoding section . . as we discuss in chapter trees also are helpful in analysis of recursive algorithms. to finish this far from complete list of tree applications we should mention the so called state space trees that underline two important algorithm design techniques backtracking and branch and bound sections . and . . for any vertex v in a tree t all the vertices on the simple path from the root to that vertex are called ancestors of v. the vertex itself is usually considered its own ancestor the set of ancestors that excludes the vertex itself is referred to as the set of proper ancestors. if u v is the last edge of the simple path from the root to vertex v and u v u is said to be the parent of v and v is called a child of u vertices that have the same parent are said to be siblings. a vertex with no children is called a leaf a vertex with at least one child is called parental. all the vertices for which a vertex v is an ancestor are said to be descendants of v the proper descendants exclude the vertex v itself. all the descendants of a vertex v with all the edges connecting them form the subtree of t rooted at that vertex. thus for the tree in figure . b the root of the tree is a vertices d g f h and i are leaves and vertices a b e and c are parental the parent of b is a the children of b are c and g the siblings of b are d and e and the vertices of the subtree rooted at b are b c g h i . the depth of a vertex v is the length of the simple path from the root to v. the height of a tree is the length of the longest simple path from the root to a leaf. for example the depth of vertex c of the tree in figure . b is and the height of the tree is . thus if we count tree levels top down starting with for the root's level the depth of a vertex is simply its level in the tree and the tree's height is the maximum level of its vertices. you should be alert to the fact that some authors define the height of a tree as the number of levels in it this makes the height of a tree larger by than the height defined as the length of the longest simple path from the root to a leaf. ordered trees an ordered tree is a rooted tree in which all the children of each vertex are ordered. it is convenient to assume that in a tree's diagram all the children are ordered left to right. a binary tree can be defined as an ordered tree in which every vertex has no more than two children and each child is designated as either a left child or a right child of its parent a binary tree may also be empty. an example of a binary tree is given in figure . a. the binary tree with its root at the left right child of a vertex in a binary tree is called the left right subtree of that vertex. since left and right subtrees are binary trees as well a binary tree can also be defined recursively. this makes it possible to solve many problems involving binary trees by recursive algorithms. a b figure . a binary tree. b binary search tree. null null null null null null null null figure . standard implementation of the binary search tree in figure . b. in figure . b some numbers are assigned to vertices of the binary tree in figure . a. note that a number assigned to each parental vertex is larger than all the numbers in its left subtree and smaller than all the numbers in its right subtree. such trees are called binary search trees. binary trees and binary search trees have a wide variety of applications in computer science you will encounter some of them throughout the book. in particular binary search trees can be generalized to more general types of search trees called multiway search trees which are indispensable for efficient access to very large data sets. as you will see later in the book the efficiency of most important algorithms for binary search trees and their extensions depends on the tree's height. therefore the following inequalities for the height h of a binary tree with n nodes are especially important for analysis of such algorithms log n h n . a binary tree is usually implemented for computing purposes by a collection of nodes corresponding to vertices of the tree. each node contains some information associated with the vertex its name or some value assigned to it and two pointers to the nodes representing the left child and right child of the vertex respectively. figure . illustrates such an implementation for the binary search tree in figure . b. a computer representation of an arbitrary ordered tree can be done by simply providing a parental vertex with the number of pointers equal to the number of its children. this representation may prove to be inconvenient if the number of children varies widely among the nodes. we can avoid this inconvenience by using nodes with just two pointers as we did for binary trees. here however the left pointer will point to the first child of the vertex and the right pointer will point to its next sibling. accordingly this representation is called the first child next sibling representation. thus all the siblings of a vertex are linked via the nodes' right pointers in a singly linked list with the first element of the list pointed to by the left pointer of their parent. figure . a illustrates this representation for the tree in figure . b. it is not difficult to see that this representation effectively transforms an ordered tree into a binary tree said to be associated with the ordered tree. we get this representation by rotating the pointers about degrees clockwise see figure . b . 