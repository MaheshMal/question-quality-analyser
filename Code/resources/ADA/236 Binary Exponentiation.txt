the amazing efficiency of horner's rule fades if the method is applied to computing an which is the value of xn at x a. in fact it degenerates to the brute force multiplication of a by itself with wasteful additions of zeros in between. since computing an actually an mod m is an essential operation in several important primality testing and encryption methods we consider now two algorithms for computing an that are based on the representation change idea. they both exploit the binary representation of exponent n but one of them processes this binary string left to right whereas the second does it right to left. let n bi . . . bi . . . b be the bit string representing a positive integer n in the binary number system. this means that the value of n can be computed as the value of the polynomial p x bi xi . . . bixi . . . b . at x . for example if n its binary representation is and . . . . . let us now compute the value of this polynomial by applying horner's rule and see what the method's operations imply for computing the power an ap abi i ... bi i ... b . horner's rule for the binary polynomial p implications for an ap p the leading digit is always for n ap a for i i downto do for i i downto do p p bi ap a p bi but a p bi a p . abi ap . abi ap if bi ap . a if bi . thus after initializing the accumulator's value to a we can scan the bit string representing the exponent n to always square the last value of the accumulator and if the current binary digit is also to multiply it by a. these observations lead to the following left to right binary exponentiation method of computing an. algorithm leftrightbinaryexponentiation a b n computes an by the left to right binary exponentiation algorithm input a number a and a list b n of binary digits bi . . . b in the binary expansion of a positive integer n output the value of an product a for i i downto do product product product if bi product product a return product example compute a by the left to right binary exponentiation algorithm. here n . so we have binary digits of n product accumulator a a . a a a a a . a a since the algorithm makes one or two multiplications on each repetition of its only loop the total number of multiplications m n made by it in computing an is b m n b where b is the length of the bit string representing the exponent n. taking into account that b log n we can conclude that the efficiency of the leftto right binary exponentiation is logarithmic. thus this algorithm is in a better efficiency class than the brute force exponentiation which always requires n multiplications. the right to left binary exponentiation uses the same binary polynomial p see . yielding the value of n. but rather than applying horner's rule to it as the previous method did this one exploits it differently an abi i ... bi i ... b abi i . . . . . abi i . . . . . ab . thus an can be computed as the product of the terms abi i a i if bi if bi i.e. the product of consecutive terms a i skipping those for which the binary digit bi is zero. in addition we can compute a i by simply squaring the same term we computed for the previous value of i since a i a i . so we compute all such powers of a from the smallest to the largest from right to left but we include in the product accumulator only those whose corresponding binary digit is . here is pseudocode of this algorithm. algorithm rightleftbinaryexponentiation a b n computes an by the right to left binary exponentiation algorithm input a number a and a list b n of binary digits bi . . . b in the binary expansion of a nonnegative integer n output the value of an term a initializes a i if b product a else product for i to i do term term term if bi product product term return product example compute a by the right to left binary exponentiation method. here n . so we have the following table filled in from right to left binary digits of n a a a a terms a i a . a a a . a a a product accumulator obviously the algorithm's efficiency is also logarithmic for the same reason the left to right binary multiplication is. the usefulness of both binary exponentiation algorithms is reduced somewhat by their reliance on availability of the explicit binary expansion of exponent n. problem in this section's exercises asks you to design an algorithm that does not have this shortcoming. exercises . . consider the following brute force algorithm for evaluating a polynomial. algorithm bruteforcepolynomialevaluation p ..n x computes the value of polynomial p at a given point x by the highest to lowest term brute force algorithm input an array p ..n of the coefficients of a polynomial of degree n stored from the lowest to the highest and a number x output the value of the polynomial at the point x p . for i n downto do power for j to i do power power x p p p i power return p find the total number of multiplications and the total number of additions made by this algorithm. . write pseudocode for the brute force polynomial evaluation that stems from substituting a given value of the variable into the polynomial's formula and evaluating it from the lowest term to the highest one. determine the number of multiplications and the number of additions made by this algorithm. . a. estimate how much faster horner's rule is compared to the lowest tohighest term brute force algorithm of problem if i the time of one multiplication is significantly larger than the time of one addition ii the time of one multiplication is about the same as the time of one addition. b. is horner's rule more time efficient at the expense of being less space efficient than the brute force algorithm? . a. apply horner's rule to evaluate the polynomial p x x x x at x . b. use the results of the above application of horner's rule to find the quotient and remainder of the division of p x by x . . apply horner's rule to convert from binary to decimal. . compare the number of multiplications and additions subtractions needed by the long division of a polynomial p x anxn an xn . . . a by x c where c is some constant with the number of these operations in the synthetic division. . a. apply the left to right binary exponentiation algorithm to compute a . b. is it possible to extend the left to right binary exponentiation algorithm to work for every nonnegative integer exponent? . apply the right to left binary exponentiation algorithm to compute a . . design a nonrecursive algorithm for computing an that mimics the right to left binary exponentiation but does not explicitly use the binary representation of n. . is it a good idea to use a general purpose polynomial evaluation algorithm such as horner's rule to evaluate the polynomial p x xn xn . . . x ? . according to the corollary of the fundamental theorem of algebra every polynomial p x anxn an xn . . . a can be represented in the form p x an x x x x . . . x xn where x x . . . xn are the roots of the polynomial generally complex and not necessarily distinct . discuss which of the two representations is more convenient for each of the following operations a. polynomial evaluation at a given point b. addition of two polynomials c. multiplication of two polynomials . polynomial interpolation given a set of n data points xi yi where no two xi are the same find a polynomial p x of degree at most n such that p xi yi for every i . . . n. 