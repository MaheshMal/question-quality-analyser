as we discussed at the beginning of this chapter and illustrated in subsequent sections dynamic programming deals with problems whose solutions satisfy a recurrence relation with overlapping subproblems. the direct top down approach to finding a solution to such a recurrence leads to an algorithm that solves common subproblems more than once and hence is very inefficient typically exponential or worse . the classic dynamic programming approach on the other hand works bottom up it fills a table with solutions to all smaller subproblems but each of them is solved only once. an unsatisfying aspect of this approach is that solutions to some of these smaller subproblems are often not necessary for getting a solution to the problem given. since this drawback is not present in the top down approach it is natural to try to combine the strengths of the top down and bottom up approaches. the goal is to get a method that solves only subproblems that are necessary and does so only once. such a method exists it is based on using memory functions. this method solves a given problem in the top down manner but in addition maintains a table of the kind that would have been used by a bottom up dynamic programming algorithm. initially all the table's entries are initialized with a special null symbol to indicate that they have not yet been calculated. thereafter whenever a new value needs to be calculated the method checks the corresponding entry in the table first if this entry is not null it is simply retrieved from the table otherwise it is computed by the recursive call whose result is then recorded in the table. the following algorithm implements this idea for the knapsack problem. after initializing the table the recursive function needs to be called with i n the number of items and j w the knapsack capacity . algorithm mfknapsack i j implements the memory function method for the knapsack problem input a nonnegative integer i indicating the number of the first items being considered and a nonnegative integer j indicating the knapsack capacity output the value of an optimal feasible subset of the first i items note uses as global variables input arrays w eights ..n v alues ..n and table f ..n ..w whose entries are initialized with 's except for row and column initialized with 's if f i j if j weights i value mfknapsack i j else value max mfknapsack i j values i mfknapsack i j weights i f i j value return f i j example let us apply the memory function method to the instance considered in example . the table in figure . gives the results. only out of nontrivial values i.e. not those in row or in column have been computed. capacity j i w v w v w v w v figure . example of solving an instance of the knapsack problem by the memory function algorithm. just one nontrivial entry v is retrieved rather than being recomputed. for larger instances the proportion of such entries can be significantly larger. in general we cannot expect more than a constant factor gain in using the memory function method for the knapsack problem because its time efficiency class is the same as that of the bottom up algorithm why? . a more significant improvement can be expected for dynamic programming algorithms in which a computation of one value takes more than constant time. you should also keep in mind that a memory function algorithm may be less space efficient than a spaceefficient version of a bottom up algorithm. exercises . . a. apply the bottom up dynamic programming algorithm to the following instance of the knapsack problem item weight value capacity w . b. how many different optimal subsets does the instance of part a have? c. in general how can we use the table generated by the dynamic programming algorithm to tell whether there is more than one optimal subset for the knapsack problem's instance? . a. write pseudocode of the bottom up dynamic programming algorithm for the knapsack problem. b. write pseudocode of the algorithm that finds the composition of an optimal subset from the table generated by the bottom up dynamic programming algorithm for the knapsack problem. . for the bottom up dynamic programming algorithm for the knapsack problem prove that a. its time efficiency is nw . b. its space efficiency is nw . c. the time needed to find the composition of an optimal subset from a filled dynamic programming table is o n . . a. true or false a sequence of values in a row of the dynamic programming table for the knapsack problem is always nondecreasing? b. true or false a sequence of values in a column of the dynamic programming table for the knapsack problem is always nondecreasing? . design a dynamic programming algorithm for the version of the knapsack problem in which there are unlimited quantities of copies for each of the n item kinds given. indicate the time efficiency of the algorithm. . apply the memory function method to the instance of the knapsack problem given in problem . indicate the entries of the dynamic programming table that are i never computed by the memory function method ii retrieved without a recomputation. . prove that the efficiency class of the memory function algorithm for the knapsack problem is the same as that of the bottom up algorithm see problem . . explain why the memory function approach is unattractive for the problem of computing a binomial coefficient by the formula c n k c n k c n k . . write a research report on one of the following well known applications of dynamic programming a. finding the longest common subsequence in two sequences b. optimal string editing c. minimal triangulation of a polygon 