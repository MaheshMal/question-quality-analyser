as the next example of a variable size decrease algorithm we consider an algorithm for searching in a sorted array called interpolation search. unlike binary search which always compares a search key with the middle value of a given sorted array and hence reduces the problem's instance size by half interpolation search takes into account the value of the search key in order to find the array's element to be compared with the search key. in a sense the algorithm mimics the way we value a r v a l l x r index figure . index computation in interpolation search. search for a name in a telephone book if we are searching for someone named brown we open the book not in the middle but very close to the beginning unlike our action when searching for someone named say smith. more precisely on the iteration dealing with the array's portion between the leftmost element a l and the rightmost element a r the algorithm assumes that the array values increase linearly i.e. along the straight line through the points l a l and r a r . the accuracy of this assumption can influence the algorithm's efficiency but not its correctness. accordingly the search key's value v is compared with the element whose index is computed as the round off of the x coordinate of the point on the straight line through the points l a l and r a r whose y coordinate is equal to the search value v figure . . writing down a standard equation for the straight line passing through the points l a l and r a r substituting v for y and solving it for x leads to the following formula x l v a l r l . . a r a l the logic behind this approach is quite straightforward. we know that the array values are increasing more accurately not decreasing from a l to a r but we do not know how they do it. had these values increased linearly which is the simplest manner possible the index computed by formula . would be the expected location of the array's element with the value equal to v. of course if v is not between a l and a r formula . need not be applied why? . after comparing v with a x the algorithm either stops if they are equal or proceeds by searching in the same manner among the elements indexed either between l and x or between x and r depending on whether a x is smaller or larger than v. thus the size of the problem's instance is reduced but we cannot tell a priori by how much. the analysis of the algorithm's efficiency shows that interpolation search uses fewer than log log n key comparisons on the average when searching in a list of n random keys. this function grows so slowly that the number of comparisons is a very small constant for all practically feasible inputs see problem in this section's exercises . but in the worst case interpolation search is only linear which must be considered a bad performance why? . assessing the worthiness of interpolation search versus that of binary search robert sedgewick wrote in the second edition of his algorithms that binary search is probably better for smaller files but interpolation search is worth considering for large files and for applications where comparisons are particularly expensive or access costs are very high. note that in section . we discuss a continuous counterpart of interpolation search which can be seen as one more example of a variable size decrease algorithm. 