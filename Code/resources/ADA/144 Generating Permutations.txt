we start with permutations. for simplicity we assume that the underlying set whose elements need to be permuted is simply the set of integers from to n more generally they can be interpreted as indices of elements in an n element set a . . . an . what would the decrease by one technique suggest for the problem of generating all n! permutations of . . . n ? the smaller by one problem is to generate all n ! permutations. assuming that the smaller problem is solved we can get a solution to the larger one by inserting n in each of the n possible positions among elements of every permutation of n elements. all the permutations obtained in this fashion will be distinct why? and their total number will be n n ! n!. hence we will obtain all the permutations of . . . n . we can insert n in the previously generated permutations either left to right or right to left. it turns out that it is beneficial to start with inserting n into . . . n by moving right to left and then switch direction every time a new permutation of . . . n needs to be processed. an example of applying this approach bottom up for n is given in figure . . the advantage of this order of generating permutations stems from the fact that it satisfies the minimal change requirement each permutation can be obtained from its immediate predecessor by exchanging just two elements in it. for the method being discussed these two elements are always adjacent to each other. start insert into right to left insert into right to left insert into left to right figure . generating permutations bottom up. check this for the permutations generated in figure . . the minimal change requirement is beneficial both for the algorithm's speed and for applications using the permutations. for example in section . we needed permutations of cities to solve the traveling salesman problem by exhaustive search. if such permutations are generated by a minimal change algorithm we can compute the length of a new tour from the length of its predecessor in constant rather than linear time how? . it is possible to get the same ordering of permutations of n elements without explicitly generating permutations for smaller values of n. it can be done by associating a direction with each element k in a permutation. we indicate such a direction by a small arrow written above the element in question e.g. . the element k is said to be mobile in such an arrow marked permutation if its arrow points to a smaller number adjacent to it. for example for the permutation and are mobile while and are not. using the notion of a mobile element we can give the following description of the johnson trotter algorithm for generating permutations. algorithm johnsontrotter n implements johnson trotter algorithm for generating permutations input a positive integer n output a list of all permutations of . . . n initialize the first permutation with . . . n while the last permutation has a mobile element do find its largest mobile element k swap k with the adjacent element k's arrow points to reverse the direction of all the elements that are larger than k add the new permutation to the list here is an application of this algorithm for n with the largest mobile element shown in bold . this algorithm is one of the most efficient for generating permutations it can be implemented to run in time proportional to the number of permutations i.e. in n! . of course it is horribly slow for all but very small values of n however this is not the algorithm's fault but rather the fault of the problem it simply asks to generate too many items. one can argue that the permutation ordering generated by the johnsontrotter algorithm is not quite natural for example the natural place for permutation n n . . . seems to be the last one on the list. this would be the case if permutations were listed in increasing order also called the lexicographic order which is the order in which they would be listed in a dictionary if the numbers were interpreted as letters of an alphabet. for example for n . so how can we generate the permutation following a a . . . an an in lexicographic order? if an an which is the case for exactly one half of all the permutations we can simply transpose these last two elements. for example is followed by . if an an we find the permutation's longest decreasing suffix ai ai . . . an but ai ai increase ai by exchanging it with the smallest element of the suffix that is greater than ai and reverse the new suffix to put it in increasing order. for example is followed by . here is pseudocode of this simple algorithm whose origins go as far back as th century india. algorithm lexicographicpermute n generates permutations in lexicographic order input a positive integer n output a list of all permutations of . . . n in lexicographic order initialize the first permutation with . . . n while last permutation has two consecutive elements in increasing order do let i be its largest index such that ai ai ai ai . . . an find the largest index j such that ai aj j i since ai ai swap ai with aj ai ai . . . an will remain in decreasing order reverse the order of the elements from ai to an inclusive add the new permutation to the list 