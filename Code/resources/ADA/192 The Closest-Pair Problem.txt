let p be a set of n points in the cartesian plane. for the sake of simplicity we assume that the points are distinct. we can also assume that the points are ordered in nondecreasing order of their x coordinate. if they were not we could sort them first by an efficeint sorting algorithm such as mergesort. it will also be convenient to have the points sorted in a separate list in nondecreasing order of the y coordinate we will denote such a list q. if n the problem can be solved by the obvious brute force algorithm. if n we can divide the points into two subsets pl and pr of n and n points respectively by drawing a vertical line through the median m of their x coordinates so that n points lie to the left of or on the line itself and n points lie to the right of or on the line. then we can solve the closest pair problem x m dl dr x m d d d min p d d a b figure . a idea of the divide and conquer algorithm for the closest pair problem. b rectangle that may contain points closer than dmin to point p. recursively for subsets pl and pr. let dl and dr be the smallest distances between pairs of points in pl and pr respectively and let d min dl dr . note that d is not necessarily the smallest distance between all the point pairs because points of a closer pair can lie on the opposite sides of the separating line. therefore as a step combining the solutions to the smaller subproblems we need to examine such points. obviously we can limit our attention to the points inside the symmetric vertical strip of width d around the separating line since the distance between any other pair of points is at least d figure . a . let s be the list of points inside the strip of width d around the separating line obtained from q and hence ordered in nondecreasing order of their y coordinate. we will scan this list updating the information about dmin the minimum distance seen so far if we encounter a closer pair of points. initially dmin d and subsequently dmin d. let p x y be a point on this list. for a point p x y to have a chance to be closer to p than dmin the point must follow p on list s and the difference between their y coordinates must be less than dmin why? . geometrically this means that p must belong to the rectangle shown in figure . b. the principal insight exploited by the algorithm is the observation that the rectangle can contain just a few such points because the points in each half left and right of the rectangle must be at least distance d apart. it is easy to prove that the total number of such points in the rectangle including p does not exceed eight problem in this section's exercises a more careful analysis reduces this number to six see joh p. . thus the algorithm can consider no more than five next points following p on the list s before moving up to the next point. here is pseudocode of the algorithm. we follow the advice given in section . to avoid computing square roots inside the innermost loop of the algorithm. algorithm efficientclosestpair p q solves the closest pair problem by divide and conquer input an array p of n points in the cartesian plane sorted in nondecreasing order of their x coordinates and an array q of the same points sorted in nondecreasing order of the y coordinates output euclidean distance between the closest pair of points if n return the minimal distance found by the brute force algorithm else copy the first n points of p to array pl copy the same n points from q to array ql copy the remaining n points of p to array pr copy the same n points from q to array qr dl efficientclosestpair pl ql dr efficientclosestpair pr qr d min dl dr m p n .x copy all the points of q for which x m d into array s ..num dminsq d for i to num do ki while k num and s k .y s i .y dminsq dminsq min s k .x s i .x s k .y s i .y dminsq kk return sqrt dminsq the algorithm spends linear time both for dividing the problem into two problems half the size and combining the obtained solutions. therefore assuming as usual that n is a power of we have the following recurrence for the running time of the algorithm t n t n f n where f n n . applying the master theorem with a b and d we get t n n log n . the necessity to presort input points does not change the overall efficiency class if sorting is done by a o n log n algorithm such as mergesort. in fact this is the best efficiency class one can achieve because it has been proved that any algorithm for this problem must be in n log n under some natural assumptions about operations an algorithm can perform see pre p. . 