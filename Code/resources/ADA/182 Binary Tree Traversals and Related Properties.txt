in this section we see how the divide and conquer technique can be applied to binary trees. a binary tree t is defined as a finite set of nodes that is either empty or consists of a root and two disjoint binary trees tl and tr called respectively the left and right subtree of the root. we usually think of a binary tree as a special case of an ordered tree figure . . this standard interpretation was an alternative definition of a binary tree in section . . since the definition itself divides a binary tree into two smaller structures of the same type the left subtree and the right subtree many problems about binary trees can be solved by applying the divide and conquer technique. as an example let us consider a recursive algorithm for computing the height of a binary tree. recall that the height is defined as the length of the longest path from the root to a leaf. hence it can be computed as the maximum of the heights of the root's left tleft tright figure . standard representation of a binary tree. and right subtrees plus . we have to add to account for the extra level of the root. also note that it is convenient to define the height of the empty tree as . thus we have the following recursive algorithm. algorithm height t computes recursively the height of a binary tree input a binary tree t output the height of t if t return else return max height tlef t height tright we measure the problem's instance size by the number of nodes n t in a given binary tree t . obviously the number of comparisons made to compute the maximum of two numbers and the number of additions a n t made by the algorithm are the same. we have the following recurrence relation for a n t a n t a n tlef t a n tright for n t a . before we solve this recurrence can you tell what its solution is? let us note that addition is not the most frequently executed operation of this algorithm. what is? checking and this is very typical for binary tree algorithms that the tree is not empty. for example for the empty tree the comparison t is executed once but there are no additions and for a single node tree the comparison and addition numbers are and respectively. it helps in the analysis of tree algorithms to draw the tree's extension by replacing the empty subtrees by special nodes. the extra nodes shown by little squares in figure . are called external the original nodes shown by little circles are called internal. by definition the extension of the empty binary tree is a single external node. it is easy to see that the height algorithm makes exactly one addition for every internal node of the extended tree and it makes one comparison to check whether a b figure . binary tree on the left and its extension on the right . internal nodes are shown as circles external nodes are shown as squares. the tree is empty for every internal and external node. therefore to ascertain the algorithm's efficiency we need to know how many external nodes an extended binary tree with n internal nodes can have. after checking figure . and a few similar examples it is easy to hypothesize that the number of external nodes x is always more than the number of internal nodes n x n . . to prove this equality consider the total number of nodes both internal and external. since every node except the root is one of the two children of an internal node we have the equation n x n which immediately implies equality . . note that equality . also applies to any nonempty full binary tree in which by definition every node has either zero or two children for a full binary tree n and x denote the numbers of parental nodes and leaves respectively. returning to algorithm height the number of comparisons to check whether the tree is empty is c n n x n and the number of additions is a n n. the most important divide and conquer algorithms for binary trees are the three classic traversals preorder inorder and postorder. all three traversals visit nodes of a binary tree recursively i.e. by visiting the tree's root and its left and right subtrees. they differ only by the timing of the root's visit in the preorder traversal the root is visited before the left and right subtrees are visited in that order . in the inorder traversal the root is visited after visiting its left subtree but before visiting the right subtree. in the postorder traversal the root is visited after visiting the left and right subtrees in that order . these traversals are illustrated in figure . . their pseudocodes are quite straightforward repeating the descriptions given above. these traversals are also a standard feature of data structures textbooks. as to their efficiency analysis it is identical to the above analysis of the height algorithm because a recursive call is made for each node of an extended binary tree. finally we should note that obviously not all questions about binary trees require traversals of both left and right subtrees. for example the search and insert operations for a binary search tree require processing only one of the two subtrees. accordingly we considered them in section . not as applications of divide andconquer but rather as examples of the variable size decrease technique. a b c preorder a b d g e c f inorder d g b e a f c d e f postorder g d e b f c a g figure . binary tree and its traversals. exercises . . design a divide and conquer algorithm for computing the number of levels in a binary tree. in particular the algorithm must return and for the empty and single node trees respectively. what is the time efficiency class of your algorithm? . the following algorithm seeks to compute the number of leaves in a binary tree. algorithm leafcounter t computes recursively the number of leaves in a binary tree input a binary tree t output the number of leaves in t if t return else return leafcounter tlef t leafcounter tright is this algorithm correct? if it is prove it if it is not make an appropriate correction. . can you compute the height of a binary tree with the same asymptotic efficiency as the section's divide and conquer algorithm but without using a stack explicitly or implicitly? of course you may use a different algorithm altogether. . prove equality . by mathematical induction. . traverse the following binary tree a. in preorder. b. in inorder. c. in postorder. a b c d e f . write pseudocode for one of the classic traversal algorithms preorder inorder and postorder for binary trees. assuming that your algorithm is recursive find the number of recursive calls made. . which of the three classic traversal algorithms yields a sorted list if applied to a binary search tree? prove this property. . a. draw a binary tree with nodes labeled . . . in such a way that the inorder and postorder traversals of the tree yield the following lists inorder and postorder . b. give an example of two permutations of the same n labels . . . n that cannot be inorder and postorder traversal lists of the same binary tree. c. design an algorithm that constructs a binary tree for which two given lists of n labels . . . n are generated by the inorder and postorder traversals of the tree. your algorithm should also identify inputs for which the problem has no solution. . the internal path length i of an extended binary tree is defined as the sum of the lengths of the paths taken over all internal nodes from the root to each internal node. similarly the external path length e of an extended binary tree is defined as the sum of the lengths of the paths taken over all external nodes from the root to each external node. prove that e i n where n is the number of internal nodes in the tree. . write a program for computing the internal path length of an extended binary tree. use it to investigate empirically the average number of key comparisons for searching in a randomly generated binary search tree. . chocolate bar puzzle given an n m chocolate bar you need to break it into nm pieces. you can break a bar only in a straight line and only one bar can be broken at a time. design an algorithm that solves the problem with the minimum number of bar breaks. what is this minimum number? justify your answer by using properties of a binary tree. 