recall the string matching problem introduced in section . given a string of n characters called the text and a string of m characters m n called the pattern find a substring of the text that matches the pattern. to put it more precisely we want to find i the index of the leftmost character of the first matching substring in the text such that ti p . . . ti j pj . . . ti m pm t ... ti ... ti j ... ti m ... tn text t p ... pj ... pm pattern p if matches other than the first one need to be found a string matching algorithm can simply continue working until the entire text is exhausted. a brute force algorithm for the string matching problem is quite obvious align the pattern against the first m characters of the text and start matching the corresponding pairs of characters from left to right until either all the m pairs of the characters match then the algorithm can stop or a mismatching pair is encountered. in the latter case shift the pattern one position to the right and resume the character comparisons starting again with the first character of the pattern and its counterpart in the text. note that the last position in the text that can still be a beginning of a matching substring is n m provided the text positions are indexed from to n . beyond that position there are not enough characters to match the entire pattern hence the algorithm need not make any comparisons there. algorithm bruteforcestringmatch t ..n p ..m implements brute force string matching input an array t ..n of n characters representing a text and an array p ..m of m characters representing a pattern output the index of the first character in the text that starts a matching substring or if the search is unsuccessful for i to n m do j while j m and p j t i j do j j if j m return i return an operation of the algorithm is illustrated in figure . . note that for this example the algorithm shifts the pattern almost always after a single character comparison. the worst case is much worse the algorithm may have to make all m comparisons before shifting the pattern and this can happen for each of the n m tries. problem in this section's exercises asks you to give a specific example of such a situation. thus in the worst case the algorithm makes n o b o d y n o t i c e d h i m n o t n o t n o t n o t n o t n o t n o t n o t figure . example of brute force string matching. the pattern's characters that are compared with their text counterparts are in bold type. m n m character comparisons which puts it in the o nm class. for a typical word search in a natural language text however we should expect that most shifts would happen after very few comparisons check the example again . therefore the average case efficiency should be considerably better than the worst case efficiency. indeed it is for searching in random texts it has been shown to be linear i.e. n . there are several more sophisticated and more efficient algorithms for string searching. the most widely known of them by r. boyer and j. moore is outlined in section . along with its simplification suggested by r. horspool. exercises . . find the number of comparisons made by the sentinel version of sequential search a. in the worst case. b. in the average case if the probability of a successful search is p p . . as shown in section . the average number of key comparisons made by sequential search without a sentinel under standard assumptions about its inputs is given by the formula cavg n p n n p where p is the probability of a successful search. determine for a fixed n the values of p p for which this formula yields the maximum value of cavg n and the minimum value of cavg n . . gadget testing a firm wants to determine the highest floor of its n story headquarters from which a gadget can fall without breaking. the firm has two identical gadgets to experiment with. if one of them gets broken it cannot be repaired and the experiment will have to be completed with the remaining gadget. design an algorithm in the best efficiency class you can to solve this problem. . determine the number of character comparisons made by the brute force algorithm in searching for the pattern gandhi in the text there is more to life than increasing its speed assume that the length of the text it is characters long is known before the search starts. . how many comparisons both successful and unsuccessful will be made by the brute force algorithm in searching for each of the following patterns in the binary text of one thousand zeros? a. b. c. . give an example of a text of length n and a pattern of length m that constitutes a worst case input for the brute force string matching algorithm. exactly how many character comparisons will be made for such input? . in solving the string matching problem would there be any advantage in comparing pattern and text characters right to left instead of left to right? . consider the problem of counting in a given text the number of substrings that start with an a and end with a b. for example there are four such substrings in cabaaxbya. a. design a brute force algorithm for this problem and determine its efficiency class. b. design a more efficient algorithm for this problem. gin . write a visualization program for the brute force string matching algorithm. . word find a popular diversion in the united states word find or word search puzzles ask the player to find each of a given set of words in a square table filled with single letters. a word can read horizontally left or right vertically up or down or along a degree diagonal in any of the four directions formed by consecutively adjacent cells of the table it may wrap around the table's boundaries but it must read in the same direction with no zigzagging. the same cell of the table may be used in different words but in a given word the same cell may be used no more than once. write a computer program for solving this puzzle. . battleship game write a program based on a version of brute force pattern matching for playing the game battleship on the computer. the rules of the game are as follows. there are two opponents in the game in this case a human player and the computer . the game is played on two identical boards tables of squares on which each opponent places his or her ships not seen by the opponent. each player has five ships each of which occupies a certain number of squares on the board a destroyer two squares a submarine three squares a cruiser three squares a battleship four squares and an aircraft carrier five squares . each ship is placed either horizontally or vertically with no two ships touching each other. the game is played by the opponents taking turns shooting at each other's ships. the result of every shot is displayed as either a hit or a miss. in case of a hit the player gets to go again and keeps playing until missing. the goal is to sink all the opponent's ships before the opponent succeeds in doing it first. to sink a ship all squares occupied by the ship must be hit. 