most problems discussed in this book can be solved in polynomial time by some algorithm. they include computing the product and the greatest common divisor of two integers sorting a list searching for a key in a list or for a pattern in a text string checking connectivity and acyclicity of a graph and finding a minimum spanning tree and shortest paths in a weighted graph. you are invited to add more examples to this list. informally we can think about problems that can be solved in polynomial time as the set that computer science theoreticians call p . a more formal definition includes in p only decision problems which are problems with yes no answers. definition class p is a class of decision problems that can be solved in polynomial time by deterministic algorithms. this class of problems is called polynomial. the restriction of p to decision problems can be justified by the following reasons. first it is sensible to exclude problems not solvable in polynomial time because of their exponentially large output. such problems do arise naturally e.g. generating subsets of a given set or all the permutations of n distinct items but it is apparent from the outset that they cannot be solved in polynomial time. second many important problems that are not decision problems in their most natural formulation can be reduced to a series of decision problems that are easier to study. for example instead of asking about the minimum number of colors needed to color the vertices of a graph so that no two adjacent vertices are colored the same color we can ask whether there exists such a coloring of the graph's vertices with no more than m colors for m . . . . the latter is called the mcoloring problem. the first value of m in this series for which the decision problem of m coloring has a solution solves the optimization version of the graph coloring problem as well. it is natural to wonder whether every decision problem can be solved in polynomial time. the answer to this question turns out to be no. in fact some decision problems cannot be solved at all by any algorithm. such problems are called undecidable as opposed to decidable problems that can be solved by an algorithm. a famous example of an undecidable problem was given by alan turing in . the problem in question is called the halting problem given a computer program and an input to it determine whether the program will halt on that input or continue working indefinitely on it. here is a surprisingly short proof of this remarkable fact. by way of contradiction assume that a is an algorithm that solves the halting problem. that is for any program p and input i a p i if program p halts on input i if program p does not halt on input i . we can consider program p as an input to itself and use the output of algorithm a for pair p p to construct a program q as follows q p halts if a p p i.e. if program p does not halt on input p does not halt if a p p i.e. if program p halts on input p . then on substituting q for p we obtain q q halts if a q q i.e. if program q does not halt on input q does not halt if a q q i.e. if program q halts on input q. this is a contradiction because neither of the two outcomes for program q is possible which completes the proof. are there decidable but intractable problems? yes there are but the number of known examples is surprisingly small especially of those that arise naturally rather than being constructed for the sake of a theoretical argument. there are many important problems however for which no polynomial time algorithm has been found nor has the impossibility of such an algorithm been proved. the classic monograph by m. garey and d. johnson gar contains a list of several hundred such problems from different areas of computer science mathematics and operations research. here is just a small sample of some of the best known problems that fall into this category hamiltonian circuit problem determine whether a given graph has a hamiltonian circuit a path that starts and ends at the same vertex and passes through all the other vertices exactly once. traveling salesman problem find the shortest tour through n cities with known positive integer distances between them find the shortest hamiltonian circuit in a complete graph with positive integer weights . . this was just one of many breakthrough contributions to theoretical computer science made by the english mathematician and computer science pioneer alan turing . in recognition of this the acm the principal society of computing professionals and researchers has named after him an award given for outstanding contributions to theoretical computer science. a lecture given on such an occasion by richard karp kar provides an interesting historical account of the development of complexity theory. knapsack problem find the most valuable subset of n items of given positive integer weights and values that fit into a knapsack of a given positive integer capacity. partition problem given n positive integers determine whether it is possible to partition them into two disjoint subsets with the same sum. bin packing problem given n items whose sizes are positive rational numbers not larger than put them into the smallest number of bins of size . graph coloring problem for a given graph find its chromatic number which is the smallest number of colors that need to be assigned to the graph's vertices so that no two adjacent vertices are assigned the same color. integer linear programming problem find the maximum or minimum value of a linear function of several integer valued variables subject to a finite set of constraints in the form of linear equalities and inequalities. some of these problems are decision problems. those that are not have decision version counterparts e.g. the m coloring problem for the graph coloring problem . what all these problems have in common is an exponential or worse growth of choices as a function of input size from which a solution needs to be found. note however that some problems that also fall under this umbrella can be solved in polynomial time. for example the eulerian circuit problem the problem of the existence of a cycle that traverses all the edges of a given graph exactly once can be solved in o n time by checking in addition to the graph's connectivity whether all the graph's vertices have even degrees. this example is particularly striking it is quite counterintuitive to expect that the problem about cycles traversing all the edges exactly once eulerian circuits can be so much easier than the seemingly similar problem about cycles visiting all the vertices exactly once hamiltonian circuits . another common feature of a vast majority of decision problems is the fact that although solving such problems can be computationally difficult checking whether a proposed solution actually solves the problem is computationally easy i.e. it can be done in polynomial time. we can think of such a proposed solution as being randomly generated by somebody leaving us with the task of verifying its validity. for example it is easy to check whether a proposed list of vertices is a hamiltonian circuit for a given graph with n vertices. all we need to check is that the list contains n vertices of the graph in question that the first n vertices are distinct whereas the last one is the same as the first and that every consecutive pair of the list's vertices is connected by an edge. this general observation about decision problems has led computer scientists to the notion of a nondeterministic algorithm. definition a nondeterministic algorithm is a two stage procedure that takes as its input an instance i of a decision problem and does the following. nondeterministic guessing stage an arbitrary string s is generated that can be thought of as a candidate solution to the given instance i but may be complete gibberish as well . deterministic verification stage a deterministic algorithm takes both i and s as its input and outputs yes if s represents a solution to instance i. if s is not a solution to instance i the algorithm either returns no or is allowed not to halt at all. we say that a nondeterministic algorithm solves a decision problem if and only if for every yes instance of the problem it returns yes on some execution. in other words we require a nondeterministic algorithm to be capable of guessing a solution at least once and to be able to verify its validity. and of course we do not want it to ever output a yes answer on an instance for which the answer should be no. finally a nondeterministic algorithm is said to be nondeterministic polynomial if the time efficiency of its verification stage is polynomial. now we can define the class of np problems. definition class np is the class of decision problems that can be solved by nondeterministic polynomial algorithms. this class of problems is called nondeterministic polynomial. most decision problems are in np. first of all this class includes all the problems in p p np. this is true because if a problem is in p we can use the deterministic polynomialtime algorithm that solves it in the verification stage of a nondeterministic algorithm that simply ignores string s generated in its nondeterministic guessing stage. but np also contains the hamiltonian circuit problem the partition problem decision versions of the traveling salesman the knapsack graph coloring and many hundreds of other difficult combinatorial optimization problems cataloged in gar . the halting problem on the other hand is among the rare examples of decision problems that are known not to be in np. this leads to the most important open question of theoretical computer science is p a proper subset of np or are these two classes in fact the same? we can put this symbolically as p ? np. note that p np would imply that each of many hundreds of difficult combinatorial decision problems can be solved by a polynomial time algorithm although computer scientists have failed to find such algorithms despite their persistent efforts over many years. moreover many well known decision problems are known to be np complete see below which seems to cast more doubts on the possibility that p np. 