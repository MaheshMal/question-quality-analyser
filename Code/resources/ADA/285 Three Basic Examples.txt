the goal of this section is to introduce dynamic programming via three typical examples. example coin row problem there is a row of n coins whose values are some positive integers c c . . . cn not necessarily distinct. the goal is to pick up the maximum amount of money subject to the constraint that no two coins adjacent in the initial row can be picked up. let f n be the maximum amount that can be picked up from the row of n coins. to derive a recurrence for f n we partition all the allowed coin selections into two groups those that include the last coin and those without it. the largest amount we can get from the first group is equal to cn f n the value of the nth coin plus the maximum amount we can pick up from the first n coins. the maximum amount we can get from the second group is equal to f n by the definition of f n . thus we have the following recurrence subject to the obvious initial conditions f n max cn f n f n for n . f f c . we can compute f n by filling the one row table left to right in the manner similar to the way it was done for the nth fibonacci number by algorithm fib n in section . . algorithm coinrow c ..n applies formula . bottom up to find the maximum amount of money that can be picked up from a coin row without picking two adjacent coins input array c ..n of positive integers indicating the coin values output the maximum amount of money that can be picked up f f c for i to n do f i max c i f i f i return f n the application of the algorithm to the coin row of denominations is shown in figure . . it yields the maximum amount of . it is worth pointing index c f f c f index c f max f index c f max f index c f max f index c f max f index c f max f figure . solving the coin row problem by dynamic programming for the coin row . out that in fact we also solved the problem for the first i coins in the row given for every i . for example for i the maximum amount is f . to find the coins with the maximum total value found we need to backtrace the computations to see which of the two possibilities cn f n or f n produced the maxima in formula . . in the last application of the formula it was the sum c f which means that the coin c is a part of an optimal solution. moving to computing f the maximum was produced by the sum c f which means that the coin c is a part of an optimal solution as well. finally the maximum in computing f was produced by f implying that the coin c is not the part of an optimal solution and the coin c is. thus the optimal solution is c c c . to avoid repeating the same computations during the backtracing the information about which of the two terms in . was larger can be recorded in an extra array when the values of f are computed. using the coinrow to find f n the largest amount of money that can be picked up as well as the coins composing an optimal set clearly takes n time and n space. this is by far superior to the alternatives the straightforward topdown application of recurrence . and solving the problem by exhaustive search problem in this section's exercises . example change making problem consider the general instance of the following well known problem. give change for amount n using the minimum number of coins of denominations d d . . . dm. for the coin denominations used in the united states as for those used in most if not all other countries there is a very simple and efficient algorithm discussed in the next chapter. here we consider a dynamic programming algorithm for the general case assuming availability of unlimited quantities of coins for each of the m denominations d d . . . dm where d . let f n be the minimum number of coins whose values add up to n it is convenient to define f . the amount n can only be obtained by adding one coin of denomination dj to the amount n dj for j . . . m such that n dj . therefore we can consider all such denominations and select the one minimizing f n dj . since is a constant we can of course find the smallest f n dj first and then add to it. hence we have the following recurrence for f n f n min f n dj for n j ndj . f . we can compute f n by filling a one row table left to right in the manner similar to the way it was done above for the coin row problem but computing a table entry here requires finding the minimum of up to m numbers. algorithm changemaking d ..m n applies dynamic programming to find the minimum number of coins of denominations d d . . . dm where d that add up to a given amount n input positive integer n and array d ..m of increasing positive integers indicating the coin denominations where d output the minimum number of coins that add up to n f for i to n do temp j while j m and i d j do temp min f i d j temp j j f i temp return f n the application of the algorithm to amount n and denominations is shown in figure . . the answer it yields is two coins. the time and space efficiencies of the algorithm are obviously o nm and n respectively. n f f n f min f f n f min f f n f min f f f n f min f f f f n f min f f f f n f min f f f f figure . application of algorithm mincoinchange to amount n and coin denominations and . to find the coins of an optimal solution we need to backtrace the computations to see which of the denominations produced the minima in formula . . for the instance considered the last application of the formula for n the minimum was produced by d . the second minimum for n was also produced for a coin of that denomination. thus the minimum coin set for n is two 's. example coin collecting problem several coins are placed in cells of an n m board no more than one coin per cell. a robot located in the upper left cell of the board needs to collect as many of the coins as possible and bring them to the bottom right cell. on each step the robot can move either one cell to the right or one cell down from its current location. when the robot visits a cell with a coin it always picks up that coin. design an algorithm to find the maximum number of coins the robot can collect and a path it needs to follow to do this. let f i j be the largest number of coins the robot can collect and bring to the cell i j in the ith row and j th column of the board. it can reach this cell either from the adjacent cell i j above it or from the adjacent cell i j to the left of it. the largest numbers of coins that can be brought to these cells are f i j and f i j respectively. of course there are no adjacent cells above the cells in the first row and there are no adjacent cells to the left of the cells in the first column. for those cells we assume that f i j and f i j are equal to for their nonexistent neighbors. therefore the largest number of coins the robot can bring to cell i j is the maximum of these two numbers plus one possible coin at cell i j itself. in other words we have the following formula for f i j f i j max f i j f i j cij for i n j m . f j for j m and f i for i n where cij if there is a coin in cell i j and cij otherwise. using these formulas we can fill in the n m table of f i j values either row by row or column by column as is typical for dynamic programming algorithms involving two dimensional tables. algorithm robotcoincollection c ..n ..m applies dynamic programming to compute the largest number of coins a robot can collect on an n m board by starting at and moving right and down from upper left to down right corner input matrix c ..n ..m whose elements are equal to and for cells with and without a coin respectively output largest number of coins the robot can bring to cell n m f c for j to m do f j f j c j for i to n do f i f i c i for j to m do f i j max f i j f i j c i j return f n m the algorithm is illustrated in figure . b for the coin setup in figure . a. since computing the value of f i j by formula . for each cell of the table takes constant time the time efficiency of the algorithm is nm . its space efficiency is obviously also nm . tracing the computations backward makes it possible to get an optimal path if f i j f i j an optimal path to cell i j must come down from the adjacent cell above it if f i j f i j an optimal path to cell i j must come from the adjacent cell on the left and if f i j f i j it can reach cell i j from either direction. this yields two optimal paths for the instance in figure . a which are shown in figure . c. if ties are ignored one optimal path can be obtained in n m time. a b c figure . a coins to collect. b dynamic programming algorithm results. c two paths to collect coins the maximum number of coins possible. exercises . . what does dynamic programming have in common with divide and conquer? what is a principal difference between them? . solve the instance of the coin row problem. . a. show that the time efficiency of solving the coin row problem by straightforward application of recurrence . is exponential. b. show that the time efficiency of solving the coin row problem by exhaustive search is at least exponential. . apply the dynamic programming algorithm to find all the solutions to the change making problem for the denominations and the amount n . . how would you modify the dynamic programming algorithm for the coincollecting problem if some cells on the board are inaccessible for the robot? apply your algorithm to the board below where the inaccessible cells are shown by x's. how many optimal paths are there for this board? . rod cutting problem design a dynamic programming algorithm for the following problem. find the maximum total sale price that can be obtained by cutting a rod of n units long into integer length pieces if the sale price of a piece i units long is pi for i . . . n. what are the time and space efficiencies of your algorithm? . shortest path counting a chess rook can move horizontally or vertically to any square in the same row or in the same column of a chessboard. find the number of shortest paths by which a rook can move from one corner of a chessboard to the diagonally opposite corner. the length of a path is measured by the number of squares it passes through including the first and the last squares. solve the problem a. by a dynamic programming algorithm. b. by using elementary combinatorics. . minimum sum descent some positive integers are arranged in an equilateral triangle with n numbers in its base like the one shown in the figure below for n . the problem is to find the smallest sum in a descent from the triangle apex to its base through a sequence of adjacent numbers shown in the figure by the circles . design a dynamic programming algorithm for this problem and indicate its time efficiency. . binomial coefficient design an efficient algorithm for computing the binomial coefficient c n k that uses no multiplications. what are the time and space efficiencies of your algorithm? . longest path in a dag a. design an efficient algorithm for finding the length of the longest path in a dag. this problem is important both as a prototype of many other dynamic programming applications and in its own right because it determines the minimal time needed for completing a project comprising precedenceconstrained tasks. b. show how to reduce the coin row problem discussed in this section to the problem of finding a longest path in a dag. . maximum square submatrix given an m n boolean matrix b find its largest square submatrix whose elements are all zeros. design a dynamic programming algorithm and indicate its time efficiency. the algorithm may be useful for say finding the largest free square area on a computer screen or for selecting a construction site. . world series odds consider two teams a and b playing a series of games until one of the teams wins n games. assume that the probability of a winning a game is the same for each game and equal to p and the probability of a losing a game is q p. hence there are no ties. let p i j be the probability of a winning the series if a needs i more games to win the series and b needs j more games to win the series. a. set up a recurrence relation for p i j that can be used by a dynamic programming algorithm. b. find the probability of team a winning a seven game series if the probability of it winning a game is . . c. write pseudocode of the dynamic programming algorithm for solving this problem and determine its time and space efficiencies. 