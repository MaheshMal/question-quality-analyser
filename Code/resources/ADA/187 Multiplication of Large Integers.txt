some applications notably modern cryptography require manipulation of integers that are over decimal digits long. since such integers are too long to fit in a single word of a modern computer they require special treatment. this practical need supports investigations of algorithms for efficient manipulation of large integers. in this section we outline an interesting algorithm for multiplying such numbers. obviously if we use the conventional pen and pencil algorithm for multiplying two n digit integers each of the n digits of the first number is multiplied by each of the n digits of the second number for the total of n digit multiplications. if one of the numbers has fewer digits than the other we can pad the shorter number with leading zeros to equalize their lengths. though it might appear that it would be impossible to design an algorithm with fewer than n digit multiplications this turns out not to be the case. the miracle of divide and conquer comes to the rescue to accomplish this feat. to demonstrate the basic idea of the algorithm let us start with a case of two digit integers say and . these numbers can be represented as follows . . and . . . now let us multiply them . . . . . the last formula yields the correct answer of of course but it uses the same four digit multiplications as the pen and pencil algorithm. fortunately we can compute the middle term with just one digit multiplication by taking advantage of the products and that need to be computed anyway . of course there is nothing special about the numbers we just multiplied. for any pair of two digit numbers a a a and b b b their product c can be computed by the formula c a b c c c where c a b is the product of their first digits c a b is the product of their second digits c a a b b c c is the product of the sum of the a's digits and the sum of the b's digits minus the sum of c and c . now we apply this trick to multiplying two n digit integers a and b where n is a positive even number. let us divide both numbers in the middle after all we promised to take advantage of the divide and conquer technique. we denote the first half of the a's digits by a and the second half by a for b the notations are b and b respectively. in these notations a a a implies that a a n a and b b b implies that b b n b . therefore taking advantage of the same trick we used for two digit numbers we get c a b a n a b n b a b n a b a b n a b c n c n c where c a b is the product of their first halves c a b is the product of their second halves c a a b b c c is the product of the sum of the a's halves and the sum of the b's halves minus the sum of c and c . if n is even we can apply the same method for computing the products c c and c . thus if n is a power of we have a recursive algorithm for computing the product of two n digit integers. in its pure form the recursion is stopped when n becomes . it can also be stopped when we deem n small enough to multiply the numbers of that size directly. how many digit multiplications does this algorithm make? since multiplication of n digit numbers requires three multiplications of n digit numbers the recurrence for the number of multiplications m n is m n m n for n m . solving it by backward substitutions for n k yields m k m k m k m k . . . im k i . . . km k k k. since k log n m n log n nlog n . . on the last step we took advantage of the following property of logarithms alogb c clogb a. but what about additions and subtractions? have we not decreased the number of multiplications by requiring more of those operations? let a n be the number of digit additions and subtractions executed by the above algorithm in multiplying two n digit decimal integers. besides a n of these operations needed to compute the three products of n digit numbers the above formulas require five additions and one subtraction. hence we have the recurrence a n a n cn for n a . applying the master theorem which was stated in the beginning of the chapter we obtain a n nlog which means that the total number of additions and subtractions have the same asymptotic order of growth as the number of multiplications. the asymptotic advantage of this algorithm notwithstanding how practical is it? the answer depends of course on the computer system and program quality implementing the algorithm which might explain the rather wide disparity of reported results. on some machines the divide and conquer algorithm has been reported to outperform the conventional method on numbers only decimal digits long and to run more than twice faster with numbers over decimal digits long the area of particular importance for modern cryptography. whatever this outperformance crossover point happens to be on a particular machine it is worth switching to the conventional algorithm after the multiplicands become smaller than the crossover point. finally if you program in an object oriented language such as java c or smalltalk you should also be aware that these languages have special classes for dealing with large integers. discovered by year old russian mathematician anatoly karatsuba in the divide and conquer algorithm proved wrong the then prevailing opinion that the time efficiency of any integer multiplication algorithm must be in n . the discovery encouraged researchers to look for even asymptotically faster algorithms for this and other algebraic problems. we will see such an algorithm in the next section. 