let us now discuss how we can apply the branch and bound technique to solving the knapsack problem. this problem was introduced in section . given n items of known weights wi and values vi i . . . n and a knapsack of capacity w find the most valuable subset of the items that fit in the knapsack. it is convenient to order the items of a given instance in descending order by their value to weight ratios. then the first item gives the best payoff per weight unit and the last one gives the worst payoff per weight unit with ties resolved arbitrarily v w v w . . . vn wn. it is natural to structure the state space tree for this problem as a binary tree constructed as follows see figure . for an example . each node on the ith level of this tree i n represents all the subsets of n items that include a particular selection made from the first i ordered items. this particular selection is uniquely determined by the path from the root to the node a branch going to the left indicates the inclusion of the next item and a branch going to the right indicates its exclusion. we record the total weight w and the total value v of this selection in the node along with some upper bound ub on the value of any subset that can be obtained by adding zero or more items to this selection. a simple way to compute the upper bound ub is to add to v the total value of the items already selected the product of the remaining capacity of the knapsack w w and the best per unit payoff among the remaining items which is vi wi ub v w w vi wi . . as a specific example let us apply the branch and bound algorithm to the same instance of the knapsack problem we solved in section . by exhaustive search. we reorder the items in descending order of their value to weight ratios though. item weight value value weight the knapsack's capacity w is . w v ub with w o w v w v ub ub with w o x inferior to node w w v ub x with w o not feasible w v w v ub ub x with w o inferior to node w w v value x not feasible optimal solution figure . state space tree of the best first branch and bound algorithm for the instance of the knapsack problem. at the root of the state space tree see figure . no items have been selected as yet. hence both the total weight of the items already selected w and their total value v are equal to . the value of the upper bound computed by formula . is . node the left child of the root represents the subsets that include item . the total weight and value of the items already included are and respectively the value of the upper bound is . node represents the subsets that do not include item . accordingly w v and ub . since node has a larger upper bound than the upper bound of node it is more promising for this maximization problem and we branch from node first. its children nodes and represent subsets with item and with and without item respectively. since the total weight w of every subset represented by node exceeds the knapsack's capacity node can be terminated immediately. node has the same values of w and v as its parent the upper bound ub is equal to . selecting node over node for the next branching why? we get nodes and by respectively including and excluding item . the total weights and values as well as the upper bounds for these nodes are computed in the same way as for the preceding nodes. branching from node yields node which represents no feasible solutions and node which represents just a single subset of value . the remaining live nodes and have smaller upper bound values than the value of the solution represented by node . hence both can be terminated making the subset of node the optimal solution to the problem. solving the knapsack problem by a branch and bound algorithm has a rather unusual characteristic. typically internal nodes of a state space tree do not define a point of the problem's search space because some of the solution's components remain undefined. see for example the branch and bound tree for the assignment problem discussed in the preceding subsection. for the knapsack problem however every node of the tree represents a subset of the items given. we can use this fact to update the information about the best subset seen so far after generating each new node in the tree. if we had done this for the instance investigated above we could have terminated nodes and before node was generated because they both are inferior to the subset of value of node . 