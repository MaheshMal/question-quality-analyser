in this section we systematically apply the general framework outlined in section . to analyzing the time efficiency of nonrecursive algorithms. let us start with a very simple example that demonstrates all the principal steps typically taken in analyzing such algorithms. example consider the problem of finding the value of the largest element in a list of n numbers. for simplicity we assume that the list is implemented as an array. the following is pseudocode of a standard algorithm for solving the problem. algorithm maxelement a ..n determines the value of the largest element in a given array input an array a ..n of real numbers output the value of the largest element in a maxval a for i to n do if a i maxval maxval a i return maxval the obvious measure of an input's size here is the number of elements in the array i.e. n. the operations that are going to be executed most often are in the algorithm's for loop. there are two operations in the loop's body the comparison a i maxval and the assignment maxval a i . which of these two operations should we consider basic? since the comparison is executed on each repetition of the loop and the assignment is not we should consider the comparison to be the algorithm's basic operation. note that the number of comparisons will be the same for all arrays of size n therefore in terms of this metric there is no need to distinguish among the worst average and best cases here. let us denote c n the number of times this comparison is executed and try to find a formula expressing it as a function of size n. the algorithm makes one comparison on each execution of the loop which is repeated for each value of the loop's variable i within the bounds and n inclusive. therefore we get the following sum for c n n c n . i this is an easy sum to compute because it is nothing other than repeated n times. thus n c n n n . i here is a general plan to follow in analyzing nonrecursive algorithms. general plan for analyzing the time efficiency of nonrecursive algorithms . decide on a parameter or parameters indicating an input's size. . identify the algorithm's basic operation. as a rule it is located in the innermost loop. . check whether the number of times the basic operation is executed depends only on the size of an input. if it also depends on some additional property the worst case average case and if necessary best case efficiencies have to be investigated separately. . set up a sum expressing the number of times the algorithm's basic operation is executed. . using standard formulas and rules of sum manipulation either find a closedform formula for the count or at the very least establish its order of growth. before proceeding with further examples you may want to review appendix a which contains a list of summation formulas and rules that are often useful in analysis of algorithms. in particular we use especially frequently two basic rules of sum manipulation u u cai c ai r i l i l u u u ai bi ai bi r i l i l i l . sometimes an analysis of a nonrecursive algorithm requires setting up not a sum but a recurrence relation for the number of times its basic operation is executed. using recurrence relations is much more typical for analyzing recursive algorithms see section . . and two summation formulas u u l where l u are some lower and upper integer limits s i l n n i . . . n n n n i n . s i i note that the formula n n which we used in example is a special i case of formula s for l and u n . example consider the element uniqueness problem check whether all the elements in a given array of n elements are distinct. this problem can be solved by the following straightforward algorithm. algorithm uniqueelements a ..n determines whether all the elements in a given array are distinct input an array a ..n output returns true if all the elements in a are distinct and false otherwise for i to n do for j i to n do if a i a j return false return true the natural measure of the input's size here is again n the number of elements in the array. since the innermost loop contains a single operation the comparison of two elements we should consider it as the algorithm's basic operation. note however that the number of element comparisons depends not only on n but also on whether there are equal elements in the array and if there are which array positions they occupy. we will limit our investigation to the worst case only. by definition the worst case input is an array for which the number of element comparisons cworst n is the largest among all arrays of size n. an inspection of the innermost loop reveals that there are two kinds of worst case inputs inputs for which the algorithm does not exit the loop prematurely arrays with no equal elements and arrays in which the last two elements are the only pair of equal elements. for such inputs one comparison is made for each repetition of the innermost loop i.e. for each value of the loop variable j between its limits i and n this is repeated for each value of the outer loop i.e. for each value of the loop variable i between its limits and n . accordingly we get n n n n cworst n n i n i i j i i i n n n n n n i n i i i n n n n n n n . we also could have computed the sum ni n i faster as follows n n n n i n n . . . i where the last equality is obtained by applying summation formula s . note that this result was perfectly predictable in the worst case the algorithm needs to compare all n n distinct pairs of its n elements. example given two n n matrices a and b find the time efficiency of the definition based algorithm for computing their product c ab. by definition c is an n n matrix whose elements are computed as the scalar dot products of the rows of matrix a and the columns of matrix b a b c row i c i j col. j where c i j a i b j . . . a i k b k j . . . a i n b n j for every pair of indices i j n . algorithm matrixmultiplication a ..n ..n b ..n ..n multiplies two square matrices of order n by the definition based algorithm input two n n matrices a and b output matrix c ab for i to n do for j to n do c i j . for k to n do c i j c i j a i k b k j return c we measure an input's size by matrix order n. there are two arithmetical operations in the innermost loop here multiplication and addition that in principle can compete for designation as the algorithm's basic operation. actually we do not have to choose between them because on each repetition of the innermost loop each of the two is executed exactly once. so by counting one we automatically count the other. still following a well established tradition we consider multiplication as the basic operation see section . . let us set up a sum for the total number of multiplications m n executed by the algorithm. since this count depends only on the size of the input matrices we do not have to investigate the worst case average case and best case efficiencies separately. obviously there is just one multiplication executed on each repetition of the algorithm's innermost loop which is governed by the variable k ranging from the lower bound to the upper bound n . therefore the number of multiplications made for every pair of specific values of variables i and j is n k and the total number of multiplications m n is expressed by the following triple sum n n n m n . i j k now we can compute this sum by using formula s and rule r given above. starting with the innermost sum n which is equal to n why? we get k n n n n n n m n n n n . i j k i j i this example is simple enough so that we could get this result without all the summation machinations. how? the algorithm computes n elements of the product matrix. each of the product's elements is computed as the scalar dot product of an n element row of the first matrix and an n element column of the second matrix which takes n multiplications. so the total number of multiplications is n . n n . it is this kind of reasoning that we expected you to employ when answering this question in problem of exercises . . if we now want to estimate the running time of the algorithm on a particular machine we can do it by the product t n cmm n cmn where cm is the time of one multiplication on the machine in question. we would get a more accurate estimate if we took into account the time spent on the additions too t n cmm n caa n cmn can cm ca n where ca is the time of one addition. note that the estimates differ only by their multiplicative constants and not by their order of growth. you should not have the erroneous impression that the plan outlined above always succeeds in analyzing a nonrecursive algorithm. an irregular change in a loop variable a sum too complicated to analyze and the difficulties intrinsic to the average case analysis are just some of the obstacles that can prove to be insurmountable. these caveats notwithstanding the plan does work for many simple nonrecursive algorithms as you will see throughout the subsequent chapters of the book. as a last example let us consider an algorithm in which the loop's variable changes in a different manner from that of the previous examples. example the following algorithm finds the number of binary digits in the binary representation of a positive decimal integer. algorithm binary n input a positive decimal integer n output the number of binary digits in n's binary representation count while n do count count n n return count first notice that the most frequently executed operation here is not inside the while loop but rather the comparison n that determines whether the loop's body will be executed. since the number of times the comparison will be executed is larger than the number of repetitions of the loop's body by exactly the choice is not that important. a more significant feature of this example is the fact that the loop variable takes on only a few values between its lower and upper limits therefore we have to use an alternative way of computing the number of times the loop is executed. since the value of n is about halved on each repetition of the loop the answer should be about log n. the exact formula for the number of times the comparison n will be executed is actually log n the number of bits in the binary representation of n according to formula . . we could also get this answer by applying the analysis technique based on recurrence relations we discuss this technique in the next section because it is more pertinent to the analysis of recursive algorithms. exercises . . compute the following sums. a. . . . b. . . . c. n d. n i e. n i i i i i f. n j g. n n ij h. n i i j i j i . find the order of growth of the following sums. use the g n notation with the simplest function g n possible. a. ni i b. n lg i i ij i j n c. in i i d. i . the sample variance of n measurements x . . . xn can be computed as either in xi x n xi where x i n n or n xi n xi n i i . n find and compare the number of divisions multiplications and additions subtractions additions and subtractions are usually bunched together that are required for computing the variance according to each of these formulas. . consider the following algorithm. algorithm mystery n input a nonnegative integer n s for i to n do ss ii return s a. what does this algorithm compute? b. what is its basic operation? c. how many times is the basic operation executed? d. what is the efficiency class of this algorithm? e. suggest an improvement or a better algorithm altogether and indicate its efficiency class. if you cannot do it try to prove that in fact it cannot be done. . consider the following algorithm. algorithm secret a ..n input an array a ..n of n real numbers minval a maxval a for i to n do if a i minval minval a i if a i maxval maxval a i return maxval minval answer questions a e of problem about this algorithm. . consider the following algorithm. algorithm enigma a ..n ..n input a matrix a ..n ..n of real numbers for i to n do for j i to n do if a i j a j i return false return true answer questions a e of problem about this algorithm. . improve the implementation of the matrix multiplication algorithm see example by reducing the number of additions made by the algorithm. what effect will this change have on the algorithm's efficiency? . determine the asymptotic order of growth for the total number of times all the doors are toggled in the locker doors puzzle problem in exercises . . . prove the formula n i . . . n n n i either by mathematical induction or by following the insight of a year old school boy named carl friedrich gauss who grew up to become one of the greatest mathematicians of all times. . mental arithmetic a table is filled with repeating numbers on its diagonals as shown below. calculate the total sum of the table's numbers in your head after cra question . . ... ... ... ... . consider the following version of an important algorithm that we will study later in the book. algorithm ge a ..n ..n input an n n matrix a ..n ..n of real numbers for i to n do for j i to n do for k i to n do a j k a j k a i k a j i a i i a. find the time efficiency class of this algorithm. b. what glaring inefficiency does this pseudocode contain and how can it be eliminated to speed the algorithm up? . von neumann's neighborhood consider the algorithm that starts with a single square and on each of its n iterations adds new squares all around the outside. how many one by one squares are there after n iterations? gar in the parlance of cellular automata theory the answer is the number of cells in the von neumann neighborhood of range n. the results for n and are illustrated below. n n n . page numbering find the total number of decimal digits needed for numbering pages in a book of pages. assume that the pages are numbered consecutively starting with . 