in addition to the mathematical and empirical analyses of algorithms there is yet a third way to study algorithms. it is called algorithm visualization and can be defined as the use of images to convey some useful information about algorithms. that information can be a visual illustration of an algorithm's operation of its performance on different kinds of inputs or of its execution speed versus that of other algorithms for the same problem. to accomplish this goal an algorithm visualization uses graphic elements points line segments two or three dimensional bars and so on to represent some interesting events in the algorithm's operation. there are two principal variations of algorithm visualization static algorithm visualization dynamic algorithm visualization also called algorithm animation static algorithm visualization shows an algorithm's progress through a series of still images. algorithm animation on the other hand shows a continuous movie like presentation of an algorithm's operations. animation is an arguably more sophisticated option which of course is much more difficult to implement. early efforts in the area of algorithm visualization go back to the s. the watershed event happened in with the appearance of a minute color sound film titled sorting out sorting. this algorithm visualization classic was produced at the university of toronto by ronald baecker with the assistance of d. sherman bae bae . it contained visualizations of nine well known sorting algorithms more than half of them are discussed later in the book and provided quite a convincing demonstration of their relative speeds. the success of sorting out sorting made sorting algorithms a perennial favorite for algorithm animation. indeed the sorting problem lends itself quite naturally to visual presentation via vertical or horizontal bars or sticks of different heights or lengths which need to be rearranged according to their sizes figure . . this presentation is convenient however only for illustrating actions of a typical sorting algorithm on small inputs. for larger files sorting out sorting used the ingenious idea of presenting data by a scatterplot of points on a coordinate plane with the first coordinate representing an item's position in the file and the second one representing the item's value with such a representation the process of sorting looks like a transformation of a random scatterplot of points into the points along a frame's diagonal figure . . in addition most sorting algorithms figure . initial and final screens of a typical visualization of a sorting algorithm using the bar representation. work by comparing and exchanging two given items at a time an event that can be animated relatively easily. since the appearance of sorting out sorting a great number of algorithm animations have been created especially after the appearance of java and the figure . initial and final screens of a typical visualization of a sorting algorithm using the scatterplot representation. world wide web in the s. they range in scope from one particular algorithm to a group of algorithms for the same problem e.g. sorting or the same application area e.g. geometric algorithms to general purpose animation systems. at the end of a catalog of links to existing visualizations maintained under the nsf supported algovizproject contained over links. unfortunately a survey of existing visualizations found most of them to be of low quality with the content heavily skewed toward easier topics such as sorting sha . there are two principal applications of algorithm visualization research and education. potential benefits for researchers are based on expectations that algorithm visualization may help uncover some unknown features of algorithms. for example one researcher used a visualization of the recursive tower of hanoi algorithm in which odd and even numbered disks were colored in two different colors. he noticed that two disks of the same color never came in direct contact during the algorithm's execution. this observation helped him in developing a better nonrecursive version of the classic algorithm. to give another example bentley and mcilroy ben mentioned using an algorithm animation system in their work on improving a library implementation of a leading sorting algorithm. the application of algorithm visualization to education seeks to help students learning algorithms. the available evidence of its effectiveness is decisively mixed. although some experiments did register positive learning outcomes others failed to do so. the increasing body of evidence indicates that creating sophisticated software systems is not going to be enough. in fact it appears that the level of student involvement with visualization might be more important than specific features of visualization software. in some experiments low tech visualizations prepared by students were more effective than passive exposure to sophisticated software systems. to summarize although some successes in both research and education have been reported in the literature they are not as impressive as one might expect. a deeper understanding of human perception of images will be required before the true potential of algorithm visualization is fulfilled. summary there are two kinds of algorithm efficiency time efficiency and space efficiency. time efficiency indicates how fast the algorithm runs space efficiency deals with the extra space it requires. an algorithm's time efficiency is principally measured as a function of its input size by counting the number of times its basic operation is executed. a basic operation is the operation that contributes the most to running time. typically it is the most time consuming operation in the algorithm's innermost loop. for some algorithms the running time can differ considerably for inputs of the same size leading to worst case efficiency average case efficiency and best case efficiency. the established framework for analyzing time efficiency is primarily grounded in the order of growth of the algorithm's running time as its input size goes to infinity. the notations o and are used to indicate and compare the asymptotic orders of growth of functions expressing algorithm efficiencies. the efficiencies of a large number of algorithms fall into the following few classes constant logarithmic linear linearithmic quadratic cubic and exponential. the main tool for analyzing the time efficiency of a nonrecursive algorithm is to set up a sum expressing the number of executions of its basic operation and ascertain the sum's order of growth. the main tool for analyzing the time efficiency of a recursive algorithm is to set up a recurrence relation expressing the number of executions of its basic operation and ascertain the solution's order of growth. succinctness of a recursive algorithm may mask its inefficiency. the fibonacci numbers are an important sequence of integers in which every element is equal to the sum of its two immediate predecessors. there are several algorithms for computing the fibonacci numbers with drastically different efficiencies. empirical analysis of an algorithm is performed by running a program implementing the algorithm on a sample of inputs and analyzing the data observed the basic operation's count or physical running time . this often involves generating pseudorandom numbers. the applicability to any algorithm is the principal strength of this approach the dependence of results on the particular computer and instance sample is its main weakness. algorithm visualization is the use of images to convey useful information about algorithms. the two principal variations of algorithm visualization are static algorithm visualization and dynamic algorithm visualization also called algorithm animation . 