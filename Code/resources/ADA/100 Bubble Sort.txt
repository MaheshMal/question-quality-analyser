another brute force application to the sorting problem is to compare adjacent elements of the list and exchange them if they are out of order. by doing it repeatedly we end up bubbling up the largest element to the last position on the list. the next pass bubbles up the second largest element and so on until after n passes the list is sorted. pass i i n of bubble sort can be represented by the following diagram a . . . aj ? aj . . . an i an i . . . an in their final positions here is pseudocode of this algorithm. algorithm bubblesort a ..n sorts a given array by bubble sort input an array a ..n of orderable elements output array a ..n sorted in nondecreasing order for i to n do for j to n i do if a j a j swap a j and a j the action of the algorithm on the list is illustrated as an example in figure . . the number of key comparisons for the bubble sort version given above is the same for all arrays of size n it is obtained by a sum that is almost identical to the sum for selection sort ? ? ? ? ? ? ? ? ? ? ? etc. figure . first two passes of bubble sort on the list . a new line is shown after a swap of two elements is done. the elements to the right of the vertical bar are in their final positions and are not considered in subsequent iterations of the algorithm. n n i n c n n i i j i n n n n i n . i the number of key swaps however depends on the input. in the worst case of decreasing arrays it is the same as the number of key comparisons sworst n c n n n n . as is often the case with an application of the brute force strategy the first version of an algorithm obtained can often be improved upon with a modest amount of effort. specifically we can improve the crude version of bubble sort given above by exploiting the following observation if a pass through the list makes no exchanges the list has been sorted and we can stop the algorithm problem a in this section's exercises . though the new version runs faster on some inputs it is still in n in the worst and average cases. in fact even among elementary sorting methods bubble sort is an inferior choice and if it were not for its catchy name you would probably have never heard of it. however the general lesson you just learned is important and worth repeating a first application of the brute force approach often results in an algorithm that can be improved with a modest amount of effort. exercises . . a. give an example of an algorithm that should not be considered an application of the brute force approach. b. give an example of a problem that cannot be solved by a brute force algorithm. . a. what is the time efficiency of the brute force algorithm for computing an as a function of n? as a function of the number of bits in the binary representation of n? b. if you are to compute an mod m where a and n is a large positive integer how would you circumvent the problem of a very large magnitude of an? . for each of the algorithms in problems and of exercises . tell whether or not the algorithm is based on the brute force approach. . a. design a brute force algorithm for computing the value of a polynomial p x anxn an xn . . . a x a at a given point x and determine its worst case efficiency class. n design a linear algorithm for this b. if the algorithm you designed is in problem. c. is it possible to design an algorithm with a better than linear efficiency for this problem? . a network topology specifies how computers printers and other devices are connected over a network. the figure below illustrates three common topologies of networks the ring the star and the fully connected mesh. ring star fully connected mesh you are given a boolean matrix a ..n ..n where n which is supposed to be the adjacency matrix of a graph modeling a network with one of these topologies. your task is to determine which of these three topologies if any the matrix represents. design a brute force algorithm for this task and indicate its time efficiency class. . tetromino tilings tetrominoes are tiles made of four squares. there are five types of tetrominoes shown below straight tetromino square tetromino l tetromino t tetromino z tetromino is it possible to tile i.e. cover exactly without overlaps an chessboard with a. straight tetrominoes? b. square tetrominoes? c. l tetrominoes? d. t tetrominoes? e. z tetrominoes? . a stack of fake coins there are n stacks of n identical looking coins. all of the coins in one of these stacks are counterfeit while all the coins in the other stacks are genuine. every genuine coin weighs grams every fake weighs grams. you have an analytical scale that can determine the exact weight of any number of coins. a. devise a brute force algorithm to identify the stack with the fake coins and determine its worst case efficiency class. b. what is the minimum number of weighings needed to identify the stack with the fake coins? . sort the list e x a m p l e in alphabetical order by selection sort. . is selection sort stable? the definition of a stable sorting algorithm was given in section . . . is it possible to implement selection sort for linked lists with the same n efficiency as the array version? . sort the list e x a m p l e in alphabetical order by bubble sort. . a. prove that if bubble sort makes no exchanges on its pass through a list the list is sorted and the algorithm can be stopped. b. write pseudocode of the method that incorporates this improvement. c. prove that the worst case efficiency of the improved version is quadratic. . is bubble sort stable? . alternating disks you have a row of n disks of two colors n dark and n light. they alternate dark light dark light and so on. you want to get all the dark disks to the right hand end and all the light disks to the left hand end. the only moves you are allowed to make are those that interchange the positions of two neighboring disks. design an algorithm for solving this puzzle and determine the number of moves it takes. gar 