in this section we discuss an important problem for directed graphs with a variety of applications involving prerequisite restricted tasks. before we pose this problem though let us review a few basic facts about directed graphs themselves. a directed graph or digraph for short is a graph with directions specified for all its edges figure . a is an example . the adjacency matrix and adjacency lists are still two principal means of representing a digraph. there are only two notable differences between undirected and directed graphs in representing them the adjacency matrix of a directed graph does not have to be symmetric an edge in a directed graph has just one not two corresponding nodes in the digraph's adjacency lists. a b a d c b e d c e a b figure . a digraph. b dfs forest of the digraph for the dfs traversal started at a. depth first search and breadth first search are principal traversal algorithms for traversing digraphs as well but the structure of corresponding forests can be more complex than for undirected graphs. thus even for the simple example of figure . a the depth first search forest figure . b exhibits all four types of edges possible in a dfs forest of a directed graph tree edges ab bc de back edges ba from vertices to their ancestors forward edges ac from vertices to their descendants in the tree other than their children and cross edges dc which are none of the aforementioned types. note that a back edge in a dfs forest of a directed graph can connect a vertex to its parent. whether or not it is the case the presence of a back edge indicates that the digraph has a directed cycle. a directed cycle in a digraph is a sequence of three or more of its vertices that starts and ends with the same vertex and in which every vertex is connected to its immediate predecessor by an edge directed from the predecessor to the successor. for example a b a is a directed cycle in the digraph in figure . a. conversely if a dfs forest of a digraph has no back edges the digraph is a dag an acronym for directed acyclic graph. edge directions lead to new questions about digraphs that are either meaningless or trivial for undirected graphs. in this section we discuss one such question. as a motivating example consider a set of five required courses c c c c c a part time student has to take in some degree program. the courses can be taken in any order as long as the following course prerequisites are met c and c have no prerequisites c requires c and c c requires c and c requires c and c . the student can take only one course per term. in which order should the student take the courses? the situation can be modeled by a digraph in which vertices represent courses and directed edges indicate prerequisite requirements figure . . in terms of this digraph the question is whether we can list its vertices in such an order that for every edge in the graph the vertex where the edge starts is listed before the vertex where the edge ends. can you find such an ordering of this digraph's vertices? this problem is called topological sorting. it can be posed for an c c c c c figure . digraph representing the prerequisite structure of five courses. c c c the popping off order c c c c c c c c the topologically sorted list c c c c c c c c c a b c figure . a digraph for which the topological sorting problem needs to be solved. b dfs traversal stack with the subscript numbers indicating the poppingoff order. c solution to the problem. arbitrary digraph but it is easy to see that the problem cannot have a solution if a digraph has a directed cycle. thus for topological sorting to be possible a digraph in question must be a dag. it turns out that being a dag is not only necessary but also sufficient for topological sorting to be possible i.e. if a digraph has no directed cycles the topological sorting problem for it has a solution. moreover there are two efficient algorithms that both verify whether a digraph is a dag and if it is produce an ordering of vertices that solves the topological sorting problem. the first algorithm is a simple application of depth first search perform a dfs traversal and note the order in which vertices become dead ends i.e. popped off the traversal stack . reversing this order yields a solution to the topological sorting problem provided of course no back edge has been encountered during the traversal. if a back edge has been encountered the digraph is not a dag and topological sorting of its vertices is impossible. why does the algorithm work? when a vertex v is popped off a dfs stack no vertex u with an edge from u to v can be among the vertices popped off before v. otherwise u v would have been a back edge. hence any such vertex u will be listed after v in the popped off order list and before v in the reversed list. figure . illustrates an application of this algorithm to the digraph in figure . . note that in figure . c we have drawn the edges of the digraph and they all point from left to right as the problem's statement requires. it is a convenient way to check visually the correctness of a solution to an instance of the topological sorting problem. c c c c c delete c c delete c c c c c c c delete c c delete c delete c c c the solution obtained is c c c c c figure . illustration of the source removal algorithm for the topological sorting problem. on each iteration a vertex with no incoming edges is deleted from the digraph. the second algorithm is based on a direct implementation of the decrease by one and conquer technique repeatedly identify in a remaining digraph a source which is a vertex with no incoming edges and delete it along with all the edges outgoing from it. if there are several sources break the tie arbitrarily. if there are none stop because the problem cannot be solved see problem a in this section's exercises. the order in which the vertices are deleted yields a solution to the topological sorting problem. the application of this algorithm to the same digraph representing the five courses is given in figure . . note that the solution obtained by the source removal algorithm is different from the one obtained by the dfs based algorithm. both of them are correct of course the topological sorting problem may have several alternative solutions. the tiny size of the example we used might create a wrong impression about the topological sorting problem. but imagine a large project e.g. in construction research or software development that involves a multitude of interrelated tasks with known prerequisites. the first thing to do in such a situation is to make sure that the set of given prerequisites is not contradictory. the convenient way of doing this is to solve the topological sorting problem for the project's digraph. only then can one start thinking about scheduling tasks to say minimize the total completion time of the project. this would require of course other algorithms that you can find in general books on operations research or in special ones on cpm critical path method and pert program evaluation and review technique methodologies. as to applications of topological sorting in computer science they include instruction scheduling in program compilation cell evaluation ordering in spreadsheet formulas and resolving symbol dependencies in linkers. exercises . . apply the dfs based algorithm to solve the topological sorting problem for the following digraphs a b a b c d c d e g e f g f a b . a. prove that the topological sorting problem has a solution if and only if it is a dag. b. for a digraph with n vertices what is the largest number of distinct solutions the topological sorting problem can have? . a. what is the time efficiency of the dfs based algorithm for topological sorting? b. how can one modify the dfs based algorithm to avoid reversing the vertex ordering generated by dfs? . can one use the order in which vertices are pushed onto the dfs stack instead of the order they are popped off it to solve the topological sorting problem? . apply the source removal algorithm to the digraphs of problem above. . a. prove that a nonempty dag must have at least one source. b. how would you find a source or determine that such a vertex does not exist in a digraph represented by its adjacency matrix? what is the time efficiency of this operation? c. how would you find a source or determine that such a vertex does not exist in a digraph represented by its adjacency lists? what is the time efficiency of this operation? . can you implement the source removal algorithm for a digraph represented by its adjacency lists so that its running time is in o v e ? . implement the two topological sorting algorithms in the language of your choice. run an experiment to compare their running times. . a digraph is called strongly connected if for any pair of two distinct vertices u and v there exists a directed path from u to v and a directed path from v to u. in general a digraph's vertices can be partitioned into disjoint maximal subsets of vertices that are mutually accessible via directed paths these subsets are called strongly connected components of the digraph. there are two dfsbased algorithms for identifying strongly connected components. here is the simpler but somewhat less efficient one of the two step perform a dfs traversal of the digraph given and number its vertices in the order they become dead ends. step reverse the directions of all the edges of the digraph. step perform a dfs traversal of the new digraph by starting and if necessary restarting the traversal at the highest numbered vertex among still unvisited vertices. the strongly connected components are exactly the vertices of the dfs trees obtained during the last traversal. a. apply this algorithm to the following digraph to determine its strongly connected components a b c d e f g h b. what is the time efficiency class of this algorithm? give separate answers for the adjacency matrix representation and adjacency list representation of an input digraph. c. how many strongly connected components does a dag have? . spider's web a spider sits at the bottom point s of its web and a fly sits at the top f . how many different ways can the spider reach the fly by moving along the web's lines in the directions indicated by the arrows? kor f s 