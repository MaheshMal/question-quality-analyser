the selection problem is the problem of finding the kth smallest element in a list of n numbers. this number is called the kth order statistic. of course for k or k n we can simply scan the list in question to find the smallest or largest element respectively. a more interesting case of this problem is for k n which asks to find an element that is not larger than one half of the list's elements and not smaller than the other half. this middle value is called the median and it is one of the most important notions in mathematical statistics. obviously we can find the kth smallest element in a list by sorting the list first and then selecting the kth element in the output of a sorting algorithm. the time of such an algorithm is determined by the efficiency of the sorting algorithm used. thus with a fast sorting algorithm such as mergesort discussed in the next chapter the algorithm's efficiency is in o n log n . you should immediately suspect however that sorting the entire list is most likely overkill since the problem asks not to order the entire list but just to find its kth smallest element. indeed we can take advantage of the idea of partitioning a given list around some value p of say its first element. in general this is a rearrangement of the list's elements so that the left part contains all the elements smaller than or equal to p followed by the pivot p itself followed by all the elements greater than or equal to p. p all are p p all are p of the two principal algorithmic alternatives to partition an array here we discuss the lomuto partitioning ben p. we introduce the better known hoare's algorithm in the next chapter. to get the idea behind the lomuto partitioning it is helpful to think of an array or more generally a subarray a l..r l r n under consideration as composed of three contiguous segments. listed in the order they follow pivot p they are as follows a segment with elements known to be smaller than p the segment of elements known to be greater than or equal to p and the segment of elements yet to be compared to p see figure . a . note that the segments can be empty for example it is always the case for the first two segments before the algorithm starts. starting with i l the algorithm scans the subarray a l..r left to right maintaining this structure until a partition is achieved. on each iteration it compares the first element in the unknown segment pointed to by the scanning index i in figure . a with the pivot p. if a i p i is simply incremented to expand the segment of the elements greater than or equal to p while shrinking the unprocessed segment. if a i p it is the segment of the elements smaller than p that needs to be expanded. this is done by incrementing s the index of the last l s i r p p p ? a l s r p p p b l s r p p p c figure . illustration of the lomuto partitioning. element in the first segment swapping a i and a s and then incrementing i to point to the new first element of the shrunk unprocessed segment. after no unprocessed elements remain figure . b the algorithm swaps the pivot with a s to achieve a partition being sought figure . c . here is pseudocode implementing this partitioning procedure. algorithm lomutopartition a l ..r partitions subarray by lomuto's algorithm using first element as pivot input a subarray a l..r of array a ..n defined by its left and right indices l and r l r output partition of a l..r and the new position of the pivot p a l sl for i l to r do if a i p s s swap a s a i swap a l a s return s how can we take advantage of a list partition to find the kth smallest element in it? let us assume that the list is implemented as an array whose elements are indexed starting with a and let s be the partition's split position i.e. the index of the array's element occupied by the pivot after partitioning. if s k pivot p itself is obviously the kth smallest element which solves the problem. if s k the kth smallest element in the entire array can be found as the kth smallest element in the left part of the partitioned array. and if s k it can be found as the k s th smallest element in its right part. thus if we do not solve the problem outright we reduce its instance to a smaller one which can be solved by the same approach i.e. recursively. this algorithm is called quickselect. to find the kth smallest element in array a ..n by this algorithm call quickselect a ..n k where algorithm quickselect a l..r k solves the selection problem by recursive partition based algorithm input subarray a l..r of array a ..n of orderable elements and integer k k r l output the value of the kth smallest element in a l..r s lomutopartition a l..r or another partition algorithm if s k return a s else if s l k quickselect a l..s k else quickselect a s ..r k s in fact the same idea can be implemented without recursion as well. for the nonrecursive version we need not even adjust the value of k but just continue until s k . example apply the partition based algorithm to find the median of the following list of nine numbers . here k and our task is to find the th smallest element in the array. we use the above version of array partitioning showing the pivots in bold. s i s i s i s i s i since s is smaller than k we proceed with the right part of the array s i s i s i now s k and hence we can stop the found median is which is greater than and but smaller than and . how efficient is quickselect? partitioning an n element array always requires n key comparisons. if it produces the split that solves the selection problem without requiring more iterations then for this best case we obtain cbest n n n . unfortunately the algorithm can produce an extremely unbalanced partition of a given array with one part being empty and the other containing n elements. in the worst case this can happen on each of the n iterations. for a specific example of the worst case input consider say the case of k n and a strictly increasing array. this implies that cworst n n n . . . n n n which compares poorly with the straightforward sorting based approach mentioned in the beginning of our selection problem discussion. thus the usefulness of the partition based algorithm depends on the algorithm's efficiency in the average case. fortunately a careful mathematical analysis has shown that the average case efficiency is linear. in fact computer scientists have discovered a more sophisticated way of choosing a pivot in quickselect that guarantees linear time even in the worst case blo but it is too complicated to be recommended for practical applications. it is also worth noting that the partition based algorithm solves a somewhat more general problem of identifying the k smallest and n k largest elements of a given list not just the value of its kth smallest element. 