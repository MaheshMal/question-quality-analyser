most algorithms are destined to be ultimately implemented as computer programs. programming an algorithm presents both a peril and an opportunity. the peril lies in the possibility of making the transition from an algorithm to a program either incorrectly or very inefficiently. some influential computer scientists strongly believe that unless the correctness of a computer program is proven with full mathematical rigor the program cannot be considered correct. they have developed special techniques for doing such proofs see gri but the power of these techniques of formal verification is limited so far to very small programs. as a practical matter the validity of programs is still established by testing. testing of computer programs is an art rather than a science but that does not mean that there is nothing in it to learn. look up books devoted to testing and debugging even more important test and debug your program thoroughly whenever you implement an algorithm. also note that throughout the book we assume that inputs to algorithms belong to the specified sets and hence require no verification. when implementing algorithms as programs to be used in actual applications you should provide such verifications. of course implementing an algorithm correctly is necessary but not sufficient you would not like to diminish your algorithm's power by an inefficient implementation. modern compilers do provide a certain safety net in this regard especially when they are used in their code optimization mode. still you need to be aware of such standard tricks as computing a loop's invariant an expression that does not change its value outside the loop collecting common subexpressions replacing expensive operations by cheap ones and so on. see ker and ben for a good discussion of code tuning and other issues related to algorithm programming. typically such improvements can speed up a program only by a constant factor whereas a better algorithm can make a difference in running time by orders of magnitude. but once an algorithm is selected a speedup may be worth an effort. . i found this call for design simplicity in an essay collection by jon bentley ben the essays deal with a variety of issues in algorithm design and implementation and are justifiably titled programming pearls. i wholeheartedly recommend the writings of both jon bentley and antoine de saint exupe ry. a working program provides an additional opportunity in allowing an empirical analysis of the underlying algorithm. such an analysis is based on timing the program on several inputs and then analyzing the results obtained. we discuss the advantages and disadvantages of this approach to analyzing algorithms in section . . in conclusion let us emphasize again the main lesson of the process depicted in figure . as a rule a good algorithm is a result of repeated effort and rework. even if you have been fortunate enough to get an algorithmic idea that seems perfect you should still try to see whether it can be improved. actually this is good news since it makes the ultimate result so much more enjoyable. yes i did think of naming this book the joy of algorithms. on the other hand how does one know when to stop? in the real world more often than not a project's schedule or the impatience of your boss will stop you. and so it should be perfection is expensive and in fact not always called for. designing an algorithm is an engineering like activity that calls for compromises among competing goals under the constraints of available resources with the designer's time being one of the resources. in the academic world the question leads to an interesting but usually difficult investigation of an algorithm's optimality. actually this question is not about the efficiency of an algorithm but about the complexity of the problem it solves what is the minimum amount of effort any algorithm will need to exert to solve the problem? for some problems the answer to this question is known. for example any algorithm that sorts an array by comparing values of its elements needs about n log n comparisons for some arrays of size n see section . . but for many seemingly easy problems such as integer multiplication computer scientists do not yet have a final answer. another important issue of algorithmic problem solving is the question of whether or not every problem can be solved by an algorithm. we are not talking here about problems that do not have a solution such as finding real roots of a quadratic equation with a negative discriminant. for such cases an output indicating that the problem does not have a solution is all we can and should expect from an algorithm. nor are we talking about ambiguously stated problems. even some unambiguous problems that must have a simple yes or no answer are undecidable i.e. unsolvable by any algorithm. an important example of such a problem appears in section . . fortunately a vast majority of problems in practical computing can be solved by an algorithm. before leaving this section let us be sure that you do not have the misconception possibly caused by the somewhat mechanical nature of the diagram of figure . that designing an algorithm is a dull activity. there is nothing further from the truth inventing or discovering? algorithms is a very creative and rewarding process. this book is designed to convince you that this is the case. exercises . . old world puzzle a peasant finds himself on a riverbank with a wolf a goat and a head of cabbage. he needs to transport all three to the other side of the river in his boat. however the boat has room for only the peasant himself and one other item either the wolf the goat or the cabbage . in his absence the wolf would eat the goat and the goat would eat the cabbage. solve this problem for the peasant or prove it has no solution. note the peasant is a vegetarian but does not like cabbage and hence can eat neither the goat nor the cabbage to help him solve the problem. and it goes without saying that the wolf is a protected species. . new world puzzle there are four people who want to cross a rickety bridge they all begin on the same side. you have minutes to get them all across to the other side. it is night and they have one flashlight. a maximum of two people can cross the bridge at one time. any party that crosses either one or two people must have the flashlight with them. the flashlight must be walked back and forth it cannot be thrown for example. person takes minute to cross the bridge person takes minutes person takes minutes and person takes minutes. a pair must walk together at the rate of the slower person's pace. note according to a rumor on the internet interviewers at a well known software company located near seattle have given this problem to interviewees. . which of the following formulas can be considered an algorithm for computing the area of a triangle whose side lengths are given positive numbers a b and c? a. s p p a p b p c where p a b c b. s bc sin a where a is the angle between sides b and c c. s aha where ha is the height to base a . write pseudocode for an algorithm for finding real roots of equation ax bx c for arbitrary real coefficients a b and c. you may assume the availability of the square root function sqrt x . . describe the standard algorithm for finding the binary representation of a positive decimal integer a. in english. b. in pseudocode. . describe the algorithm used by your favorite atm machine in dispensing cash. you may give your description in either english or pseudocode whichever you find more convenient. . a. can the problem of computing the number be solved exactly? b. how many instances does this problem have? c. look up an algorithm for this problem on the internet. . give an example of a problem other than computing the greatest common divisor for which you know more than one algorithm. which of them is simpler? which is more efficient? . consider the following algorithm for finding the distance between the two closest elements in an array of numbers. algorithm mindistance a ..n input array a ..n of numbers output minimum distance between two of its elements dmin for i to n do for j to n do if i j and a i a j dmin dmin a i a j return dmin make as many improvements as you can in this algorithmic solution to the problem. if you need to you may change the algorithm altogether if not improve the implementation given. . one of the most influential books on problem solving titled how to solve it pol was written by the hungarian american mathematician george po lya . po lya summarized his ideas in a four point summary. find this summary on the internet or better yet in his book and compare it with the plan outlined in section . . what do they have in common? how are they different? 