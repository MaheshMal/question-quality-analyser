? although there is no universally agreed on wording to describe this notion there is general agreement about what the concept means an algorithm is a sequence of unambiguous instructions for solving a problem i.e. for obtaining a required output for any legitimate input in a finite amount of time. this definition can be illustrated by a simple diagram figure . . the reference to instructions in the definition implies that there is something or someone capable of understanding and following the instructions given. we call this a computer keeping in mind that before the electronic computer was invented the word computer meant a human being involved in performing numeric calculations. nowadays of course computers are those ubiquitous electronic devices that have become indispensable in almost everything we do. note however that although the majority of algorithms are indeed intended for eventual computer implementation the notion of algorithm does not depend on such an assumption. as examples illustrating the notion of the algorithm we consider in this section three methods for solving the same problem computing the greatest common divisor of two integers. these examples will help us to illustrate several important points the nonambiguity requirement for each step of an algorithm cannot be compromised. the range of inputs for which an algorithm works has to be specified carefully. the same algorithm can be represented in several different ways. there may exist several algorithms for solving the same problem. problem algorithm input computer output figure . the notion of the algorithm. algorithms for the same problem can be based on very different ideas and can solve the problem with dramatically different speeds. recall that the greatest common divisor of two nonnegative not both zero integers m and n denoted gcd m n is defined as the largest integer that divides both m and n evenly i.e. with a remainder of zero. euclid of alexandria third century b.c. outlined an algorithm for solving this problem in one of the volumes of his elements most famous for its systematic exposition of geometry. in modern terms euclid's algorithm is based on applying repeatedly the equality gcd m n gcd n m mod n where m mod n is the remainder of the division of m by n until m mod n is equal to . since gcd m m why? the last value of m is also the greatest common divisor of the initial m and n. for example gcd can be computed as follows gcd gcd gcd . if you are not impressed by this algorithm try finding the greatest common divisor of larger numbers such as those in problem in this section's exercises. here is a more structured description of this algorithm euclid's algorithm for computing gcd m n step if n return the value of m as the answer and stop otherwise proceed to step . step divide m by n and assign the value of the remainder to r. step assign the value of n to m and the value of r to n. go to step . alternatively we can express the same algorithm in pseudocode algorithm euclid m n computes gcd m n by euclid's algorithm input two nonnegative not both zero integers m and n output greatest common divisor of m and n while n do r m mod n mn nr return m how do we know that euclid's algorithm eventually comes to a stop? this follows from the observation that the second integer of the pair gets smaller with each iteration and it cannot become negative. indeed the new value of n on the next iteration is m mod n which is always smaller than n why? . hence the value of the second integer eventually becomes and the algorithm stops. just as with many other problems there are several algorithms for computing the greatest common divisor. let us look at the other two methods for this problem. the first is simply based on the definition of the greatest common divisor of m and n as the largest integer that divides both numbers evenly. obviously such a common divisor cannot be greater than the smaller of these numbers which we will denote by t min m n . so we can start by checking whether t divides both m and n if it does t is the answer if it does not we simply decrease t by and try again. how do we know that the process will eventually stop? for example for numbers and the algorithm will try first then and so on until it reaches where it stops. consecutive integer checking algorithm for computing gcd m n step assign the value of min m n to t. step divide m by t. if the remainder of this division is go to step otherwise go to step . step divide n by t. if the remainder of this division is return the value of t as the answer and stop otherwise proceed to step . step decrease the value of t by . go to step . note that unlike euclid's algorithm this algorithm in the form presented does not work correctly when one of its input numbers is zero. this example illustrates why it is so important to specify the set of an algorithm's inputs explicitly and carefully. the third procedure for finding the greatest common divisor should be familiar to you from middle school. middle school procedure for computing gcd m n step find the prime factors of m. step find the prime factors of n. step identify all the common factors in the two prime expansions found in step and step . if p is a common factor occurring pm and pn times in m and n respectively it should be repeated min pm pn times. step compute the product of all the common factors and return it as the greatest common divisor of the numbers given. thus for the numbers and we get . . . . . . gcd . . . nostalgia for the days when we learned this method should not prevent us from noting that the last procedure is much more complex and slower than euclid's algorithm. we will discuss methods for finding and comparing running times of algorithms in the next chapter. in addition to inferior efficiency the middleschool procedure does not qualify in the form presented as a legitimate algorithm. why? because the prime factorization steps are not defined unambiguously they require a list of prime numbers and i strongly suspect that your middle school math teacher did not explain how to obtain such a list. this is not a matter of unnecessary nitpicking. unless this issue is resolved we cannot say write a program implementing this procedure. incidentally step is also not defined clearly enough. its ambiguity is much easier to rectify than that of the factorization steps however. how would you find common elements in two sorted lists? so let us introduce a simple algorithm for generating consecutive primes not exceeding any given integer n . it was probably invented in ancient greece and is known as the sieve of eratosthenes ca. b.c. . the algorithm starts by initializing a list of prime candidates with consecutive integers from to n. then on its first iteration the algorithm eliminates from the list all multiples of i.e. and so on. then it moves to the next item on the list which is and eliminates its multiples. in this straightforward version there is an overhead because some numbers such as are eliminated more than once. no pass for number is needed since itself and all its multiples are also multiples of they were already eliminated on a previous pass. the next remaining number on the list which is used on the third pass is . the algorithm continues in this fashion until no more numbers can be eliminated from the list. the remaining integers of the list are the primes needed. as an example consider the application of the algorithm to finding the list of primes not exceeding n for this example no more passes are needed because they would eliminate numbers already eliminated on previous iterations of the algorithm. the remaining numbers on the list are the consecutive primes less than or equal to . what is the largest number p whose multiples can still remain on the list to make further iterations of the algorithm necessary? before we answer this question let us first note that if p is a number whose multiples are being eliminated on the current pass then the first multiple we should consider is p . p because all its smaller multiples p . . . p p have been eliminated on earlier passes through the list. this observation helps to avoid eliminating the same number more than once. obviously p . p should not be greater than n and therefore p cannot exceed n rounded down denoted n using the so called floor function . we assume in the following pseudocode that there is a function available for computing n alternatively we could check the inequality p . p n as the loop continuation condition there. algorithm sieve n implements the sieve of eratosthenes input a positive integer n output array l of all prime numbers less than or equal to n for p to ndo a p p for p to n do see note before pseudocode if a p p hasn't been eliminated on previous passes j pp while j n do a j mark element as eliminated j j p copy the remaining elements of a to array l of the primes i for p to n do if a p l i a p ii return l so now we can incorporate the sieve of eratosthenes into the middle school procedure to get a legitimate algorithm for computing the greatest common divisor of two positive integers. note that special care needs to be exercised if one or both input numbers are equal to because mathematicians do not consider to be a prime number strictly speaking the method does not work for such inputs. before we leave this section one more comment is in order. the examples considered in this section notwithstanding the majority of algorithms in use today even those that are implemented as computer programs do not deal with mathematical problems. look around for algorithms helping us through our daily routines both professional and personal. may this ubiquity of algorithms in today's world strengthen your resolve to learn more about these fascinating engines of the information age. exercises . . do some research on al khorezmi also al khwarizmi the man from whose name the word algorithm is derived. in particular you should learn what the origins of the words algorithm and algebra have in common. . given that the official purpose of the u.s. patent system is the promotion of the useful arts do you think algorithms are patentable in this country? should they be? . a. write down driving directions for going from your school to your home with the precision required from an algorithm's description. b. write down a recipe for cooking your favorite dish with the precision required by an algorithm. . design an algorithm for computing n for any positive integer n. besides assignment and comparison your algorithm may only use the four basic arithmetical operations. . design an algorithm to find all the common elements in two sorted lists of numbers. for example for the lists and the output should be . what is the maximum number of comparisons your algorithm makes if the lengths of the two given lists are m and n respectively? . a. find gcd by applying euclid's algorithm. b. estimate how many times faster it will be to find gcd by euclid's algorithm compared with the algorithm based on checking consecutive integers from min m n down to gcd m n . . prove the equality gcd m n gcd n m mod n for every pair of positive integers m and n. . what does euclid's algorithm do for a pair of integers in which the first is smaller than the second? what is the maximum number of times this can happen during the algorithm's execution on such an input? . a. what is the minimum number of divisions made by euclid's algorithm among all inputs m n ? b. what is the maximum number of divisions made by euclid's algorithm among all inputs m n ? . a. euclid's algorithm as presented in euclid's treatise uses subtractions rather than integer divisions. write pseudocode for this version of euclid's algorithm. b. euclid's game see bog starts with two unequal positive integers on the board. two players move in turn. on each move a player has to write on the board a positive number equal to the difference of two numbers already on the board this number must be new i.e. different from all the numbers already on the board. the player who cannot move loses the game. should you choose to move first or second in this game? . the extended euclid's algorithm determines not only the greatest common divisor d of two positive integers m and n but also integers not necessarily positive x and y such that mx ny d. a. look up a description of the extended euclid's algorithm see e.g. knui p. and implement it in the language of your choice. b. modify your program to find integer solutions to the diophantine equation ax by c with any set of integer coefficients a b and c. . locker doors there are n lockers in a hallway numbered sequentially from to n. initially all the locker doors are closed. you make n passes by the lockers each time starting with locker . on the ith pass i . . . n you toggle the door of every ith locker if the door is closed you open it if it is open you close it. after the last pass which locker doors are open and which are closed? how many of them are open? 