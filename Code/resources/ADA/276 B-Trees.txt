the idea of using extra space to facilitate faster access to a given data set is particularly important if the data set in question contains a very large number of records that need to be stored on a disk. a principal device in organizing such data sets is an index which provides some information about the location of records with indicated key values. for data sets of structured records as opposed to unstructured data such as text images sound and video the most important index organization is the b tree introduced by r. bayer and e. mcgreight bay . it extends the idea of the tree see section . by permitting more than a single key in the same node of a search tree. in the b tree version we consider here all data records or record keys are stored at the leaves in increasing order of the keys. the parental nodes are used for indexing. specifically each parental node contains n ordered keys k . . . kn assumed for the sake of simplicity to be distinct. the keys are interposed with n pointers to the node's children so that all the keys in subtree t are smaller than k all the keys in subtree t are greater than or equal to k and smaller than k with k being equal to the smallest key in t and so on through the last subtree tn whose keys are greater than or equal to kn with kn being equal to the smallest key in tn see figure . . in addition a b tree of order m must satisfy the following structural properties the root is either a leaf or has between and m children. each node except for the root and the leaves has between m and m children and hence between m and m keys . the tree is perfectly balanced i.e. all its leaves are at the same level. . the node depicted in figure . is called the n node. thus all the nodes in a classic binary search tree are nodes a tree introduced in section . comprises nodes and nodes. figure . example of a b tree of order . an example of a b tree of order is given in figure . . searching in a b tree is very similar to searching in the binary search tree and even more so in the tree. starting with the root we follow a chain of pointers to the leaf that may contain the search key. then we search for the search key among the keys of that leaf. note that since keys are stored in sorted order at both parental nodes and leaves we can use binary search if the number of keys at a node is large enough to make it worthwhile. it is not the number of key comparisons however that we should be concerned about in a typical application of this data structure. when used for storing a large data file on a disk the nodes of a b tree normally correspond to the disk pages. since the time needed to access a disk page is typically several orders of magnitude larger than the time needed to compare keys in the fast computer memory it is the number of disk accesses that becomes the principal indicator of the efficiency of this and similar data structures. how many nodes of a b tree do we need to access during a search for a record with a given key value? this number is obviously equal to the height of the tree plus . to estimate the height let us find the smallest number of keys a b tree of order m and positive height h can have. the root of the tree will contain at least one key. level will have at least two nodes with at least m keys in each of them for the total minimum number of keys m . level will have at least m nodes the children of the nodes on level with at least m in each of them for the total minimum number of keys m m . in general the nodes of level i i h will contain at least m i m keys. finally level h the leaf level will have at least m h nodes with at least one key in each. thus for any b tree of order m with n nodes and height h we have the following inequality h n m i m m h . i after a series of standard simplifications see problem in this section's exercises this inequality reduces to n m h which in turn yields the following upper bound on the height h of the b tree of order m with n nodes h log m n . . inequality . immediately implies that searching in a b tree is a o log n operation. but it is important to ascertain here not just the efficiency class but the actual number of disk accesses implied by this formula. the following table contains the values of the right hand side estimates for a file of million records and a few typical values of the tree's order m order m h's upper bound keep in mind that the table's entries are upper estimates for the number of disk accesses. in actual applications this number rarely exceeds with the b tree's root and sometimes first level nodes stored in the fast memory to minimize the number of disk accesses. the operations of insertion and deletion are less straightforward than searching but both can also be done in o log n time. here we outline an insertion algorithm only a deletion algorithm can be found in the references e.g. aho cor . the most straightforward algorithm for inserting a new record into a btree is quite similar to the algorithm for insertion into a tree outlined in section . . first we apply the search procedure to the new record's key k to find the appropriate leaf for the new record. if there is room for the record in that leaf we place it there in an appropriate position so that the keys remain sorted and we are done. if there is no room for the record the leaf is split in half by sending the second half of the records to a new node. after that the smallest key k in the new node and the pointer to it are inserted into the old leaf's parent immediately after the key and pointer to the old leaf . this recursive procedure may percolate up to the tree's root. if the root is already full too a new root is created with the two halves of the old root's keys split between two children of the new root. as an example figure . shows the result of inserting into the b tree in figure . under the restriction that the leaves cannot contain more than three items. you should be aware that there are other algorithms for implementing insertions into a b tree. for example to avoid the possibility of recursive node splits we can split full nodes encountered in searching for an appropriate leaf for the new record. another possibility is to avoid some node splits by moving a key to the node's sibling. for example inserting into the b tree in figure . can be done by moving the smallest key of the full leaf to its sibling with keys and and replacing the key value of their parent by the new smallest value in figure . b tree obtained after inserting into the b tree in figure . . the second child. this modification tends to save some space at the expense of a slightly more complicated algorithm. a b tree does not have to be always associated with the indexing of a large file and it can be considered as one of several search tree varieties. as with other types of search trees such as binary search trees avl trees and trees a btree can be constructed by successive insertions of data records into the initially empty tree. the empty tree is considered to be a b tree too. when all keys reside in the leaves and the upper levels are organized as a b tree comprising an index the entire structure is usually called in fact a b tree. exercises . . give examples of using an index in real life applications that do not involve computers. . a. prove the equality h m i m m h m h i which was used in the derivation of upper bound . for the height of a b tree. b. complete the derivation of inequality . . . find the minimum order of the b tree that guarantees that the number of disk accesses in searching in a file of million records does not exceed . assume that the root's page is stored in main memory. . draw the b tree obtained after inserting and then in the b tree in figure . . assume that a leaf cannot contain more than three items. . outline an algorithm for finding the largest key in a b tree. . a. a top down tree is a b tree of order with the following modification of the insert operation whenever a search for a leaf for a new key encounters a full node i.e. a node with three keys the node is split into two nodes by sending its middle key to the node's parent or if the full node happens to be the root the new root for the middle key is created. construct a top down tree by inserting the following list of keys in the initially empty tree . b. what is the principal advantage of this insertion procedure compared with the one used for trees in section . ? what is its disadvantage? . a. write a program implementing a key insertion algorithm in a b tree. b. write a program for visualization of a key insertion algorithm in a b tree. summary space and time trade offs in algorithm design are a well known issue for both theoreticians and practitioners of computing. as an algorithm design technique trading space for time is much more prevalent than trading time for space. input enhancement is one of the two principal varieties of trading space for time in algorithm design. its idea is to preprocess the problem's input in whole or in part and store the additional information obtained in order to accelerate solving the problem afterward. sorting by distribution counting and several important algorithms for string matching are examples of algorithms based on this technique. distribution counting is a special method for sorting lists of elements from a small set of possible values. horspool's algorithm for string matching can be considered a simplified version of the boyer moore algorithm.both algorithms are based on the ideas of input enhancement and right to left comparisons of a pattern's characters. both algorithms use the same bad symbol shift table the boyer moore also uses a second table called the good suffix shift table. prestructuring the second type of technique that exploits space for time trade offs uses extra space to facilitate a faster and or more flexible access to the data. hashing and b trees are important examples of prestructuring. hashing is a very efficient approach to implementing dictionaries. it is based on the idea of mapping keys into a one dimensional table. the size limitations of such a table make it necessary to employ a collision resolution mechanism. the two principal varieties of hashing are open hashing or separate chaining with keys stored in linked lists outside of the hash table and closed hashing or open addressing with keys stored inside the table . both enable searching insertion and deletion in time on average. the b tree is a balanced search tree that generalizes the idea of the tree by allowing multiple keys at the same node. its principal application called the b tree is for keeping index like information about data stored on a disk. by choosing the order of the tree appropriately one can implement the operations of searching insertion and deletion with just a few disk accesses even for extremely large files. 