depth first search starts a graph's traversal at an arbitrary vertex by marking it as visited. on each iteration the algorithm proceeds to an unvisited vertex that is adjacent to the one it is currently in. if there are several such vertices a tie can be resolved arbitrarily. as a practical matter which of the adjacent unvisited candidates is chosen is dictated by the data structure representing the graph. in our examples we always break ties by the alphabetical order of the vertices. this process continues until a dead end a vertex with no adjacent unvisited vertices is encountered. at a dead end the algorithm backs up one edge to the vertex it came from and tries to continue visiting unvisited vertices from there. the algorithm eventually halts after backing up to the starting vertex with the latter being a dead end. by then all the vertices in the same connected component as the starting vertex have been visited. if unvisited vertices still remain the depth first search must be restarted at any one of them. it is convenient to use a stack to trace the operation of depth first search. we push a vertex onto the stack when the vertex is reached for the first time i.e. the a g g h e c h a e b j c f d f i d f i c h d b a g j b j i e a b c figure . example of a dfs traversal. a graph. b traversal's stack the first subscript number indicates the order in which a vertex is visited i.e. pushed onto the stack the second one indicates the order in which it becomes a dead end i.e. popped off the stack . c dfs forest with the tree and back edges shown with solid and dashed lines respectively. visit of the vertex starts and we pop a vertex off the stack when it becomes a dead end i.e. the visit of the vertex ends . it is also very useful to accompany a depth first search traversal by constructing the so called depth first search forest. the starting vertex of the traversal serves as the root of the first tree in such a forest. whenever a new unvisited vertex is reached for the first time it is attached as a child to the vertex from which it is being reached. such an edge is called a tree edge because the set of all such edges forms a forest. the algorithm may also encounter an edge leading to a previously visited vertex other than its immediate predecessor i.e. its parent in the tree . such an edge is called a back edge because it connects a vertex to its ancestor other than the parent in the depth first search forest. figure . provides an example of a depth first search traversal with the traversal stack and corresponding depth first search forest shown as well. here is pseudocode of the depth first search. algorithm dfs g implements a depth first search traversal of a given graph input graph g v e output graph g with its vertices marked with consecutive integers in the order they are first encountered by the dfs traversal mark each vertex in v with as a mark of being unvisited count for each vertex v in v do if v is marked with dfs v dfs v visits recursively all the unvisited vertices connected to vertex v by a path and numbers them in the order they are encountered via global variable count count count mark v with count for each vertex w in v adjacent to v do if w is marked with dfs w the brevity of the dfs pseudocode and the ease with which it can be performed by hand may create a wrong impression about the level of sophistication of this algorithm. to appreciate its true power and depth you should trace the algorithm's action by looking not at a graph's diagram but at its adjacency matrix or adjacency lists. try it for the graph in figure . or a smaller example. how efficient is depth first search? it is not difficult to see that this algorithm is in fact quite efficient since it takes just the time proportional to the size of the data structure used for representing the graph in question. thus for the adjacency matrix representation the traversal time is in v and for the adjacency list representation it is in v e where v and e are the number of the graph's vertices and edges respectively. a dfs forest which is obtained as a by product of a dfs traversal deserves a few comments too. to begin with it is not actually a forest. rather we can look at it as the given graph with its edges classified by the dfs traversal into two disjoint classes tree edges and back edges. no other types are possible for a dfs forest of an undirected graph. again tree edges are edges used by the dfs traversal to reach previously unvisited vertices. if we consider only the edges in this class we will indeed get a forest. back edges connect vertices to previously visited vertices other than their immediate predecessors in the traversal. they connect vertices to their ancestors in the forest other than their parents. a dfs traversal itself and the forest like representation of the graph it provides have proved to be extremely helpful for the development of efficient algorithms for checking many important properties of graphs. note that the dfs yields two orderings of vertices the order in which the vertices are reached for the first time pushed onto the stack and the order in which the vertices become dead ends popped off the stack . these orders are qualitatively different and various applications can take advantage of either of them. important elementary applications of dfs include checking connectivity and checking acyclicity of a graph. since dfs halts after visiting all the vertices con . the discovery of several such applications was an important breakthrough achieved by the two american computer scientists john hopcroft and robert tarjan in the s. for this and other contributions they were given the turing award the most prestigious prize in the computing field hop tar . nected by a path to the starting vertex checking a graph's connectivity can be done as follows. start a dfs traversal at an arbitrary vertex and check after the algorithm halts whether all the vertices of the graph will have been visited. if they have the graph is connected otherwise it is not connected. more generally we can use dfs for identifying connected components of a graph how? . as for checking for a cycle presence in a graph we can take advantage of the graph's representation in the form of a dfs forest. if the latter does not have back edges the graph is clearly acyclic. if there is a back edge from some vertex u to its ancestor v e.g. the back edge from d to a in figure . c the graph has a cycle that comprises the path from v to u via a sequence of tree edges in the dfs forest followed by the back edge from u to v. you will find a few other applications of dfs later in the book although more sophisticated applications such as finding articulation points of a graph are not included. a vertex of a connected graph is said to be its articulation point if its removal with all edges incident to it breaks the graph into disjoint pieces. 