whatever man prays for he prays for a miracle. every prayer reduces itself to this great god grant that twice two be not four. ivan turgenev russian novelist and short story writer divide and conquer is probably the best known general algorithm design technique. though its fame may have something to do with its catchy name it is well deserved quite a few very efficient algorithms are specific implementations of this general strategy. divide and conquer algorithms work according to the following general plan . a problem is divided into several subproblems of the same type ideally of about equal size. . the subproblems are solved typically recursively though sometimes a different algorithm is employed especially when subproblems become small enough . . if necessary the solutions to the subproblems are combined to get a solution to the original problem. the divide and conquer technique is diagrammed in figure . which depicts the case of dividing a problem into two smaller subproblems by far the most widely occurring case at least for divide and conquer algorithms designed to be executed on a single processor computer . as an example let us consider the problem of computing the sum of n numbers a . . . an . if n we can divide the problem into two instances of the same problem to compute the sum of the first n numbers and to compute the sum of the remaining n numbers. of course if n we simply return a as the answer. once each of these two sums is computed by applying the same method recursively we can add their values to get the sum in question a . . . an a . . . a n a n . . . an . is this an efficient way to compute the sum of n numbers? a moment of reflection why could it be more efficient than the brute force summation? a problem of size n subproblem subproblem of size n of size n solution to solution to subproblem subproblem solution to the original problem figure . divide and conquer technique typical case . small example of summing say four numbers by this algorithm a formal analysis which follows and common sense we do not normally compute sums this way do we? all lead to a negative answer to this question. thus not every divide and conquer algorithm is necessarily more efficient than even a brute force solution. but often our prayers to the goddess of algorithmics see the chapter's epigraph are answered and the time spent on executing the divide and conquer plan turns out to be significantly smaller than solving a problem by a different method. in fact the divide and conquer approach yields some of the most important and efficient algorithms in computer science. we discuss a few classic examples of such algorithms in this chapter. though we consider only sequential algorithms here it is worth keeping in mind that the divide and conquer technique is ideally suited for parallel computations in which each subproblem can be solved simultaneously by its own processor. . actually the divide and conquer algorithm called the pairwise summation may substantially reduce the accumulated round off error of the sum of numbers that can be represented only approximately in a digital computer hig . as mentioned above in the most typical case of divide and conquer a problem's instance of size n is divided into two instances of size n . more generally an instance of size n can be divided into b instances of size n b with a of them needing to be solved. here a and b are constants a and b . assuming that size n is a power of b to simplify our analysis we get the following recurrence for the running time t n t n at n b f n . where f n is a function that accounts for the time spent on dividing an instance of size n into instances of size n b and combining their solutions. for the sum example above a b and f n . recurrence . is called the general divide and conquer recurrence. obviously the order of growth of its solution t n depends on the values of the constants a and b and the order of growth of the function f n . the efficiency analysis of many divide and conquer algorithms is greatly simplified by the following theorem see appendix b . master theorem if f n nd where d in recurrence . then nd if a bd t n nd log n if a bd nlogb a if a bd. analogous results hold for the o and notations too. for example the recurrence for the number of additions a n made by the divide and conquer sum computation algorithm see above on inputs of size n k is a n a n . thus for this example a b and d hence since a bd a n nlogb a nlog n . note that we were able to find the solution's efficiency class without going through the drudgery of solving the recurrence. but of course this approach can only establish a solution's order of growth to within an unknown multiplicative constant whereas solving a recurrence equation with a specific initial condition yields an exact answer at least for n's that are powers of b . it is also worth pointing out that if a recurrence . covers decreaseby a constant factor algorithms discussed in the previous chapter. in fact some people consider such algorithms as binary search degenerate cases of divide andconquer where just one of two subproblems of half the size needs to be solved. it is better not to do this and consider decrease by a constant factor and divideand conquer as different design paradigms. 