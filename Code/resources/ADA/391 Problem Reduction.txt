we have already encountered the problem reduction approach in section . . there we discussed getting an algorithm for problem p by reducing it to another problem q solvable with a known algorithm. a similar reduction idea can be used for finding a lower bound. to show that problem p is at least as hard as another problem q with a known lower bound we need to reduce q to p not p to q! . in other words we should show that an arbitrary instance of problem q can be transformed in a reasonably efficient fashion to an instance of problem p so any algorithm solving p would solve q as well. then a lower bound for q will be a lower bound for p . table . lists several important problems that are often used for this purpose. table . problems often used for establishing lower bounds by problem reduction problem lower bound tightness sorting n log n yes searching in a sorted array log n yes element uniqueness problem n log n yes multiplication of n digit integers n unknown multiplication of n n matrices n unknown we will establish the lower bounds for sorting and searching in the next section. the element uniqueness problem asks whether there are duplicates among n given numbers. we encountered this problem in sections . and . . the proof of the lower bound for this seemingly simple problem is based on a very sophisticated mathematical analysis that is well beyond the scope of this book see e.g. pre for a rather elementary exposition . as to the last two algebraic problems in table . the lower bounds quoted are trivial but whether they can be improved remains unknown. as an example of establishing a lower bound by reduction let us consider the euclidean minimum spanning tree problem given n points in the cartesian plane construct a tree of minimum total length whose vertices are the given points. as a problem with a known lower bound we use the element uniqueness problem. we can transform any set x x . . . xn of n real numbers into a set of n points in the cartesian plane by simply adding as the points' y coordinate x x . . . xn . let t be a minimum spanning tree found for this set of points. since t must contain a shortest edge checking whether t contains a zerolength edge will answer the question about uniqueness of the given numbers. this reduction implies that n log n is a lower bound for the euclidean minimum spanning tree problem too. since the final results about the complexity of many problems are not known the reduction technique is often used to compare the relative complexity of problems. for example the formulas x . y x y x y and x x . x show that the problems of computing the product of two n digit integers and squaring an n digit integer belong to the same complexity class despite the latter being seemingly simpler than the former. there are several similar results for matrix operations. for example multiplying two symmetric matrices turns out to be in the same complexity class as multiplying two arbitrary square matrices. this result is based on the observation that not only is the former problem a special case of the latter one but also that we can reduce the problem of multiplying two arbitrary square matrices of order n say a and b to the problem of multiplying two symmetric matrices x a and y bt at b where at and bt are the transpose matrices of a and b i.e. at i j a j i and bt i j b j i respectively and stands for the n n matrix whose elements are all zeros. indeed xy a bt ab at b at bt from which the needed product ab can be easily extracted. true we will have to multiply matrices twice the original size but this is just a minor technical complication with no impact on the complexity classes. though such results are interesting we will encounter even more important applications of the reduction approach to comparing problem complexity in section . . exercises . . prove that any algorithm solving the alternating disk puzzle problem in exercises . must make at least n n moves to solve it. is this lower bound tight? . prove that the classic recursive algorithm for the tower of hanoi puzzle section . makes the minimum number of disk moves needed to solve the problem. . find a trivial lower bound class for each of the following problems and indicate if you can whether this bound is tight. a. finding the largest element in an array b. checking completeness of a graph represented by its adjacency matrix c. generating all the subsets of an n element set d. determining whether n given real numbers are all distinct . consider the problem of identifying a lighter fake coin among n identicallooking coins with the help of a balance scale. can we use the same information theoretic argument as the one in the text for the number of questions in the guessing game to conclude that any algorithm for identifying the fake will need at least log n weighings in the worst case? . prove that any comparison based algorithm for finding the largest element of an n element set of real numbers must make n comparisons in the worst case. . find a tight lower bound for sorting an array by exchanging its adjacent elements. . give an adversary argument proof that the time efficiency of any algorithm that checks connectivity of a graph with n vertices is in n provided the only operation allowed for an algorithm is to inquire about the presence of an edge between two vertices of the graph. is this lower bound tight? . what is the minimum number of comparisons needed for a comparison based sorting algorithm to merge any two sorted lists of sizes n and n elements respectively? prove the validity of your answer. . find the product of matrices a and b through a transformation to a product of two symmetric matrices if a and b . . a. can one use this section's formulas that indicate the complexity equivalence of multiplication and squaring of integers to show the complexity equivalence of multiplication and squaring of square matrices? b. show that multiplication of two matrices of order n can be reduced to squaring a matrix of order n. . find a tight lower bound class for the problem of finding two closest numbers among n real numbers x x . . . xn. . find a tight lower bound class for the number placement problem problem in exercises . . 