we can look at the efficiency of an algorithm two ways. we can establish its asymptotic efficiency class say for the worst case and see where this class stands with respect to the hierarchy of efficiency classes outlined in section . . for example selection sort whose efficiency is quadratic is a reasonably fast algorithm whereas the algorithm for the tower of hanoi problem is very slow because its efficiency is exponential. we can argue however that this comparison is akin to the proverbial comparison of apples to oranges because these two algorithms solve different problems. the alternative and possibly fairer approach is to ask how efficient a particular algorithm is with respect to other algorithms for the same problem. seen in this light selection sort has to be considered slow because there are o n log n sorting algorithms the tower of hanoi algorithm on the other hand turns out to be the fastest possible for the problem it solves. when we want to ascertain the efficiency of an algorithm with respect to other algorithms for the same problem it is desirable to know the best possible efficiency any algorithm solving the problem may have. knowing such a lower bound can tell us how much improvement we can hope to achieve in our quest for a better algorithm for the problem in question. if such a bound is tight i.e. we already know an algorithm in the same efficiency class as the lower bound we can hope for a constant factor improvement at best. if there is a gap between the efficiency of the fastest algorithm and the best lower bound known the door for possible improvement remains open either a faster algorithm matching the lower bound could exist or a better lower bound could be proved. in this section we present several methods for establishing lower bounds and illustrate them with specific examples. as we did in analyzing the efficiency of specific algorithms in the preceding chapters we should distinguish between a lower bound class and a minimum number of times a particular operation needs to be executed. as a rule the second problem is more difficult than the first. for example we can immediately conclude that any algorithm for finding the median of n numbers must be in n why? but it is not simple at all to prove that any comparison based algorithm for this problem must do at least n comparisons in the worst case for odd n . 