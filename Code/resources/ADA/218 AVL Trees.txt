avl trees were invented in by two russian scientists g. m. adelson velsky and e. m. landis ade after whom this data structure is named. a b figure . a avl tree. b binary search tree that is not an avl tree. the numbers above the nodes indicate the nodes' balance factors. definition an avl tree is a binary search tree in which the balance factor of every node which is defined as the difference between the heights of the node's left and right subtrees is either or or . the height of the empty tree is defined as . of course the balance factor can also be computed as the difference between the numbers of levels rather than the height difference of the node's left and right subtrees. for example the binary search tree in figure . a is an avl tree but the one in figure . b is not. if an insertion of a new node makes an avl tree unbalanced we transform the tree by a rotation. a rotation in an avl tree is a local transformation of its subtree rooted at a node whose balance has become either or . if there are several such nodes we rotate the tree rooted at the unbalanced node that is the closest to the newly inserted leaf. there are only four types of rotations in fact two of them are mirror images of the other two. in their simplest form the four rotations are shown in figure . . the first rotation type is called the single right rotation or r rotation. imagine rotating the edge connecting the root and its left child in the binary tree in figure . a to the right. figure . presents the single r rotation in its most general form. note that this rotation is performed after a new key is inserted into the left subtree of the left child of a tree whose root had the balance of before the insertion. the symmetric single left rotation or l rotation is the mirror image of the single r rotation. it is performed after a new key is inserted into the right subtree of the right child of a tree whose root had the balance of before the insertion. you are asked to draw a diagram of the general case of the single l rotation in the exercises. r a l b lr c rl d figure . four rotation types for avl trees with three nodes. a single r rotation. b single l rotation. c double lr rotation. d double rl rotation. the second rotation type is called the double left right rotation lrrotation . it is in fact a combination of two rotations we perform the l rotation of the left subtree of root r followed by the r rotation of the new tree rooted at r figure . . it is performed after a new key is inserted into the right subtree of the left child of a tree whose root had the balance of before the insertion. single r rotation r c c r t t t t t t figure . general form of the r rotation in the avl tree. a shaded node is the last one inserted. double lr rotation r g c c r g t t t t t t t t or or figure . general form of the double lr rotation in the avl tree. a shaded node is the last one inserted. it can be either in the left subtree or in the right subtree of the root's grandchild. the double right left rotation rl rotation is the mirror image of the double lr rotation and is left for the exercises. note that the rotations are not trivial transformations though fortunately they can be done in constant time. not only should they guarantee that a resulting tree is balanced but they should also preserve the basic requirements of a binary search tree. for example in the initial tree of figure . all the keys of subtree t are smaller than c which is smaller than all the keys of subtree t which are smaller than r which is smaller than all the keys of subtree t . and the same relationships among the key values hold as they must for the balanced tree after the rotation. l r lr rl figure . construction of an avl tree for the list by successive insertions. the parenthesized number of a rotation's abbreviation indicates the root of the tree being reorganized. an example of constructing an avl tree for a given list of numbers is shown in figure . . as you trace the algorithm's operations keep in mind that if there are several nodes with the balance the rotation is done for the tree rooted at the unbalanced node that is the closest to the newly inserted leaf. how efficient are avl trees? as with any search tree the critical characteristic is the tree's height. it turns out that it is bounded both above and below by logarithmic functions. specifically the height h of any avl tree with n nodes satisfies the inequalities log n h . log n . . these weird looking constants are round offs of some irrational numbers related to fibonacci numbers and the golden ratio see section . . the inequalities immediately imply that the operations of searching and insertion are log n in the worst case. getting an exact formula for the average height of an avl tree constructed for random lists of keys has proved to be difficult but it is known from extensive experiments that it is about . log n . except when n is small knuiii p. . thus searching in an avl tree requires on average almost the same number of comparisons as searching in a sorted array by binary search. the operation of key deletion in an avl tree is considerably more difficult than insertion but fortunately it turns out to be in the same efficiency class as insertion i.e. logarithmic. these impressive efficiency characteristics come at a price however. the drawbacks of avl trees are frequent rotations and the need to maintain balances for its nodes. these drawbacks have prevented avl trees from becoming the standard structure for implementing dictionaries. at the same time their underlying idea that of rebalancing a binary search tree via rotations has proved to be very fruitful and has led to discoveries of other interesting variations of the classical binary search tree. trees as mentioned at the beginning of this section the second idea of balancing a search tree is to allow more than one key in the same node of such a tree. the simplest implementation of this idea is trees introduced by the u.s. computer scientist john hopcroft in . a tree is a tree that can have nodes of two kinds nodes and nodes. a node contains a single key k and has two children the left child serves as the root of a subtree whose keys are less than k and the right child serves as the root of a subtree whose keys are greater than k. in other words a node is the same kind of node we have in the classical binary search tree. a node contains two ordered keys k and k k k and has three children. the leftmost child serves as the root of a subtree with keys less than k the middle child serves as the root of a subtree with keys between k and k and the rightmost child serves as the root of a subtree with keys greater than k figure . . the last requirement of the tree is that all its leaves must be on the same level. in other words a tree is always perfectly height balanced the length of a path from the root to a leaf is the same for every leaf. it is this property that we buy by allowing more than one key in the same node of a search tree. searching for a given key k in a tree is quite straightforward. we start at the root. if the root is a node we act as if it were a binary search tree we either stop if k is equal to the root's key or continue the search in the left or right node node k k k k k k k k k figure . two kinds of nodes of a tree. subtree if k is respectively smaller or larger than the root's key. if the root is a node we know after no more than two key comparisons whether the search can be stopped if k is equal to one of the root's keys or in which of the root's three subtrees it needs to be continued. inserting a new key in a tree is done as follows. first of all we always insert a new key k in a leaf except for the empty tree. the appropriate leaf is found by performing a search for k. if the leaf in question is a node we insert k there as either the first or the second key depending on whether k is smaller or larger than the node's old key. if the leaf is a node we split the leaf in two the smallest of the three keys two old ones and the new key is put in the first leaf the largest key is put in the second leaf and the middle key is promoted to the old leaf's parent. if the leaf happens to be the tree's root a new root is created to accept the middle key. note that promotion of a middle key to its parent can cause the parent's overflow if it was a node and hence can lead to several node splits along the chain of the leaf's ancestors. an example of a tree construction is given in figure . . as for any search tree the efficiency of the dictionary operations depends on the tree's height. so let us first find an upper bound for it. a tree of height h with the smallest number of keys is a full tree of nodes such as the final tree in figure . for h . therefore for any tree of height h with n nodes we get the inequality n . . . h h and hence h log n . on the other hand a tree of height h with the largest number of keys is a full tree of nodes each with two keys and three children. therefore for any tree with n nodes n . . . . . . h . . . h h figure . construction of a tree for the list . and hence h log n . these lower and upper bounds on height h log n h log n imply that the time efficiencies of searching insertion and deletion are all in log n in both the worst and average case. we consider a very important generalization of trees called b trees in section . . exercises . . which of the following binary trees are avl trees? a b c . a. for n and draw all the binary trees with n nodes that satisfy the balance requirement of avl trees. b. draw a binary tree of height that can be an avl tree and has the smallest number of nodes among all such trees. . draw diagrams of the single l rotation and of the double rl rotation in their general form. . for each of the following lists construct an avl tree by inserting their elements successively starting with the empty tree. a. b. c. . a. for an avl tree containing real numbers design an algorithm for computing the range i.e. the difference between the largest and smallest numbers in the tree and determine its worst case efficiency. b. true or false the smallest and the largest keys in an avl tree can always be found on either the last level or the next to last level? . write a program for constructing an avl tree for a given list of n distinct integers. . a. construct a tree for the list c o m p u t i n g. use the alphabetical order of the letters and insert them successively starting with the empty tree. b. assuming that the probabilities of searching for each of the keys i.e. the letters are the same find the largest number and the average number of key comparisons for successful searches in this tree. . let tb and t be respectively a classical binary search tree and a tree constructed for the same list of keys inserted in the corresponding trees in the same order. true or false searching for the same key in t always takes fewer or the same number of key comparisons as searching in tb? . for a tree containing real numbers design an algorithm for computing the range i.e. the difference between the largest and smallest numbers in the tree and determine its worst case efficiency. . write a program for constructing a tree for a given list of n integers. 