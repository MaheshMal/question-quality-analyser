in the previous section we considered the greedy algorithm that grows a minimum spanning tree through a greedy inclusion of the nearest vertex to the vertices already in the tree. remarkably there is another greedy algorithm for the minimum spanning tree problem that also always yields an optimal solution. it is named kruskal's algorithm after joseph kruskal who discovered this algorithm when he was a second year graduate student kru . kruskal's algorithm looks at a minimum spanning tree of a weighted connected graph g v e as an acyclic subgraph with v edges for which the sum of the edge weights is the smallest. it is not difficult to prove that such a subgraph must be a tree. consequently the algorithm constructs a minimum spanning tree as an expanding sequence of subgraphs that are always acyclic but are not necessarily connected on the intermediate stages of the algorithm. the algorithm begins by sorting the graph's edges in nondecreasing order of their weights. then starting with the empty subgraph it scans this sorted list adding the next edge on the list to the current subgraph if such an inclusion does not create a cycle and simply skipping the edge otherwise. algorithm kruskal g kruskal's algorithm for constructing a minimum spanning tree input a weighted connected graph g v e output et the set of edges composing a minimum spanning tree of g sort e in nondecreasing order of the edge weights w ei . . . w ei e et ecounter initialize the set of tree edges and its size k initialize the number of processed edges while ecounter v do kk if et eik is acyclic et et eik ecounter ecounter return et the correctness of kruskal's algorithm can be proved by repeating the essential steps of the proof of prim's algorithm given in the previous section. the fact that et is actually a tree in prim's algorithm but generally just an acyclic subgraph in kruskal's algorithm turns out to be an obstacle that can be overcome. figure . demonstrates the application of kruskal's algorithm to the same graph we used for illustrating prim's algorithm in section . . as you trace the algorithm's operations note the disconnectedness of some of the intermediate subgraphs. applying prim's and kruskal's algorithms to the same small graph by hand may create the impression that the latter is simpler than the former. this impression is wrong because on each of its iterations kruskal's algorithm has to check whether the addition of the next edge to the edges already selected would create a a f d e tree edges sorted list of edges illustration bc ef ab bf cf af df ae cd de b c a f d e bc bc ef ab bf cf af df ae cd de b c a f d e ef bc ef ab bf cf af df ae cd de b c a f d e ab bc ef ab bf cf af df ae cd de b c a f d e bf bc ef ab bf cf af df ae cd de b c a f d e df figure . application of kruskal's algorithm. selected edges are shown in bold. v v u u a b figure . new edge connecting two vertices may a or may not b create a cycle. cycle. it is not difficult to see that a new cycle is created if and only if the new edge connects two vertices already connected by a path i.e. if and only if the two vertices belong to the same connected component figure . . note also that each connected component of a subgraph generated by kruskal's algorithm is a tree because it has no cycles. in view of these observations it is convenient to use a slightly different interpretation of kruskal's algorithm. we can consider the algorithm's operations as a progression through a series of forests containing all the vertices of a given graph and some of its edges. the initial forest consists of v trivial trees each comprising a single vertex of the graph. the final forest consists of a single tree which is a minimum spanning tree of the graph. on each iteration the algorithm takes the next edge u v from the sorted list of the graph's edges finds the trees containing the vertices u and v and if these trees are not the same unites them in a larger tree by adding the edge u v . fortunately there are efficient algorithms for doing so including the crucial check for whether two vertices belong to the same tree. they are called unionfind algorithms. we discuss them in the following subsection. with an efficient union find algorithm the running time of kruskal's algorithm will be dominated by the time needed for sorting the edge weights of a given graph. hence with an efficient sorting algorithm the time efficiency of kruskal's algorithm will be in o e log e . 