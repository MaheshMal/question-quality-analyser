let's start with the obvious observation that almost all algorithms run longer on larger inputs. for example it takes longer to sort larger arrays multiply larger matrices and so on. therefore it is logical to investigate an algorithm's efficiency as a function of some parameter n indicating the algorithm's input size. in most cases selecting such a parameter is quite straightforward. for example it will be the size of the list for problems of sorting searching finding the list's smallest element and most other problems dealing with lists. for the problem of evaluating a polynomial p x anxn . . . a of degree n it will be the polynomial's degree or the number of its coefficients which is larger by than its degree. you'll see from the discussion that such a minor difference is inconsequential for the efficiency analysis. there are situations of course where the choice of a parameter indicating an input size does matter. one such example is computing the product of two n n matrices. there are two natural measures of size for this problem. the first and more frequently used is the matrix order n. but the other natural contender is the total number of elements n in the matrices being multiplied. the latter is also more general since it is applicable to matrices that are not necessarily square. since there is a simple formula relating these two measures we can easily switch from one to the other but the answer about an algorithm's efficiency will be qualitatively different depending on which of these two measures we use see problem in this section's exercises . the choice of an appropriate size metric can be influenced by operations of the algorithm in question. for example how should we measure an input's size for a spell checking algorithm? if the algorithm examines individual characters of its input we should measure the size by the number of characters if it works by processing words we should count their number in the input. we should make a special note about measuring input size for algorithms solving problems such as checking primality of a positive integer n. here the input is just one number and it is this number's magnitude that determines the input . some algorithms require more than one parameter to indicate the size of their inputs e.g. the number of vertices and the number of edges for algorithms on graphs represented by their adjacency lists . size. in such situations it is preferable to measure size by the number b of bits in the n's binary representation b log n . . this metric usually gives a better idea about the efficiency of algorithms in question. 