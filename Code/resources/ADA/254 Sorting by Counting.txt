as a first example of applying the input enhancement technique we discuss its application to the sorting problem. one rather obvious idea is to count for each element of a list to be sorted the total number of elements smaller than this element and record the results in a table. these numbers will indicate the positions of the elements in the sorted list e.g. if the count is for some element it should be in the th position with index if we start counting with in the sorted array. thus we will be able to sort the list by simply copying its elements to their appropriate positions in a new sorted list. this algorithm is called comparisoncounting sort figure . . array a .. initially count after pass i count after pass i count after pass i count after pass i count after pass i count final state count array s .. figure . example of sorting by comparison counting. algorithm comparisoncountingsort a ..n sorts an array by comparison counting input an array a ..n of orderable elements output array s ..n of a's elements sorted in nondecreasing order for i to n do count i for i to n do for j i to n do if a i a j count j count j else count i count i for i to n do s count i a i return s what is the time efficiency of this algorithm? it should be quadratic because the algorithm considers all the different pairs of an n element array. more formally the number of times its basic operation the comparison a i a j is executed is equal to the sum we have encountered several times already n n n n n n c n n i n i . i j i i i thus the algorithm makes the same number of key comparisons as selection sort and in addition uses a linear amount of extra space. on the positive side the algorithm makes the minimum number of key moves possible placing each of them directly in their final position in a sorted array. the counting idea does work productively in a situation in which elements to be sorted belong to a known small set of values. assume for example that we have to sort a list whose values can be either or . rather than applying a general sorting algorithm we should be able to take advantage of this additional information about values to be sorted. indeed we can scan the list to compute the number of 's and the number of 's in it and then on the second pass simply make the appropriate number of the first elements equal to and the remaining elements equal to . more generally if element values are integers between some lower bound l and upper bound u we can compute the frequency of each of those values and store them in array f ..u l . then the first f positions in the sorted list must be filled with l the next f positions with l and so on. all this can be done of course only if we can overwrite the given elements. let us consider a more realistic situation of sorting a list of items with some other information associated with their keys so that we cannot overwrite the list's elements. then we can copy elements into a new array s ..n to hold the sorted list as follows. the elements of a whose values are equal to the lowest possible value l are copied into the first f elements of s i.e. positions through f the elements of value l are copied to positions from f to f f and so on. since such accumulated sums of frequencies are called a distribution in statistics the method itself is known as distribution counting. example consider sorting the array whose values are known to come from the set and should not be overwritten in the process of sorting. the frequency and distribution arrays are as follows array values frequencies distribution values note that the distribution values indicate the proper positions for the last occurrences of their elements in the final sorted array. if we index array positions from to n the distribution values must be reduced by to get corresponding element positions. it is more convenient to process the input array right to left. for the example the last element is and since its distribution value is we place this in position of the array s that will hold the sorted list. then we decrease the 's distribution value by and proceed to the next from the right element in the given array. the entire processing of this example is depicted in figure . . d .. s .. a a a a a a figure . example of sorting by distribution counting. the distribution values being decremented are shown in bold. here is pseudocode of this algorithm. algorithm distributioncountingsort a ..n l u sorts an array of integers from a limited range by distribution counting input an array a ..n of integers between l and u l u output array s ..n of a's elements sorted in nondecreasing order for j to u l do d j initialize frequencies for i to n do d a i l d a i l compute frequencies for j to u l do d j d j d j reuse for distribution for i n downto do j a i l s d j a i d j d j return s assuming that the range of array values is fixed this is obviously a linear algorithm because it makes just two consecutive passes through its input array a. this is a better time efficiency class than that of the most efficient sorting algorithms mergesort quicksort and heapsort we have encountered. it is important to remember however that this efficiency is obtained by exploiting the specific nature of inputs for which sorting by distribution counting works in addition to trading space for time. exercises . . is it possible to exchange numeric values of two variables say u and v without using any extra storage? . will the comparison counting algorithm work correctly for arrays with equal values? . assuming that the set of possible list values is a b c d sort the following list in alphabetical order by the distribution counting algorithm b c d c b a a b. . is the distribution counting algorithm stable? . design a one line algorithm for sorting any array of size n whose values are n distinct integers from to n. . the ancestry problem asks to determine whether a vertex u is an ancestor of vertex v in a given binary or more generally rooted ordered tree of n vertices. design a o n input enhancement algorithm that provides sufficient information to solve this problem for any pair of the tree's vertices in constant time. . the following technique known as virtual initialization provides a timeefficient way to initialize just some elements of a given array a ..n so that for each of its elements we can say in constant time whether it has been initialized and if it has been with which value. this is done by utilizing a variable counter for the number of initialized elements in a and two auxiliary arrays of the same size say b ..n and c ..n defined as follows. b . . . b counter contain the indices of the elements of a that were initialized b contains the index of the element initialized first b contains the index of the element initialized second etc. furthermore if a i was the kth element k counter to be initialized c i contains k. a. sketch the state of arrays a .. b .. and c .. after the three assignments a x a z a y. b. in general how can we check with this scheme whether a i has been initialized and if it has been with which value? . least distance sorting there are egyptian stone statues standing in a row in an art gallery hall. a new curator wants to move them so that the statues are ordered by their height. how should this be done to minimize the total distance that the statues are moved? you may assume for simplicity that all the statues have different heights. azi . a. write a program for multiplying two sparse matrices a p q matrix a and a q r matrix b. b. write a program for multiplying two sparse polynomials p x and q x of degrees m and n respectively. . is it a good idea to write a program that plays the classic game of tic tac toe with the human user by storing all possible positions on the game's board along with the best move for each of them? 