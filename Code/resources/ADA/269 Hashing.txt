in this section we consider a very efficient way to implement dictionaries. recall that a dictionary is an abstract data type namely a set with the operations of searching lookup insertion and deletion defined on its elements. the elements of this set can be of an arbitrary nature numbers characters of some alphabet character strings and so on. in practice the most important case is that of records student records in a school citizen records in a governmental office book records in a library . typically records comprise several fields each responsible for keeping a particular type of information about an entity the record represents. for example a student record may contain fields for the student's id name date of birth sex home address major and so on. among record fields there is usually at least one called a key that is used for identifying entities represented by the records e.g. the student's id . in the discussion below we assume that we have to implement a dictionary of n records with keys k k . . . kn. hashing is based on the idea of distributing keys among a one dimensional array h ..m called a hash table. the distribution is done by computing for each of the keys the value of some predefined function h called the hash function. this function assigns an integer between and m called the hash address to a key. for example if keys are nonnegative integers a hash function can be of the form h k k mod m obviously the remainder of division by m is always between and m . if keys are letters of some alphabet we can first assign a letter its position in the alphabet denoted here ord k and then apply the same kind of a function used for integers. finally if k is a character string c c . . . cs we s can use as a very unsophisticated option or d ci mod m. a better option i is to compute h k as follows h for i to s do h h c ord ci mod m where c is a constant larger than every ord ci . in general a hash function needs to satisfy somewhat conflicting requirements a hash table's size should not be excessively large compared to the number of keys but it should be sufficient to not jeopardize the implementation's time efficiency see below . a hash function needs to distribute keys among the cells of the hash table as evenly as possible. this requirement makes it desirable for most applications to have a hash function dependent on all bits of a key not just some of them. a hash function has to be easy to compute. . this can be obtained by treating ord ci as digits of a number in the c based system computing its decimal value by horner's rule and finding the remainder of the number after dividing it by m. ki kj . . . . . . b m figure . collision of two keys in hashing h ki h kj . obviously if we choose a hash table's size m to be smaller than the number of keys n we will get collisions a phenomenon of two or more keys being hashed into the same cell of the hash table figure . . but collisions should be expected even if m is considerably larger than n see problem in this section's exercises . in fact in the worst case all the keys could be hashed to the same cell of the hash table. fortunately with an appropriately chosen hash table size and a good hash function this situation happens very rarely. still every hashing scheme must have a collision resolution mechanism. this mechanism is different in the two principal versions of hashing open hashing also called separate chaining and closed hashing also called open addressing . 