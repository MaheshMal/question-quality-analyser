presorting is an old idea in computer science. in fact interest in sorting algorithms is due to a significant degree to the fact that many questions about a list are easier to answer if the list is sorted. obviously the time efficiency of algorithms that involve sorting may depend on the efficiency of the sorting algorithm being used. for the sake of simplicity we assume throughout this section that lists are implemented as arrays because some sorting algorithms are easier to implement for the array representation. so far we have discussed three elementary sorting algorithms selection sort bubble sort and insertion sort that are quadratic in the worst and average cases and two advanced algorithms mergesort which is always in n log n and quicksort whose efficiency is also n log n in the average case but is quadratic in the worst case. are there faster sorting algorithms? as we have already stated in section . see also section . no general comparison based sorting algorithm can have a better efficiency than n log n in the worst case and the same result holds for the average case efficiency. following are three examples that illustrate the idea of presorting. more examples can be found in this section's exercises. example checking element uniqueness in an array if this element uniqueness problem looks familiar to you it should we considered a brute force algorithm for the problem in section . see example . the brute force algorithm compared pairs of the array's elements until either two equal elements were found or no more pairs were left. its worst case efficiency was in n . alternatively we can sort the array first and then check only its consecutive elements if the array has equal elements a pair of them must be next to each other and vice versa. algorithm presortelementuniqueness a ..n solves the element uniqueness problem by sorting the array first input an array a ..n of orderable elements output returns true if a has no equal elements false otherwise sort the array a for i to n do if a i a i return false return true the running time of this algorithm is the sum of the time spent on sorting and the time spent on checking consecutive elements. since the former requires at least n log n comparisons and the latter needs no more than n comparisons it is the sorting part that will determine the overall efficiency of the algorithm. so if we use a quadratic sorting algorithm here the entire algorithm will not be more efficient than the brute force one. but if we use a good sorting algorithm such as mergesort with worst case efficiency in n log n the worst case efficiency of the entire presorting based algorithm will be also in n log n t n tsort n tscan n n log n n n log n . example computing a mode a mode is a value that occurs most often in a given list of numbers. for example for the mode is . if several different values occur most often any of them can be considered a mode. the brute force approach to computing a mode would scan the list and compute the frequencies of all its distinct values then find the value with the largest frequency. . sorting algorithms called radix sorts are linear but in terms of the total number of input bits. these algorithms work by comparing individual bits or pieces of keys rather than keys in their entirety. although the running time of these algorithms is proportional to the number of input bits they are still essentially n log n algorithms because the number of bits per key must be at least log n in order to accommodate n distinct keys of input. in order to implement this idea we can store the values already encountered along with their frequencies in a separate list. on each iteration the ith element of the original list is compared with the values already encountered by traversing this auxiliary list. if a matching value is found its frequency is incremented otherwise the current element is added to the list of distinct values seen so far with a frequency of . it is not difficult to see that the worst case input for this algorithm is a list with no equal elements. for such a list its ith element is compared with i elements of the auxiliary list of distinct values seen so far before being added to the list with a frequency of . as a result the worst case number of comparisons made by this algorithm in creating the frequency list is n i . . . n n n c n n . i the additional n comparisons needed to find the largest frequency in the auxiliary list do not change the quadratic worst case efficiency class of the algorithm. as an alternative let us first sort the input. then all equal values will be adjacent to each other. to compute the mode all we need to do is to find the longest run of adjacent equal values in the sorted array. algorithm presortmode a ..n computes the mode of an array by sorting it first input an array a ..n of orderable elements output the array's mode sort the array a i current run begins at position i modef requency highest frequency seen so far while i n do runlength runvalue a i while i runlength n and a i runlength runvalue runlength runlength if runlength modef requency modef requency runlength modevalue runvalue i i runlength return modevalue the analysis here is similar to the analysis of example the running time of the algorithm will be dominated by the time spent on sorting since the remainder of the algorithm takes linear time why? . consequently with an n log n sort this method's worst case efficiency will be in a better asymptotic class than the worstcase efficiency of the brute force algorithm. example searching problem consider the problem of searching for a given value v in a given array of n sortable items. the brute force solution here is sequential search section . which needs n comparisons in the worst case. if the array is sorted first we can then apply binary search which requires only log n comparisons in the worst case. assuming the most efficient n log n sort the total running time of such a searching algorithm in the worst case will be t n tsort n tsearch n n log n log n n log n which is inferior to sequential search. the same will also be true for the averagecase efficiency. of course if we are to search in the same list more than once the time spent on sorting might well be justified. problem in this section's exercises asks to estimate the minimum number of searches needed to justify presorting. before we finish our discussion of presorting we should mention that many if not most geometric algorithms dealing with sets of points use presorting in one way or another. points can be sorted by one of their coordinates or by their distance from a particular line or by some angle and so on. for example presorting was used in the divide and conquer algorithms for the closest pair problem and for the convex hull problem which were discussed in section . . further some problems for directed acyclic graphs can be solved more easily after topologically sorting the digraph in question. the problems of finding the longest and shortest paths in such digraphs see the exercises for sections . and . illustrate this point. finally most algorithms based on the greedy technique which is the subject of chapter require presorting of their inputs as an intrinsic part of their operations. exercises . . consider the problem of finding the distance between the two closest numbers in an array of n numbers. the distance between two numbers x and y is computed as x y . a. design a presorting based algorithm for solving this problem and determine its efficiency class. b. compare the efficiency of this algorithm with that of the brute force algorithm see problem in exercises . . . let a a . . . an and b b . . . bm be two sets of numbers. consider the problem of finding their intersection i.e. the set c of all the numbers that are in both a and b. a. design a brute force algorithm for solving this problem and determine its efficiency class. b. design a presorting based algorithm for solving this problem and determine its efficiency class. . consider the problem of finding the smallest and largest elements in an array of n numbers. a. design a presorting based algorithm for solving this problem and determine its efficiency class. b. compare the efficiency of the three algorithms i the brute force algorithm ii this presorting based algorithm and iii the divide and conquer algorithm see problem in exercises . . . estimate how many searches will be needed to justify time spent on presorting an array of elements if sorting is done by mergesort and searching is done by binary search. you may assume that all searches are for elements known to be in the array. what about an array of elements? . to sort or not to sort? design a reasonably efficient algorithm for solving each of the following problems and determine its efficiency class. a. you are given n telephone bills and m checks sent to pay the bills n m . assuming that telephone numbers are written on the checks find out who failed to pay. for simplicity you may also assume that only one check is written for a particular bill and that it covers the bill in full. b. you have a file of n student records indicating each student's number name home address and date of birth. find out the number of students from each of the u.s. states. . given a set of n points in the cartesian plane connect them in a simple polygon i.e. a closed path through all the points so that its line segments the polygon's edges do not intersect except for neighboring edges at their common vertex . for example p p p p p p p p p p p p a. does the problem always have a solution? does it always have a unique solution? b. design a reasonably efficient algorithm for solving this problem and indicate its efficiency class. . you have an array of n real numbers and another integer s. find out whether the array contains two elements whose sum is s. for example for the array and s the answer is yes but for the same array and s the answer is no. design an algorithm for this problem with a better than quadratic time efficiency. . you have a list of n open intervals a b a b . . . an bn on the real line. an open interval a b comprises all the points strictly between its endpoints a and b i.e. a b x a x b . find the maximum number of these intervals that have a common point. for example for the intervals . . this maximum number is . design an algorithm for this problem with a better than quadratic time efficiency. . number placement given a list of n distinct integers and a sequence of n boxes with pre set inequality signs inserted between them design an algorithm that places the numbers into the boxes to satisfy those inequalities. for example the numbers can be placed in the five boxes as shown below . maxima search a. a point xi yi in the cartesian plane is said to be dominated by point xj yj if xi xj and yi yj with at least one of the two inequalities being strict. given a set of n points one of them is said to be a maximum of the set if it is not dominated by any other point in the set. for example in the figure below all the maximum points of the set of points are circled. y x design an efficient algorithm for finding all the maximum points of a given set of n points in the cartesian plane. what is the time efficiency class of your algorithm? b. give a few real world applications of this algorithm. . anagram detection a. design an efficient algorithm for finding all sets of anagrams in a large file such as a dictionary of english words ben . for example eat ate and tea belong to one such set. b. write a program implementing the algorithm. 