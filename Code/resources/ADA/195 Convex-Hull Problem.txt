let us revisit the convex hull problem introduced in section . find the smallest convex polygon that contains n given points in the plane. we consider here a divide and conquer algorithm called quickhull because of its resemblance to quicksort. let s be a set of n points p x y . . . pn xn yn in the cartesian plane. we assume that the points are sorted in nondecreasing order of their x coordinates with ties resolved by increasing order of the y coordinates of the points involved. it is not difficult to prove the geometrically obvious fact that the leftmost point p and the rightmost point pn are two distinct extreme points of the set's convex hull figure . . let p pn be the straight line through points p and pn directed from p to pn. this line separates the points of s into two sets s is the set of points to the left of this line and s is the set of points to the right of this line. we say that point q is to the left of the line q q directed from point q to point q if q q q forms a counterclockwise cycle. later we cite an analytical way to check this condition based on checking the sign of a determinant formed by the coordinates of the three points. the points of s on the line p pn other than p and pn cannot be extreme points of the convex hull and hence are excluded from further consideration. the boundary of the convex hull of s is made up of two polygonal chains an upper boundary and a lower boundary. the upper boundary called the upper hull is a sequence of line segments with vertices at p some of the points in s if s is not empty and pn. the lower boundary called the lower hull is a sequence of line segments with vertices at p some of the points in s if s is not empty and pn. the fact that the convex hull of the entire set s is composed of the upper and lower hulls which can be constructed independently and in a similar fashion is a very useful observation exploited by several algorithms for this problem. for concreteness let us discuss how quickhull proceeds to construct the upper hull the lower hull can be constructed in the same manner. if s is empty the pn p figure . upper and lower hulls of a set of points. pmax pn p figure . the idea of quickhull. upper hull is simply the line segment with the endpoints at p and pn. if s is not empty the algorithm identifies point pmax in s which is the farthest from the line p pn figure . . if there is a tie the point that maximizes the angle pmaxppn can be selected. note that point pmax maximizes the area of the triangle with two vertices at p and pn and the third one at some other point of s . then the algorithm identifies all the points of set s that are to the left of the line p pmax these are the points that will make up the set s . the points of s to the left of the line p m a x pn will make up the set s . it is not difficult to prove the following pmax is a vertex of the upper hull. the points inside p pmaxpn cannot be vertices of the upper hull and hence can be eliminated from further consideration . there are no points to the left of both lines p pmax and p m a x pn. therefore the algorithm can continue constructing the upper hulls of p s pmax and pmax s pn recursively and then simply concatenate them to get the upper hull of the entire set p s pn. now we have to figure out how the algorithm's geometric operations can be actually implemented. fortunately we can take advantage of the following very useful fact from analytical geometry if q x y q x y and q x y are three arbitrary points in the cartesian plane then the area of the triangle q q q is equal to one half of the magnitude of the determinant x y x y x y x y x y x y x y x y x y while the sign of this expression is positive if and only if the point q x y is to the left of the line q q. using this formula we can check in constant time whether a point lies to the left of the line determined by two other points as well as find the distance from the point to the line. quickhull has the same n worst case efficiency as quicksort problem in this section's exercises . in the average case however we should expect a much better performance. first the algorithm should benefit from the quicksortlike savings from the on average balanced split of the problem into two smaller subproblems. second a significant fraction of the points namely those inside p pmaxpn see figure . are eliminated from further processing. under a natural assumption that points given are chosen randomly from a uniform distribution over some convex region e.g. a circle or a rectangle the average case efficiency of quickhull turns out to be linear ove . exercises . . a. for the one dimensional version of the closest pair problem i.e. for the problem of finding two closest numbers among a given set of n real numbers design an algorithm that is directly based on the divide and conquer technique and determine its efficiency class. b. is it a good algorithm for this problem? . prove that the divide and conquer algorithm for the closest pair problem examines for every point p in the vertical strip see figures . a and . b no more than seven other points that can be closer to p than dmin the minimum distance between two points encountered by the algorithm up to that point. . consider the version of the divide and conquer two dimensional closest pair algorithm in which instead of presorting input set p we simply sort each of the two sets pl and pr in nondecreasing order of their y coordinates on each recursive call. assuming that sorting is done by mergesort set up a recurrence relation for the running time in the worst case and solve it for n k. . implement the divide and conquer closest pair algorithm outlined in this section in the language of your choice. . find on the web a visualization of an algorithm for the closest pair problem. what algorithm does this visualization represent? . the voronoi polygon for a point p of a set s of points in the plane is defined to be the perimeter of the set of all points in the plane closer to p than to any other point in s. the union of all the voronoi polygons of the points in s is called the voronoi diagram of s. a. what is the voronoi diagram for a set of three points? b. find a visualization of an algorithm for generating the voronoi diagram on the web and study a few examples of such diagrams. based on your observations can you tell how the solution to the previous question is generalized to the general case? . explain how one can find point pmax in the quickhull algorithm analytically. . what is the best case efficiency of quickhull? . give a specific example of inputs that make quickhull run in quadratic time. . implement quickhull in the language of your choice. . creating decagons there are points in the plane no three of them on the same line. devise an algorithm to construct decagons with their vertices at these points. the decagons need not be convex but each of them has to be simple i.e. its boundary should not cross itself and no two decagons may have a common point. . shortest path around there is a fenced area in the two dimensional euclidean plane in the shape of a convex polygon with vertices at points p x y p x y . . . pn xn yn not necessarily in this order . there are two more points a xa ya and b xb yb such that xa min x x . . . xn and xb max x x . . . xn . design a reasonably efficient algorithm for computing the length of the shortest path between a and b. oro summary divide and conquer is a general algorithm design technique that solves a problem by dividing it into several smaller subproblems of the same type ideally of about equal size solving each of them recursively and then combining their solutions to get a solution to the original problem. many efficient algorithms are based on this technique although it can be both inapplicable and inferior to simpler algorithmic solutions. running time t n of many divide and conquer algorithms satisfies the recurrence t n at n b f n . the master theorem establishes the order of growth of its solutions. mergesort is a divide and conquer sorting algorithm. it works by dividing an input array into two halves sorting them recursively and then merging the two sorted halves to get the original array sorted. the algorithm's time efficiency is in n log n in all cases with the number of key comparisons being very close to the theoretical minimum. its principal drawback is a significant extra storage requirement. quicksort is a divide and conquer sorting algorithm that works by partitioning its input elements according to their value relative to some preselected element. quicksort is noted for its superior efficiency among n log n algorithms for sorting randomly ordered arrays but also for the quadratic worst case efficiency. the classic traversals of a binary tree preorder inorder and postorder and similar algorithms that require recursive processing of both left and right subtrees can be considered examples of the divide and conquer technique. their analysis is helped by replacing all the empty subtrees of a given tree by special external nodes. there is a divide and conquer algorithm for multiplying two n digit integers that requires about n . one digit multiplications. strassen's algorithm needs only seven multiplications to multiply two matrices. by exploiting the divide and conquer technique this algorithm can multiply two n n matrices with about n . multiplications. the divide and conquer technique can be successfully applied to two important problems of computational geometry the closest pair problem and the convex hull problem. 