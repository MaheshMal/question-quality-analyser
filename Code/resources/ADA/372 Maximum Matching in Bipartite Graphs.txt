in many situations we are faced with a problem of pairing elements of two sets. the traditional example is boys and girls for a dance but you can easily think of more serious applications. it is convenient to represent elements of two given sets by vertices of a graph with edges between vertices that can be paired. a matching in a graph is a subset of its edges with the property that no two edges share a vertex. a maximum matching more precisely a maximum cardinality matching is a matching with the largest number of edges. what is it for the graph in figure . ? is it unique? the maximum matching problem is the problem of finding a maximum matching in a given graph. for an arbitrary graph this is a rather difficult problem. it was solved in by jack edmonds edm . see gal for a good survey and more recent references. we limit our discussion in this section to the simpler case of bipartite graphs. in a bipartite graph all the vertices can be partitioned into two disjoint sets v and u not necessarily of the same size so that every edge connects a vertex in one of these sets to a vertex in the other set. in other words a graph is bipartite if its vertices can be colored in two colors so that every edge has its vertices colored in different colors such graphs are also said to be colorable. the graph in figure . is bipartite. it is not difficult to prove that a graph is bipartite if and only if it does not have a cycle of an odd length. we will assume for the rest of this section that v u figure . example of a bipartite graph. the vertex set of a given bipartite graph has been already partitioned into sets v and u as required by the definition see problem in exercises . . let us apply the iterative improvement technique to the maximumcardinality matching problem. let m be a matching in a bipartite graph g v u e . how can we improve it i.e. find a new matching with more edges? obviously if every vertex in either v or u is matched has a mate i.e. serves as an endpoint of an edge in m this cannot be done and m is a maximum matching. therefore to have a chance at improving the current matching both v and u must contain unmatched also called free vertices i.e. vertices that are not incident to any edge in m. for example for the matching ma in the graph in figure . a vertices and are free and vertices and are matched. another obvious observation is that we can immediately increase a current matching by adding an edge between two free vertices. for example adding to the matching ma in the graph in figure . a yields a larger matching mb figure . b . let us now try to find a matching larger than mb by matching vertex . the only way to do this would be to include the edge in a new matching. this inclusion requires removal of which can be compensated by inclusion of in the new matching. this new matching mc is shown in figure . c. in general we increase the size of a current matching m by constructing a simple path from a free vertex in v to a free vertex in u whose edges are alternately in e m and in m. that is the first edge of the path does not belong to m the second one does and so on until the last edge that does not belong to m. such a path is called augmenting with respect to the matching m. for example the path is an augmenting path with respect to the matching mb in figure . b. since the length of an augmenting path is always odd adding to the matching m the path's edges in the odd numbered positions and deleting from it the path's edges in the even numbered positions yields a matching with one more edge than in m. such a matching adjustment is called augmentation. thus in figure . the matching mb was obtained by augmentation of the matching ma along the augmenting path and the matching mc was obtained by augmentation of the matching mb along the augmenting path . moving further is an augmenting path for the matching mc figure . c . after adding to mc the edges and and deleting and we obtain the matching md shown in figure . d. the v u a augmenting path b augmenting path c augmenting path d maximum matching figure . augmenting paths and matching augmentations. matching md is not only a maximum matching but also perfect i.e. a matching that matches all the vertices of the graph. before we discuss an algorithm for finding an augmenting path let us settle the issue of what nonexistence of such a path means. according to the theorem discovered by the french mathematician claude berge it means the current matching is maximal. theorem a matching m is a maximum matching if and only if there exists no augmenting path with respect to m. proof if an augmenting path with respect to a matching m exists then the size of the matching can be increased by augmentation. let us prove the more difficult part if no augmenting path with respect to a matching m exists then the matching is a maximum matching. assume that on the contrary this is not the case for a certain matching m in a graph g. let m be a maximum matching in g by our assumption the number of edges in m is at least one more than the number of edges in m i.e. m m . consider the edges in the symmetric difference m m m m m m the set of all the edges that are either in m or in m but not in both. note that m m m m because m m by assumption. let g be the subgraph of g made up of all the edges in m m and their endpoints. by definition of a matching any vertex in g g can be incident to no more than one edge in m and no more than one edge in m. hence each of the vertices in g has degree or less and therefore every connected component of g is either a path or an even length cycle of alternating edges from m m and m m. since m m m m and the number of edges from m m and m m is the same for any even length cycle of alternating edges in g there must exist at least one path of alternating edges that starts and ends with an edge from m m. hence this is an augmenting path for the matching m which contradicts the assumption that no such path exists. our discussion of augmenting paths leads to the following general method for constructing a maximum matching in a bipartite graph. start with some initial matching e.g. the empty set . find an augmenting path and augment the current matching along this path. when no augmenting path can be found terminate the algorithm and return the last matching which is maximum. we now give a specific algorithm implementing this general template. we will search for an augmenting path for a matching m by a bfs like traversal of the graph that starts simultaneously at all the free vertices in one of the sets v and u say v . it would be logical to select the smaller of the two vertex sets but we will ignore this observation in the pseudocode below. recall that an augmenting path if it exists is an odd length path that connects a free vertex in v with a free vertex in u and which unless it consists of a single edge zigs from a vertex in v to another vertex' mate in u then zags back to v along the uniquely defined edge from m and so on until a free vertex in u is reached. draw augmenting paths for the matchings in figure . for example. hence any candidate to be such a path must have its edges alternate in the pattern just described. this motivates the following rules for labeling vertices during the bfs like traversal of the graph. case the queue's front vertex w is in v if u is a free vertex adjacent to w it is used as the other endpoint of an augmenting path so the labeling stops and augmentation of the matching commences. the augmenting path in question is obtained by moving backward along the vertex labels see below to alternately add and delete its edges to and from the current matching. if u is not free and connected to w by an edge not in m label u with w unless it has been already labeled. case the front vertex w is in u in this case w must be matched and we label its mate in v with w. here is pseudocode of the algorithm in its entirety. algorithm maximumbipartitematching g finds a maximum matching in a bipartite graph by a bfs like traversal input a bipartite graph g v u e output a maximum cardinality matching m in the input graph initialize set m of edges with some valid matching e.g. the empty set initialize queue q with all the free vertices in v in any order while not empty q do w front q dequeue q if w v for every vertex u adjacent to w do if u is free augment m m w u vw while v is labeled do u vertex indicated by v's label m m v u v vertex indicated by u's label m m v u remove all vertex labels reinitialize q with all free vertices in v break exit the for loop else u is matched if w u m and u is unlabeled label u with w enqueue q u else w u and matched label the mate v of w with w enqueue q v return m current matching is maximum an application of this algorithm to the matching in figure . a is shown in figure . . note that the algorithm finds a maximum matching that differs from the one in figure . d. v u queue queue augment from queue queue augment from queue queue augment from queue empty maximum matching figure . application of the maximum cardinality matching algorithm. the left column shows a current matching and initialized queue at the next iteration's start the right column shows the vertex labeling generated by the algorithm before augmentation is performed. matching edges are shown in bold. vertex labels indicate the vertices from which the labeling is done. the discovered endpoint of an augmenting path is shaded and labeled for clarity. vertices deleted from the queue are indicated by . how efficient is the maximum matching algorithm? each iteration except the last one matches two previously free vertices one from each of the sets v and u. therefore the total number of iterations cannot exceed n where n v u is the number of vertices in the graph. the time spent on each iteration is in o n m where m e is the number of edges in the graph. this assumes that the information about the status of each vertex free or matched and the vertex' mate if the latter can be retrieved in constant time e.g. by storing it in an array. hence the time efficiency of the algorithm is in o n n m . hopcroft and karp hop showed how the efficiency can be improved to o n n m by combining several iterations into a single stage to maximize the number of edges added to the matching with one search. we were concerned in this section with matching the largest possible number of vertex pairs in a bipartite graph. some applications may require taking into account the quality or cost of matching different pairs. for example workers may execute jobs with different efficiencies or girls may have different preferences for their potential dance partners. it is natural to model such situations by bipartite graphs with weights assigned to their edges. this leads to the problem of maximizing the sum of the weights on edges connecting matched pairs of vertices. this problem is called maximum weight matching. we encountered it under a different name the assignment problem in section . . there are several sophisticated algorithms for this problem which are much more efficient than exhaustive search see e.g. pap gal ahu . we have to leave them outside of our discussion however because of their complexity especially for general graphs. exercises . . for each matching shown below in bold find an augmentation or explain why no augmentation exists. a. b. . apply the maximum matching algorithm to the following bipartite graph . a. what is the largest and what is the smallest possible cardinality of a matching in a bipartite graph g v u e with n vertices in each vertex set v and u and at least n edges? b. what is the largest and what is the smallest number of distinct solutions the maximum cardinality matching problem can have for a bipartite graph g v u e with n vertices in each vertex set v and u and at least n edges? . a. hall's marriage theorem asserts that a bipartite graph g v u e has a matching that matches all vertices of the set v if and only if for each subset s v r s s where r s is the set of all vertices adjacent to a vertex in s. check this property for the following graph with i v and ii v . b. you have to devise an algorithm that returns yes if there is a matching in a bipartite graph g v u e that matches all vertices in v and returns no otherwise. would you base your algorithm on checking the condition of hall's marriage theorem? . suppose there are five committees a b c d and e composed of six persons a b c d e and f as follows committee a's members are b and e committee b's members are b d and e committee c's members are a c d e and f committee d's members are b d and e committee e's members are b and e. is there a system of distinct representatives i.e. is it possible to select a representative from each committee so that all the selected persons are distinct? . show how the maximum cardinality matching problem for a bipartite graph can be reduced to the maximum flow problem discussed in section . . . consider the following greedy algorithm for finding a maximum matching in a bipartite graph g v u e . sort all the vertices in nondecreasing order of their degrees. scan this sorted list to add to the current matching initially empty the edge from the list's free vertex to an adjacent free vertex of the lowest degree. if the list's vertex is matched or if there are no adjacent free vertices for it the vertex is simply skipped. does this algorithm always produce a maximum matching in a bipartite graph? . design a linear time algorithm for finding a maximum matching in a tree. . implement the maximum matching algorithm of this section in the language of your choice. experiment with its performance on bipartite graphs with n vertices in each of the vertex sets and randomly generated edges in both dense and sparse modes to compare the observed running time with the algorithm's theoretical efficiency. . domino puzzle a domino is a tile that can be oriented either horizontally or vertically. a tiling of a given board composed of squares is covering it with dominoes exactly and without overlap. is it possible to tile with dominoes an board without two unit squares at its diagonally opposite corners? 