the following problem arises naturally in many practical situations given n points connect them in the cheapest possible way so that there will be a path between every pair of points. it has direct applications to the design of all kinds of networks including communication computer transportation and electrical by providing the cheapest way to achieve connectivity. it identifies clusters of points in data sets. it has been used for classification purposes in archeology biology sociology and other sciences. it is also helpful for constructing approximate solutions to more difficult problems such the traveling salesman problem see section . . we can represent the points given by vertices of a graph possible connections by the graph's edges and the connection costs by the edge weights. then the question can be posed as the minimum spanning tree problem defined formally as follows. definition a spanning tree of an undirected connected graph is its connected acyclic subgraph i.e. a tree that contains all the vertices of the graph. if such a graph has weights assigned to its edges a minimum spanning tree is its spanning tree of the smallest weight where the weight of a tree is defined as the sum of the weights on all its edges. the minimum spanning tree problem is the problem of finding a minimum spanning tree for a given weighted connected graph. figure . presents a simple example illustrating these notions. if we were to try constructing a minimum spanning tree by exhaustive search we would face two serious obstacles. first the number of spanning trees grows exponentially with the graph size at least for dense graphs . second generating all spanning trees for a given graph is not easy in fact it is more difficult than finding a minimum spanning tree for a weighted graph by using one of several efficient algorithms available for this problem. in this section we outline prim's algorithm which goes back to at least pri . . robert prim rediscovered the algorithm published years earlier by the czech mathematician vojte ch jarni k in a czech journal. prim's algorithm constructs a minimum spanning tree through a sequence of expanding subtrees. the initial subtree in such a sequence consists of a single vertex selected arbitrarily from the set v of the graph's vertices. on each iteration the algorithm expands the current tree in the greedy manner by simply attaching to it the nearest vertex not in that tree. by the nearest vertex we mean a vertex not in the tree connected to a vertex in the tree by an edge of the smallest weight. ties can be broken arbitrarily. the algorithm stops after all the graph's vertices have been included in the tree being constructed. since the algorithm expands a tree by exactly one vertex on each of its iterations the total number of such iterations is n where n is the number of vertices in the graph. the tree generated by the algorithm is obtained as the set of edges used for the tree expansions. here is pseudocode of this algorithm. algorithm prim g prim's algorithm for constructing a minimum spanning tree input a weighted connected graph g v e output et the set of edges composing a minimum spanning tree of g vt v the set of tree vertices can be initialized with any vertex et for i to v do find a minimum weight edge e v u among all the edges v u such that v is in vt and u is in v vt vt vt u et et e return et the nature of prim's algorithm makes it necessary to provide each vertex not in the current tree with the information about the shortest edge connecting the vertex to a tree vertex. we can provide such information by attaching two labels to a vertex the name of the nearest tree vertex and the length the weight of the corresponding edge. vertices that are not adjacent to any of the tree vertices can be given the label indicating their infinite distance to the tree vertices and a null label for the name of the nearest tree vertex. alternatively we can split the vertices that are not in the tree into two sets the fringe and the unseen. the fringe contains only the vertices that are not in the tree but are adjacent to at least one tree vertex. these are the candidates from which the next tree vertex is selected. the unseen vertices are all the other vertices of the graph called unseen because they are yet to be affected by the algorithm. with such labels finding the next vertex to be added to the current tree t vt et becomes a simple task of finding a vertex with the smallest distance label in the set v vt . ties can be broken arbitrarily. after we have identified a vertex u to be added to the tree we need to perform two operations move u from the set v vt to the set of tree vertices vt . for each remaining vertex u in v vt that is connected to u by a shorter edge than the u's current distance label update its labels by u and the weight of the edge between u and u respectively. figure . demonstrates the application of prim's algorithm to a specific graph. does prim's algorithm always yield a minimum spanning tree? the answer to this question is yes. let us prove by induction that each of the subtrees ti i . . . n generated by prim's algorithm is a part i.e. a subgraph of some minimum spanning tree. this immediately implies of course that the last tree in the sequence tn is a minimum spanning tree itself because it contains all n vertices of the graph. the basis of the induction is trivial since t consists of a single vertex and hence must be a part of any minimum spanning tree. for the inductive step let us assume that ti is part of some minimum spanning tree t . we need to prove that ti generated from ti by prim's algorithm is also a part of a minimum spanning tree. we prove this by contradiction by assuming that no minimum spanning tree of the graph can contain ti. let ei v u be the minimum weight edge from a vertex in ti to a vertex not in ti used by prim's algorithm to expand ti to ti. by our assumption ei cannot belong to any minimum spanning tree including t . therefore if we add ei to t a cycle must be formed figure . . in addition to edge ei v u this cycle must contain another edge v u connecting a vertex v ti to a vertex u that is not in ti . it is possible that v coincides with v or u coincides with u but not both. if we now delete the edge v u from this cycle we will obtain another spanning tree of the entire graph whose weight is less than or equal to the weight of t since the weight of ei is less than or equal to the weight of v u . hence this spanning tree is a minimum spanning tree which contradicts the assumption that no minimum spanning tree contains ti. this completes the correctness proof of prim's algorithm. how efficient is prim's algorithm? the answer depends on the data structures chosen for the graph itself and for the priority queue of the set v vt whose vertex priorities are the distances to the nearest tree vertices. you may want to take another look at the example in figure . to see that the set v vt indeed operates as a priority queue. in particular if a graph is represented by its weight matrix and the priority queue is implemented as an unordered array the algorithm's running time will be in v . indeed on each of the v iterations the array implementing the priority queue is traversed to find and delete the minimum and then to update if necessary the priorities of the remaining vertices. we can also implement the priority queue as a min heap. a min heap is a mirror image of the heap structure discussed in section . . in fact it can be implemented by constructing a heap after negating all the key values given. namely a min heap is a complete binary tree in which every element is less than or equal . if the implementation with the fringe unseen split is pursued all the unseen vertices adjacent to u must also be moved to the fringe. a f d e tree vertices remaining vertices illustration a b a c d b c e a f a a f d e b a c b d e a b c f b a f d e c b d c e a f b b c a f d e f b d f e f b c a f d e e f d f b c a f d e d f figure . application of prim's algorithm. the parenthesized labels of a vertex in the middle column indicate the nearest tree vertex and edge weight selected vertices and edges are shown in bold. v u v ei u ti figure . correctness proof of prim's algorithm. to its children. all the principal properties of heaps remain valid for min heaps with some obvious modifications. for example the root of a min heap contains the smallest rather than the largest element. deletion of the smallest element from and insertion of a new element into a min heap of size n are o log n operations and so is the operation of changing an element's priority see problem in this section's exercises . if a graph is represented by its adjacency lists and the priority queue is implemented as a min heap the running time of the algorithm is in o e log v . this is because the algorithm performs v deletions of the smallest element and makes e verifications and possibly changes of an element's priority in a min heap of size not exceeding v . each of these operations as noted earlier is a o log v operation. hence the running time of this implementation of prim's algorithm is in v e o log v o e log v because in a connected graph v e . in the next section you will find another greedy algorithm for the minimum spanning tree problem which is greedy in a manner different from that of prim's algorithm. exercises . . write pseudocode of the greedy algorithm for the change making problem with an amount n and coin denominations d d . . . dm as its input. what is the time efficiency class of your algorithm? . design a greedy algorithm for the assignment problem see section . . does your greedy algorithm always yield an optimal solution? . job scheduling consider the problem of scheduling n jobs of known durations t t . . . tn for execution by a single processor. the jobs can be executed in any order one job at a time. you want to find a schedule that minimizes the total time spent by all the jobs in the system. the time spent by one job in the system is the sum of the time spent by this job in waiting plus the time spent on its execution. design a greedy algorithm for this problem. does the greedy algorithm always yield an optimal solution? . compatible intervals given n open intervals a b a b . . . an bn on the real line each representing start and end times of some activity requiring the same resource the task is to find the largest number of these intervals so that no two of them overlap. investigate the three greedy algorithms based on a. earliest start first. b. shortest duration first. c. earliest finish first. for each of the three algorithms either prove that the algorithm always yields an optimal solution or give a counterexample showing this not to be the case. . bridge crossing revisited consider the generalization of the bridge crossing puzzle problem in exercises . in which we have n people whose bridge crossing times are t t . . . tn. all the other conditions of the problem remain the same at most two people at a time can cross the bridge and they move with the speed of the slower of the two and they must carry with them the only flashlight the group has. design a greedy algorithm for this problem and find how long it will take to cross the bridge by using this algorithm. does your algorithm yield a minimum crossing time for every instance of the problem? if it does prove it if it does not find an instance with the smallest number of people for which this happens. . averaging down there are n identical vessels one of them with w pints of water and the others empty. you are allowed to perform the following operation take two of the vessels and split the total amount of water in them equally between them. the object is to achieve a minimum amount of water in the vessel containing all the water in the initial set up by a sequence of such operations. what is the best way to do this? . rumor spreading there are n people each in possession of a different rumor. they want to share all the rumors with each other by sending electronic messages. assume that a sender includes all the rumors he or she knows at the time the message is sent and that a message may only have one addressee. design a greedy algorithm that always yields the minimum number of messages they need to send to guarantee that every one of them gets all the rumors. . bachet's problem of weights find an optimal set of n weights w w . . . wn so that it would be possible to weigh on a balance scale any integer load in the largest possible range from to w provided a. weights can be put only on the free cup of the scale. b. weights can be put on both cups of the scale. . a. apply prim's algorithm to the following graph. include in the priority queue all the vertices not already in the tree. a b e c d b. apply prim's algorithm to the following graph. include in the priority queue only the fringe vertices the vertices not in the current tree which are adjacent to at least one tree vertex . a b c d e f g h i j k l . the notion of a minimum spanning tree is applicable to a connected weighted graph. do we have to check a graph's connectivity before applying prim's algorithm or can the algorithm do it by itself? . does prim's algorithm always work correctly on graphs with negative edge weights? . let t be a minimum spanning tree of graph g obtained by prim's algorithm. let gnew be a graph obtained by adding to g a new vertex and some edges with weights connecting the new vertex to some vertices in g. can we construct a minimum spanning tree of gnew by adding one of the new edges to t ? if you answer yes explain how if you answer no explain why not. . how can one use prim's algorithm to find a spanning tree of a connected graph with no weights on its edges? is it a good algorithm for this problem? . prove that any weighted connected graph with distinct weights has exactly one minimum spanning tree. . outline an efficient algorithm for changing an element's value in a min heap. what is the time efficiency of your algorithm? 