the sorting problem is to rearrange the items of a given list in nondecreasing order. of course for this problem to be meaningful the nature of the list items must allow such an ordering. mathematicians would say that there must exist a relation of total ordering. as a practical matter we usually need to sort lists of numbers characters from an alphabet character strings and most important records similar to those maintained by schools about their students libraries about their holdings and companies about their employees. in the case of records we need to choose a piece of information to guide sorting. for example we can choose to sort student records in alphabetical order of names or by student number or by student grade point average. such a specially chosen piece of information is called a key. computer scientists often talk about sorting a list of keys even when the list's items are not records but say just integers. why would we want a sorted list? to begin with a sorted list can be a required output of a task such as ranking internet search results or ranking students by their gpa scores. further sorting makes many questions about the list easier to answer. the most important of them is searching it is why dictionaries telephone books class lists and so on are sorted. you will see other examples of the usefulness of list presorting in section . . in a similar vein sorting is used as an auxiliary step in several important algorithms in other areas e.g. geometric algorithms and data compression. the greedy approach an important algorithm design technique discussed later in the book requires a sorted input. by now computer scientists have discovered dozens of different sorting algorithms. in fact inventing a new sorting algorithm has been likened to designing the proverbial mousetrap. and i am happy to report that the hunt for a better sorting mousetrap continues. this perseverance is admirable in view of the following facts. on the one hand there are a few good sorting algorithms that sort an arbitrary array of size n using about n log n comparisons. on the other hand no algorithm that sorts by key comparisons as opposed to say comparing small pieces of keys can do substantially better than that. there is a reason for this embarrassment of algorithmic riches in the land of sorting. although some algorithms are indeed better than others there is no algorithm that would be the best solution in all situations. some of the algorithms are simple but relatively slow while others are faster but more complex some work better on randomly ordered inputs while others do better on almost sorted lists some are suitable only for lists residing in the fast memory while others can be adapted for sorting large files stored on a disk and so on. two properties of sorting algorithms deserve special mention. a sorting algorithm is called stable if it preserves the relative order of any two equal elements in its input. in other words if an input list contains two equal elements in positions i and j where i j then in the sorted list they have to be in positions i and j respectively such that i j . this property can be desirable if for example we have a list of students sorted alphabetically and we want to sort it according to student gpa a stable algorithm will yield a list in which students with the same gpa will still be sorted alphabetically. generally speaking algorithms that can exchange keys located far apart are not stable but they usually work faster you will see how this general comment applies to important sorting algorithms later in the book. the second notable feature of a sorting algorithm is the amount of extra memory the algorithm requires. an algorithm is said to be in place if it does not require extra memory except possibly for a few memory units. there are important sorting algorithms that are in place and those that are not. 