definition a heap can be defined as a binary tree with keys assigned to its nodes one key per node provided the following two conditions are met . the shape property the binary tree is essentially complete or simply complete i.e. all its levels are full except possibly the last level where only some rightmost leaves may be missing. . the parental dominance or heap property the key in each node is greater than or equal to the keys in its children. this condition is considered automatically satisfied for all leaves. for example consider the trees of figure . . the first tree is a heap. the second one is not a heap because the tree's shape property is violated. and the third one is not a heap because the parental dominance fails for the node with key . note that key values in a heap are ordered top down i.e. a sequence of values on any path from the root to a leaf is decreasing nonincreasing if equal keys are allowed . however there is no left to right order in key values i.e. there is no . some authors require the key at each node to be less than or equal to the keys at its children. we call this variation a min heap. the array representation index value parents leaves figure . heap and its array representation. relationship among key values for nodes either on the same level of the tree or more generally in the left and right subtrees of the same node. here is a list of important properties of heaps which are not difficult to prove check these properties for the heap of figure . as an example . . there exists exactly one essentially complete binary tree with n nodes. its height is equal to log n . . the root of a heap always contains its largest element. . a node of a heap considered with all its descendants is also a heap. . a heap can be implemented as an array by recording its elements in the topdown left to right fashion. it is convenient to store the heap's elements in positions through n of such an array leaving h either unused or putting there a sentinel whose value is greater than every element in the heap. in such a representation a. the parental node keys will be in the first n positions of the array while the leaf keys will occupy the last n positions b. the children of a key in the array's parental position i i n will be in positions i and i and correspondingly the parent of a key in position i i n will be in position i . thus we could also define a heap as an array h ..n in which every element in position i in the first half of the array is greater than or equal to the elements in positions i and i i.e. h i max h i h i for i . . . n . of course if i n just h i h i needs to be satisfied. while the ideas behind the majority of algorithms dealing with heaps are easier to understand if we think of heaps as binary trees their actual implementations are usually much simpler and more efficient with arrays. how can we construct a heap for a given list of keys? there are two principal alternatives for doing this. the first is the bottom up heap construction algorithm illustrated in figure . . it initializes the essentially complete binary tree with n nodes by placing keys in the order given and then heapifies the tree as follows. starting with the last parental node the algorithm checks whether the parental figure . bottom up construction of a heap for the list . the doubleheaded arrows show key comparisons verifying the parental dominance. dominance holds for the key in this node. if it does not the algorithm exchanges the node's key k with the larger key of its children and checks whether the parental dominance holds for k in its new position. this process continues until the parental dominance for k is satisfied. eventually it has to because it holds automatically for any key in a leaf. after completing the heapification of the subtree rooted at the current parental node the algorithm proceeds to do the same for the node's immediate predecessor. the algorithm stops after this is done for the root of the tree. algorithm heapbottomup h ..n constructs a heap from elements of a given array by the bottom up algorithm input an array h ..n of orderable items output a heap h ..n for i n downto do k i v h k heap false while not heap and k n do j k if j n there are two children if h j h j j j if v h j heap true else h k h j kj h k v how efficient is this algorithm in the worst case? assume for simplicity that n k so that a heap's tree is full i.e. the largest possible number of nodes occurs on each level. let h be the height of the tree. according to the first property of heaps in the list at the beginning of the section h log n or just log n k for the specific values of n we are considering. each key on level i of the tree will travel to the leaf level h in the worst case of the heap construction algorithm. since moving to the next level down requires two comparisons one to find the larger child and the other to determine whether the exchange is required the total number of key comparisons involving a key on level i will be h i . therefore the total number of key comparisons in the worst case will be h h cworst n h i h i i n log n i level i keys i where the validity of the last equality can be proved either by using the closed form formula for the sum h i i see appendix a or by mathematical induction on i h. thus with this bottom up algorithm a heap of size n can be constructed with fewer than n comparisons. the alternative and less efficient algorithm constructs a heap by successive insertions of a new key into a previously constructed heap some people call it the top down heap construction algorithm. so how can we insert a new key k into a heap? first attach a new node with key k in it after the last leaf of the existing heap. then sift k up to its appropriate place in the new heap as follows. compare k with its parent's key if the latter is greater than or equal to k stop the structure is a heap otherwise swap these two keys and compare k with its new parent. this swapping continues until k is not greater than its last parent or it reaches the root illustrated in figure . . obviously this insertion operation cannot require more key comparisons than the heap's height. since the height of a heap with n nodes is about log n the time efficiency of insertion is in o log n . how can we delete an item from a heap? we consider here only the most important case of deleting the root's key leaving the question about deleting an arbitrary key in a heap for the exercises. authors of textbooks like to do such things to their readers do they not? deleting the root's key from a heap can be done with the following algorithm illustrated in figure . . figure . inserting a key into the heap constructed in figure . . the new key is sifted up via a swap with its parent until it is not larger than its parent or is in the root . step step step figure . deleting the root's key from a heap. the key to be deleted is swapped with the last key after which the smaller tree is heapified by exchanging the new key in its root with the larger key in its children until the parental dominance requirement is satisfied. maximum key deletion from a heap step exchange the root's key with the last key k of the heap. step decrease the heap's size by . step heapify the smaller tree by sifting k down the tree exactly in the same way we did it in the bottom up heap construction algorithm. that is verify the parental dominance for k if it holds we are done if not swap k with the larger of its children and repeat this operation until the parental dominance condition holds for k in its new position. the efficiency of deletion is determined by the number of key comparisons needed to heapify the tree after the swap has been made and the size of the tree is decreased by . since this cannot require more key comparisons than twice the heap's height the time efficiency of deletion is in o log n as well. 