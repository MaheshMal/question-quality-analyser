in this section we will see how to apply the general framework for analysis of algorithms to recursive algorithms. we start with an example often used to introduce novices to the idea of a recursive algorithm. example compute the factorial function f n n! for an arbitrary nonnegative integer n. since n! . . . . . n . n n ! . n for n and ! by definition we can compute f n f n . n with the following recursive algorithm. algorithm f n computes n! recursively input a nonnegative integer n output the value of n! if n return else return f n n for simplicity we consider n itself as an indicator of this algorithm's input size rather than the number of bits in its binary expansion . the basic operation of the algorithm is multiplication whose number of executions we denote m n . since the function f n is computed according to the formula f n f n . n for n . alternatively we could count the number of times the comparison n is executed which is the same as counting the total number of calls made by the algorithm see problem in this section's exercises . the number of multiplications m n needed to compute it must satisfy the equality m n m n for n . to compute to multiply f n f n by n indeed m n multiplications are spent to compute f n and one more multiplication is needed to multiply the result by n. the last equation defines the sequence m n that we need to find. this equation defines m n not explicitly i.e. as a function of n but implicitly as a function of its value at another point namely n . such equations are called recurrence relations or for brevity recurrences. recurrence relations play an important role not only in analysis of algorithms but also in some areas of applied mathematics. they are usually studied in detail in courses on discrete mathematics or discrete structures a very brief tutorial on them is provided in appendix b. our goal now is to solve the recurrence relation m n m n i.e. to find an explicit formula for m n in terms of n only. note however that there is not one but infinitely many sequences that satisfy this recurrence. can you give examples of say two of them? to determine a solution uniquely we need an initial condition that tells us the value with which the sequence starts. we can obtain this value by inspecting the condition that makes the algorithm stop its recursive calls if n return . this tells us two things. first since the calls stop when n the smallest value of n for which this algorithm is executed and hence m n defined is . second by inspecting the pseudocode's exiting line we can see that when n the algorithm performs no multiplications. therefore the initial condition we are after is m . the calls stop when n no multiplications when n thus we succeeded in setting up the recurrence relation and initial condition for the algorithm's number of multiplications m n m n m n for n . m . before we embark on a discussion of how to solve this recurrence let us pause to reiterate an important point. we are dealing here with two recursively defined functions. the first is the factorial function f n itself it is defined by the recurrence f n f n . n for every n f . the second is the number of multiplications m n needed to compute f n by the recursive algorithm whose pseudocode was given at the beginning of the section. as we just showed m n is defined by recurrence . . and it is recurrence . that we need to solve now. though it is not difficult to guess the solution here what sequence starts with when n and increases by on each step? it will be more useful to arrive at it in a systematic fashion. from the several techniques available for solving recurrence relations we use what can be called the method of backward substitutions. the method's idea and the reason for the name is immediately clear from the way it applies to solving our particular recurrence m n m n substitute m n m n m n m n substitute m n m n m n m n . after inspecting the first three lines we see an emerging pattern which makes it possible to predict not only the next line what would it be? but also a general formula for the pattern m n m n i i. strictly speaking the correctness of this formula should be proved by mathematical induction but it is easier to get to the solution as follows and then verify its correctness. what remains to be done is to take advantage of the initial condition given. since it is specified for n we have to substitute i n in the pattern's formula to get the ultimate result of our backward substitutions m n m n . . . m n i i . . . m n n n n. you should not be disappointed after exerting so much effort to get this obvious answer. the benefits of the method illustrated in this simple example will become clear very soon when we have to solve more difficult recurrences. also note that the simple iterative algorithm that accumulates the product of n consecutive integers requires the same number of multiplications and it does so without the overhead of time and space used for maintaining the recursion's stack. the issue of time efficiency is actually not that important for the problem of computing n! however. as we saw in section . the function's values get so large so fast that we can realistically compute exact values of n! only for very small n's. again we use this example just as a simple and convenient vehicle to introduce the standard approach to analyzing recursive algorithms. generalizing our experience with investigating the recursive algorithm for computing n! we can now outline a general plan for investigating recursive algorithms. general plan for analyzing the time efficiency of recursive algorithms . decide on a parameter or parameters indicating an input's size. . identify the algorithm's basic operation. . check whether the number of times the basic operation is executed can vary on different inputs of the same size if it can the worst case average case and best case efficiencies must be investigated separately. . set up a recurrence relation with an appropriate initial condition for the number of times the basic operation is executed. . solve the recurrence or at least ascertain the order of growth of its solution. example as our next example we consider another educational workhorse of recursive algorithms the tower of hanoi puzzle. in this puzzle we or mythical monks if you do not like to move disks have n disks of different sizes that can slide onto any of three pegs. initially all the disks are on the first peg in order of size the largest on the bottom and the smallest on top. the goal is to move all the disks to the third peg using the second one as an auxiliary if necessary. we can move only one disk at a time and it is forbidden to place a larger disk on top of a smaller one. the problem has an elegant recursive solution which is illustrated in figure . . to move n disks from peg to peg with peg as auxiliary we first move recursively n disks from peg to peg with peg as auxiliary then move the largest disk directly from peg to peg and finally move recursively n disks from peg to peg using peg as auxiliary . of course if n we simply move the single disk directly from the source peg to the destination peg. figure . recursive solution to the tower of hanoi puzzle. let us apply the general plan outlined above to the tower of hanoi problem. the number of disks n is the obvious choice for the input's size indicator and so is moving one disk as the algorithm's basic operation. clearly the number of moves m n depends on n only and we get the following recurrence equation for it m n m n m n for n . with the obvious initial condition m we have the following recurrence relation for the number of moves m n m n m n for n . m . we solve this recurrence by the same method of backward substitutions m n m n sub. m n m n m n m n sub. m n m n m n m n . the pattern of the first three sums on the left suggests that the next one will be m n and generally after i substitutions we get m n im n i i i . . . im n i i . since the initial condition is specified for n which is achieved for i n we get the following formula for the solution to recurrence . m n n m n n n n m n n n n . thus we have an exponential algorithm which will run for an unimaginably long time even for moderate values of n see problem in this section's exercises . this is not due to the fact that this particular algorithm is poor in fact it is not difficult to prove that this is the most efficient algorithm possible for this problem. it is the problem's intrinsic difficulty that makes it so computationally hard. still this example makes an important general point one should be careful with recursive algorithms because their succinctness may mask their inefficiency. when a recursive algorithm makes more than a single call to itself it can be useful for analysis purposes to construct a tree of its recursive calls. in this tree nodes correspond to recursive calls and we can label them with the value of the parameter or more generally parameters of the calls. for the tower of hanoi example the tree is given in figure . . by counting the number of nodes in the tree we can get the total number of calls made by the tower of hanoi algorithm n c n l where l is the level in the tree in figure . n . l n n n n n n n figure . tree of recursive calls made by the recursive algorithm for the tower of hanoi puzzle. the number agrees as it should with the move count obtained earlier. example as our next example we investigate a recursive version of the algorithm discussed at the end of section . . algorithm binrec n input a positive decimal integer n output the number of binary digits in n's binary representation if n return else return binrec n let us set up a recurrence and an initial condition for the number of additions a n made by the algorithm. the number of additions made in computing binrec n is a n plus one more addition is made by the algorithm to increase the returned value by . this leads to the recurrence a n a n for n . . since the recursive calls end when n is equal to and there are no additions made then the initial condition is a . the presence of n in the function's argument makes the method of backward substitutions stumble on values of n that are not powers of . therefore the standard approach to solving such a recurrence is to solve it only for n k and then take advantage of the theorem called the smoothness rule see appendix b which claims that under very broad assumptions the order of growth observed for n k gives a correct answer about the order of growth for all values of n. alternatively after getting a solution for powers of we can sometimes fine tune this solution to get a formula valid for an arbitrary n. so let us apply this recipe to our recurrence which for n k takes the form a k a k for k a . now backward substitutions encounter no problems a k a k substitute a k a k a k a k substitute a k a k a k a k ... ... a k i i ... a k k k. thus we end up with a k a k k or after returning to the original variable n k and hence k log n a n log n log n . in fact one can prove problem in this section's exercises that the exact solution for an arbitrary value of n is given by just a slightly more refined formula a n log n . this section provides an introduction to the analysis of recursive algorithms. these techniques will be used throughout the book and expanded further as necessary. in the next section we discuss the fibonacci numbers their analysis involves more difficult recurrence relations to be solved by a method different from backward substitutions. exercises . . solve the following recurrence relations. a. x n x n for n x b. x n x n for n x c. x n x n n for n x d. x n x n n for n x solve for n k e. x n x n for n x solve for n k . set up and solve a recurrence relation for the number of calls made by f n the recursive algorithm for computing n!. . consider the following recursive algorithm for computing the sum of the first n cubes s n . . . n . algorithm s n input a positive integer n output the sum of the first n cubes if n return else return s n n n n a. set up and solve a recurrence relation for the number of times the algorithm's basic operation is executed. b. how does this algorithm compare with the straightforward nonrecursive algorithm for computing this sum? . consider the following recursive algorithm. algorithm q n input a positive integer n if n return else return q n n a. set up a recurrence relation for this function's values and solve it to determine what this algorithm computes. b. set up a recurrence relation for the number of multiplications made by this algorithm and solve it. c. set up a recurrence relation for the number of additions subtractions made by this algorithm and solve it. . tower of hanoi a. in the original version of the tower of hanoi puzzle as it was published in the s by e douard lucas a french mathematician the world will end after disks have been moved from a mystical tower of brahma. estimate the number of years it will take if monks could move one disk per minute. assume that monks do not eat sleep or die. b. how many moves are made by the ith largest disk i n in this algorithm? c. find a nonrecursive algorithm for the tower of hanoi puzzle and implement it in the language of your choice. . restricted tower of hanoi consider the version of the tower of hanoi puzzle in which n disks have to be moved from peg a to peg c using peg b so that any move should either place a disk on peg b or move a disk from that peg. of course the prohibition of placing a larger disk on top of a smaller one remains in place too. design a recursive algorithm for this problem and find the number of moves made by it. . a. prove that the exact number of additions made by the recursive algorithm binrec n for an arbitrary positive decimal integer n is log n . b. set up a recurrence relation for the number of additions made by the nonrecursive version of this algorithm see section . example and solve it. . a. design a recursive algorithm for computing n for any nonnegative integer n that is based on the formula n n n . b. set up a recurrence relation for the number of additions made by the algorithm and solve it. c. draw a tree of recursive calls for this algorithm and count the number of calls made by the algorithm. d. is it a good algorithm for solving this problem? . consider the following recursive algorithm. algorithm riddle a ..n input an array a ..n of real numbers if n return a else temp riddle a ..n if temp a n return temp else return a n a. what does this algorithm compute? b. set up a recurrence relation for the algorithm's basic operation count and solve it. . consider the following algorithm to check whether a graph defined by its adjacency matrix is complete. algorithm graphcomplete a ..n ..n input adjacency matrix a ..n ..n of an undirected graph g output true if g is complete and false otherwise if n return one vertex graph is complete by definition else if not graphcomplete a ..n ..n return else for j to n do if a n j return return what is the algorithm's efficiency class in the worst case? . the determinant of an n n matrix a ... a n a a ... ... a n... an ... an n denoted det a can be defined as a for n and for n by the recursive formula n det a sj a j det aj j where sj is if j is even and if j is odd a j is the element in row and column j and aj is the n n matrix obtained from matrix a by deleting its row and column j . a. set up a recurrence relation for the number of multiplications made by the algorithm implementing this recursive definition. b. without solving the recurrence what can you say about the solution's order of growth as compared to n!? . von neumann's neighborhood revisited find the number of cells in the von neumann neighborhood of range n problem in exercises . by setting up and solving a recurrence relation. . frying hamburgers there are n hamburgers to be fried on a small grill that can hold only two hamburgers at a time. each hamburger has to be fried on both sides frying one side of a hamburger takes minute regardless of whether one or two hamburgers are fried at the same time. consider the following recursive algorithm for executing this task in the minimum amount of time. if n fry the hamburger or the two hamburgers together on each side. if n fry any two hamburgers together on each side and then apply the same procedure recursively to the remaining n hamburgers. a. set up and solve the recurrence for the amount of time this algorithm needs to fry n hamburgers. b. explain why this algorithm does not fry the hamburgers in the minimum amount of time for all n . c. give a correct recursive algorithm that executes the task in the minimum amount of time. . celebrity problem a celebrity among a group of n people is a person who knows nobody but is known by everybody else. the task is to identify a celebrity by only asking questions to people of the form do you know him her? design an efficient algorithm to identify a celebrity or determine that the group has no such person. how many questions does your algorithm need in the worst case? 