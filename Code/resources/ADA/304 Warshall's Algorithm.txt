recall that the adjacency matrix a aij of a directed graph is the boolean matrix that has in its ith row and j th column if and only if there is a directed edge from the ith vertex to the j th vertex. we may also be interested in a matrix containing the information about the existence of directed paths of arbitrary lengths between vertices of a given graph. such a matrix called the transitive closure of the digraph would allow us to determine in constant time whether the j th vertex is reachable from the ith vertex. here are a few application examples. when a value in a spreadsheet cell is changed the spreadsheet software must know all the other cells affected by the change. if the spreadsheet is modeled by a digraph whose vertices represent the spreadsheet cells and edges indicate cell dependencies the transitive closure will provide such information. in software engineering transitive closure can be used for investigating data flow and control flow dependencies as well as for inheritance testing of object oriented software. in electronic engineering it is used for redundancy identification and test generation for digital circuits. definition the transitive closure of a directed graph with n vertices can be defined as the n n boolean matrix t tij in which the element in the ith row and the j th column is if there exists a nontrivial path i.e. directed path of a positive length from the ith vertex to the j th vertex otherwise tij is . an example of a digraph its adjacency matrix and its transitive closure is given in figure . . we can generate the transitive closure of a digraph with the help of depthfirst search or breadth first search. performing either traversal starting at the ith a b a b c d a b c d a a a b t b c c c d d d a b c figure . a digraph. b its adjacency matrix. c its transitive closure. vertex gives the information about the vertices reachable from it and hence the columns that contain 's in the ith row of the transitive closure. thus doing such a traversal for every vertex as a starting point yields the transitive closure in its entirety. since this method traverses the same digraph several times we should hope that a better algorithm can be found. indeed such an algorithm exists. it is called warshall's algorithm after stephen warshall who discovered it war . it is convenient to assume that the digraph's vertices and hence the rows and columns of the adjacency matrix are numbered from to n. warshall's algorithm constructs the transitive closure through a series of n n boolean matrices r . . . r k r k . . . r n . . each of these matrices provides certain information about directed paths in the digraph. specifically the element ri jk in the ith row and j th column of matrix r k i j . . . n k . . . n is equal to if and only if there exists a directed path of a positive length from the ith vertex to the j th vertex with each intermediate vertex if any numbered not higher than k. thus the series starts with r which does not allow any intermediate vertices in its paths hence r is nothing other than the adjacency matrix of the digraph. recall that the adjacency matrix contains the information about one edge paths i.e. paths with no intermediate vertices. r contains the information about paths that can use the first vertex as intermediate thus with more freedom so to speak it may contain more 's than r . in general each subsequent matrix in series . has one more vertex to use as intermediate for its paths than its predecessor and hence may but does not have to contain more 's. the last matrix in the series r n reflects paths that can use all n vertices of the digraph as intermediate and hence is nothing other than the digraph's transitive closure. the central point of the algorithm is that we can compute all the elements of each matrix r k from its immediate predecessor r k in series . . let ri jk the element in the ith row and j th column of matrix r k be equal to . this means that there exists a path from the ith vertex vi to the j th vertex vj with each intermediate vertex numbered not higher than k vi a list of intermediate vertices each numbered not higher than k vj . . j k j k r k k r k k i i figure . rule for changing zeros in warshall's algorithm. two situations regarding this path are possible. in the first the list of its intermediate vertices does not contain the kth vertex. then this path from vi to vj has intermediate vertices numbered not higher than k and therefore ri jk is equal to as well. the second possibility is that path . does contain the kth vertex vk among the intermediate vertices. without loss of generality we may assume that vk occurs only once in that list. if it is not the case we can create a new path from vi to vj with this property by simply eliminating all the vertices between the first and last occurrences of vk in it. with this caveat path . can be rewritten as follows vi vertices numbered k vk vertices numbered k vj . the first part of this representation means that there exists a path from vi to vk with each intermediate vertex numbered not higher than k hence ri kk and the second part means that there exists a path from vk to vj with each intermediate vertex numbered not higher than k hence rk jk . what we have just proved is that if ri jk then either ri jk or both ri kk and rk jk . it is easy to see that the converse of this assertion is also true. thus we have the following formula for generating the elements of matrix r k from the elements of matrix r k ri jk ri jk or ri kk and rk jk . . formula . is at the heart of warshall's algorithm. this formula implies the following rule for generating elements of matrix r k from elements of matrix r k which is particularly convenient for applying warshall's algorithm by hand if an element rij is in r k it remains in r k . if an element rij is in r k it has to be changed to in r k if and only if the element in its row i and column k and the element in its column j and row k are both 's in r k . this rule is illustrated in figure . . as an example the application of warshall's algorithm to the digraph in figure . is shown in figure . . a b c d 's reflect the existence of paths a b a with no intermediate vertices r b r is just the adjacency matrix c boxed row and column are used for getting r . c d d a b c d 's reflect the existence of paths a with intermediate vertices numbered r b not higher than i.e. just vertex a c note a new path from d to b d boxed row and column are used for getting r . a b c d 's reflect the existence of paths a with intermediate vertices numbered r b not higher than i.e. a and b c note two new paths d boxed row and column are used for getting r . a b c d 's reflect the existence of paths a with intermediate vertices numbered r b not higher than i.e. a b and c c no new paths d boxed row and column are used for getting r . a b c d a 's reflect the existence of paths r b with intermediate vertices numbered c not higher than i.e. a b c and d d note five new paths . figure . application of warshall's algorithm to the digraph shown. new 's are in bold. here is pseudocode of warshall's algorithm. algorithm warshall a ..n ..n implements warshall's algorithm for computing the transitive closure input the adjacency matrix a of a digraph with n vertices output the transitive closure of the digraph r a for k to n do for i to n do for j to n do r k i j r k i j or r k i k and r k k j return r n several observations need to be made about warshall's algorithm. first it is remarkably succinct is it not? still its time efficiency is only n . in fact for sparse graphs represented by their adjacency lists the traversal based algorithm a b a b c d a b c d a a w b d b c c c d d d a b c figure . a digraph. b its weight matrix. c its distance matrix. mentioned at the beginning of this section has a better asymptotic efficiency than warshall's algorithm why? . we can speed up the above implementation of warshall's algorithm for some inputs by restructuring its innermost loop see problem in this section's exercises . another way to make the algorithm run faster is to treat matrix rows as bit strings and employ the bitwise or operation available in most modern computer languages. as to the space efficiency of warshall's algorithm the situation is similar to that of computing a fibonacci number and some other dynamic programming algorithms. although we used separate matrices for recording intermediate results of the algorithm this is in fact unnecessary. problem in this section's exercises asks you to find a way of avoiding this wasteful use of the computer memory. finally we shall see below how the underlying idea of warshall's algorithm can be applied to the more general problem of finding lengths of shortest paths in weighted graphs. 