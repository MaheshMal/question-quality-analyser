Distributed Computation Paradigms
Data used in an application may be stored in different sites of a distributed system
because of the following considerations:
·  Data replication: Several copies of a data D may be kept in different sites of
   a distributed system to provide availability and efficient access.
·  Data distribution: Parts of a data D may be kept in different sites of a system
   either because the data D is voluminous, or because its parts originate in
   different sites or are frequently used in different sites.



666  Part 5  Distributed Operating Systems
             Table 16.4      Modes          of  Accessing Data in a Distributed System
             Mode of access                     Description
             Remote data access                 A computation accesses data over the network. This
                                                mode of access does not interfere with organization or
                                                access of data and does not require restructuring of a
                                                computation. However, computations are slowed down
                                                by communication delays.
             Data migration                     The data is moved to the site where a computation is
                                                located. Data migration provides efficient data access;
                                                however, it may interfere with replication and
                                                distribution of data.
             Computation migration              A computation (or a part of it) is moved to the site
                                                where its data is located. It provides efficient data access
                                                without interfering with organization or access of data.
             When data D is neither replicated nor distributed, the OS may position it such
             that the total network traffic generated by accesses to D by various applications
             is minimal.
             Table 16.4 summarizes three modes of accessing data in a distributed system.
             In remote data access, the data is accessed in situ, i.e., where it exists. This mode
             of using data does not interfere with decisions concerning placement of the data;
             however, it is slow because of network latencies. Data migration involves moving
             data to the site of the computation that uses it. This mode faces difficulties if
             data is used by many computations or if it has been replicated to provide high
             availability. In the worst case, it may force the data to be used strictly by one
             computation at a time. Computation migration moves a computation to the site
             where its data is located. It does not interfere with replication or distribution
             of data.
             Operating systems provide some support for each data access mode summa-
             rized in Table 16.4. As described in Section 16.3, a network OS supports remote
             data access. The File Transfer Protocol (FTP) is a facility for data migration; it
             performs transfer of files in an offline manner rather than during execution of a
             computation. Process migration is a feature for migrating a computation, or a part
             of it, while the computation is in progress. It is described later in Section 18.8.2.
             A distributed computation is one whose parts can be executed in different
             sites for reasons of data access efficiency, computation speedup, or reliability.
             A distributed computation paradigm is a model of useful practices for designing
             distributed computations. The primary issues addressed by a distributed compu-
             tation paradigm are manipulation of data and initiation of subcomputations
             in different sites of a distributed system. Table 16.5 summarizes three dis-
             tributed computation paradigms. The client­server computing paradigm focuses
             on remote data access and manipulation, while the remote procedure call and
             remote evaluation paradigms provide different ways of performing computation
             migration.



                                                    Chapter 16   Distributed Operating   Systems  667
Table 16.5  Distributed Computation Paradigms
Paradigm                 Description
Client­server computing  A server process provides a specific service to its clients.
                         A client process invokes its service by sending a
                         message to it, and the server returns its results in
                         another message. Applications use the client­server
                         paradigm extensively to perform remote data access or
                         remote data manipulation.
Remote procedure         A remote procedure resembles a conventional
call (RPC)               procedure except that it executes in a different node of
                         the system. A remote procedure is installed in a node
                         by a system administrator and it is registered with a
                         name server. The remote procedure call has been used
                         extensively for computation migration.
Remote evaluation        If a program uses the statement at <node> eval
                         <code_segment>, the compiler of the language in
                         which the program is written makes a provision to
                         transfer <code_segment> to the node designated by
                         <node>, execute it there and return its results. There is
                         no need to install the code segment in the remote node.
                         Java provides a facility for remote evaluation.
16.5.1 Client--Server Computing
A server is a process in a distributed system that provides a specific service to its
clients. Typically, the name of a server and a specification of its service are widely
advertised in a system. Any process can send a message to a server and become its
client. A service may have a physical connotation like accessing or printing a file, or
it may have a computational connotation like evaluating mathematical functions
in a math server. Accordingly, the server's role ranges from mere data access to
data manipulation; in the latter case the server may even play a computational
role in a distributed computation.
A server may become a bottleneck if the rate at which clients make requests
exceeds the rate at which the server can service them. Figure 16.5 depicts three
methods of addressing this problem. Figure 16.5(a) shows many identical servers,
each with its own request queue. The clients are partitioned in some way such
that each client knows which server it should use. This arrangement inherits the
drawbacks of partitioning--some servers may be heavily loaded while others
are idle. In Figure 16.5(b) many servers dynamically share the same queue. This
arrangement is more flexible than partitioning the clients to use different servers.
Figure 16.5(c) shows a multithreaded server. A new thread is created to handle
each request. The threads compete with one another for CPU and other resources.
If the server function is I/O-bound, this arrangement can overlap servicing of
several requests. Another way to eliminate the server bottleneck is to push most
of the computational burden into a client process. Now the server can provide



668  Part 5  Distributed Operating Systems
                       S            S                S  S        S                              S
                           Clients                      Clients                        Clients
                  (a)                           (b)                           (c)
             Figure  16.5  Servers with (a) independent and (b) shared queues; (c) a multithreaded server.
             better response times to clients. Design methodologies have been evolved to design
             such client­server arrangements.
                  Client­server computing is a poor paradigm for distributed computing
             because methodologies for structuring a distributed computation in the form of
             a client­server configuration have not been evolved. The primary difficulty is that
             a distributed computation involves many entities with a symmetric relationship.
             This relationship is hard to model with the client­server paradigm. In practice,
             the client­server paradigm is used extensively for noncomputational roles in a
             LAN environment, such as accessing files, or handling simple database queries.
             To make its implementation efficient, simple protocols like the RR protocol are
             preferred over multilayered protocols like the ISO protocol, which is discussed in
             a later section.
             16.5.2 Remote Procedure Calls
             A remote procedure call (RPC) is a programming language feature designed
             for  distributed       computing.  As  discussed    earlier  in  Section  9.4.2,  its  syntax
             and semantics resemble those of a conventional procedure call. In the remote
             procedure call
                                            call <proc_id> (<message>);
             <proc_id> is the id of a remote procedure, and <message> is a list of parameters.
             The call is implemented by using a blocking protocol. The result of the call may be
             passed back through one of the parameters, or through an explicit return value.
             We can view the caller­callee relationship as a client­server relationship. Thus,
             the remote procedure is the server and a process calling it is a client.
                  The schematic diagram of Figure 16.6 depicts the arrangement used to per-
             form name resolution, parameter passing, and return of results during a remote
             procedure call. The domain name system (DNS) described in Section 16.4.1 is
             used to obtain the IP address of the called process. The functions of the client and
             server stubs are as described earlier in Section 9.4.2--the client stub converts the
             parameters into a machine-independent form and the server stub converts them
             into the machine-specific representation suitable for the server's host, whereas
             they play the converse roles for the results of the called procedure. The circled



                                                                  Chapter 16      Distributed Operating  Systems  669
                                      Name
                                      server
                                 3
             Client           Client             Server                   Server
             process          stub               stub                   procedure
                      1                       4                   6
                              2  9                             5
                      10                      8                   7
                      Client                                      Server
                      site                                        site
Figure 16.6  Implementation of a remote procedure call (RPC).
numbers in Figure 16.6 denote the steps in implementing the remote procedure
call. Details of these steps are as follows:
1. The client process calls the client stub with parameters. This call is a con-
ventional procedure call. Hence execution of the client process is suspended
until the call is completed.
2. The client stub marshals the parameters and converts them into a machine-
independent format. It now prepares a message containing this representa-
tion of parameters.
3. The client stub interacts with the name server to find the identity of the site
at which the remote procedure exists.
4. The client stub sends the message prepared in Step 2 to the site where the
remote procedure exists, using a blocking protocol. This send operation
blocks the client stub until a reply to its message arrives.
5. The server stub receives the message sent by the client stub. It converts the
parameters to the machine-specific format suitable for the server site.
6. The server stub now executes a call on the server procedure with these param-
eters. This is a conventional procedure call, hence execution of the server stub
is suspended until the procedure call is completed.
7. The server procedure returns its results to the server stub. The server stub
converts them into a machine-independent format and prepares a message
containing the results.
8. The message containing the results is sent to the client site.
9. The client stub converts the results into the format suitable for the client site.
10. The client stub returns the results to the client process.
Step 10 completes execution of the remote procedure call. The client process is
now free to continue its execution.
In Step 3, the client stub need not perform name resolution every time the
RPC is executed. It can do so the first time, and save the information concerning
site of the remote procedure in a name server cache for future use. Name resolution
can even be performed statically, i.e., before operation of the client process begins.



670  Part 5  Distributed Operating Systems
             Faults may occur during a remote procedure call--either in the communica-
             tion link, in the server site, or in the client itself. If the client site crashes, the call
             becomes an orphan because its result is not going to be of any use. We discuss
             orphans and their handling later in Section 19.3. Communication and server
             faults can be handled using an arrangement involving acknowledgments and
             retransmissions (see Section 16.4). Ideally, RPCs should possess the exactly-once
             semantics; however, it is expensive to implement these semantics. At-least-once
             semantics are cheaper to implement; however, they require that either the actions
             of the remote procedure should be idempotent or that it must discard duplicate
             requests.
             The remote procedure call feature can be used as a building block for dis-
             tributed computations. Its advantages over the client­server paradigm are due
             to two factors. First, it may be possible to set up a remote procedure by simply
             intimating its name and location to the name server. It is much easier than setting
             up a server. Second, only those processes that know of the existence of a remote
             procedure can invoke it. So, use of remote procedures provides more privacy, and
             hence more security, than use of the client­server paradigm. Its primary disad-
             vantage is a lack of flexibility--the remote procedure has to be registered with a
             name server, so its location cannot be changed easily.
             16.5.3 Remote Evaluation
             The remote evaluation paradigm was proposed by Stamos and Gifford (1990).
             The paradigm is implemented through the statement
                                            at <node> eval <code_segment>
             where <node> is an expression that evaluates to the identity of some node in the
             distributed system and <code_segment> is a segment of code, possibly a sequence
             of statements. When the at statement is encountered during operation of a pro-
             cess, <node> is evaluated to obtain the identity of a node, <code_segment> is
             executed in that node, and its results, if any, are returned to the process.
             This paradigm has several advantages over the client­server and RPC
             paradigms. It requires minimal support from the OS. Most of the work is done
             by the compiler of the language in which the program is written. With the help
             of the OS, the compiler makes a provision to transfer <code_segment> to the
             target node and to execute it there. The OS of the target node creates a process to
             execute the code and to return its results. Prior installation of <code_segment>
             or an elaborate setup of stub procedures is not needed.
             The issues of naming and binding are also much simpler than in an RPC
             environment. The decision about which node should be used to execute the code
             segment is taken dynamically. This decision could use information concerning
             computational loads at various nodes. <code_segment> can be any arbitrary
             section of code that can be executed remotely; it need not have the syntactic
             shape of a procedure. The remote evaluation paradigm can be used along with the
             client­server or RPC paradigms, i.e., the code segment could invoke procedures
             during its execution or it could itself be a procedure.



                                           Chapter 16  Distributed Operating Systems   671
The remote evaluation paradigm can be used for computation speedup or
for improving efficiency of a computation. For example, if a subcomputation
involves considerable manipulation of data located at some specific node Si, the
subcomputation can itself be executed at Si. It would reduce the amount of
network traffic involved in remote data access. Similarly, if a user wishes to send
an email to a number of persons at Si, the mail sending command can itself be
executed at Si.
16.5.4 Case Studies
SUN RPC   Sun RPC was designed for client­server communication in NFS,
the Sun network file system. NFS models file processing actions as idempo-
tent actions, so Sun RPC provides the at-least-once semantics. This feature
makes the RPC efficient; however, it requires applications using RPC to make
their own arrangements for duplicate suppression if exactly-once semantics are
desired.
Sun RPC provides an interface language called XDR and an interface com-
piler called rpcgen. To use a remote procedure, a user has to write an interface
definition for it in XDR, which contains a specification of the remote procedure
and its parameters. The interface definition is compiled using rpcgen, which
produces the following: a client stub, the server procedure and a server stub, a
header file for use in the client and server programs, and two parameter han-
dling procedures that are invoked by the client and server stubs, respectively. The
client program is compiled with the header file and the client stub, while the server
program is compiled with the header file and the server stub. The parameter han-
dling procedure invoked by the client stub marshals parameters and converts
them into a machine-independent format called the external data representation
(XDR). The procedure invoked by the server stub converts parameters from the
XDR format into the machine representation suitable for the called procedure.
The Sun RPC schematic has some limitations. The remote procedure can
accept only one parameter. This limitation is overcome by defining a structure
containing many data members and passing the structure as the parameter. The
RPC implementation also does not use the services of a name server. Instead,
each site contains a port mapper that is like a local name server. It contains
names of procedures and their port ids. A procedure that is to be invoked as a
remote procedure is assigned a port and this information is registered with the
port mapper. The client first makes a request to the port mapper of the remote
site to find which port is used by the required remote procedure. It then calls the
procedure at that port. A weakness of this arrangement is that a caller must know
the site where a remote procedure exists.
Java Remote Method Invocation (RMI)        A server application running on a host
creates a special type of object called a remote object, whose methods may be
invoked by clients operating in other hosts. The server selects a name for the
service that is to be offered by a method of the remote object, and registers
it with a name server called the rmiregistry, which runs on the server's
