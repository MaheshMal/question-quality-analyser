Page Replacement Policies
             As discussed earlier in Section 12.2.1.1, a page replacement policy should replace
             a page that is not likely to be referenced in the immediate future. We evaluate
             the following three page replacement policies to see how well they fulfill this
             requirement.
             ·  Optimal page replacement policy
             ·  First-in, first-out (FIFO) page replacement policy
             ·  Least recently used (LRU) page replacement policy



                                                                              Chapter 12  Virtual Memory        439
For our analysis of these page replacement policies, we rely on the concept of
page reference strings. A page reference string of a process is a trace of the pages
accessed by the process during its operation. It can be constructed by monitoring
the operation of a process, and forming a sequence of page numbers that appear in
logical addresses generated by it. The page reference string of a process depends
on the data input to it, so use of different data would lead to a different page
reference string for a process.
For convenience we associate a reference time string t1, t2, t3, . . . with each
page reference string. This way, the kth page reference in a page reference string
is assumed to have occurred at time instant tk. (In effect, we assume a logical
clock that runs only when a process is in the running state and gets advanced only
when the process refers to a logical address.) Example 12.5 illustrates the page
reference string and the associated reference time string for a process.
                                                                                                                ·
Page Reference String                                                                        Example      12.5
A computer supports instructions that are 4 bytes in length, and uses a page
size of 1 KB. It executes the following nonsense program in which the symbols
A and B are in pages 2 and 5, respectively:
                                 START       2040
                                 READ        B
          LOOP                   MOVER       AREG,  A
                                 SUB         AREG,  B
                                 BC          LT,   LOOP
                                 ...
                                 STOP
          A                      DS          2500
          B                      DS          1
                                 END
The page reference string and the reference time string for the process are as
follows:
          Page reference string        1, 5, 1, 2, 2, 5, 2, 1, . . .
          Reference time string        t1, t2, t3, t4, t5, t6, t7, t8, . . .
The logical address of the first instruction is 2040, and so it lies in page 1.
The first page reference in the string is therefore 1. It occurs at time instant
t1. B, the operand of the instruction is situated in page 5, and so the second
page reference in the string is 5, at time t2. The next instruction is located in
page 1 and refers to A, which is located in page 2, and thus the next two page
references are to pages 1 and 2. The next two instructions are located in page 2,
and the instruction with the label LOOP is located in page 1. Therefore, if the
value of B input to the READ statement is greater than the value of A, the next
four page references would be to pages 2, 5, 2 and 1, respectively; otherwise,
the next four page references would be to pages 2, 5, 2 and 2, respectively.
                                                                                          ·



440  Part 3  Memory Management
                   Optimal   Page  Replacement    Optimal  page  replacement  means       making       page
                   replacement decisions in such a manner that the total number of page faults
                   during operation of a process is the minimum possible; i.e., no other sequence
                   of page replacement decisions can lead to a smaller number of page faults. To
                   achieve optimal page replacement, at each page fault, the page replacement pol-
                   icy would have to consider all alternative page replacement decisions, analyze
                   their implications for future page faults, and select the best alternative. Of course,
                   such a policy is infeasible in reality: the virtual memory manager does not have
                   knowledge of the future behavior of a process. As an analytical tool, however, this
                   policy provides a useful comparison in hindsight for the performance of other
                   page replacement policies (see Example 12.6, below, and Exercise 12.5).
                   Although optimal page replacement might seem to require excessive analysis,
                   Belady (1966) showed that it is equivalent to the following simple rule: At a page
                   fault, replace the page whose next reference is farthest in the page reference string.
                   FIFO Page Replacement          At every page fault, the FIFO page replacement policy
                   replaces the page that was loaded into memory earlier than any other page of
                   the process. To facilitate FIFO page replacement, the virtual memory manager
                   records the time of loading of a page in the ref info field of its page table entry.
                   When a page fault occurs, this information is used to determine pearliest, the page
                   that was loaded earlier than any other page of the process. This is the page that
                   will be replaced with the page whose reference led to the page fault.
                   LRU Page Replacement   The LRU policy uses the law of locality of reference as
                   the basis for its replacement decisions. Its operation can be described as follows:
                   At every page fault the least recently used (LRU) page is replaced by the required
                   page. The page table entry of a page records the time when the page was last
                   referenced. This information is initialized when a page is loaded, and it is updated
                   every time the page is referenced. When a page fault occurs, this information is
                   used to locate the page pLRU whose last reference is earlier than that of every
                   other page. This page is replaced with the page whose reference led to the page
                   fault.
                   Analysis of Page Replacement Policies   Example 12.6 illustrates operation of
                   the optimal, FIFO, and LRU page replacement policies.
·
     Example 12.6  Operation of Page Replacement Policies
                   A page reference string and the reference time string for a process P are as
                   follows:
                           Page reference string  0, 1, 0, 2, 0, 1, 2, . . .                (12.4)
                           Reference time string  t1, t2, t3, t4, t5, t6, t7, . . .         (12.5)
                   Figure 12.15 illustrates operation of the optimal, FIFO and LRU page replace-
                   ment policies for this page reference string with alloc = 2. For convenience, we
                   show only two fields of the page table, valid bit and ref info. In the interval t0



                                                                                 Chapter   12  Virtual  Memory  441
                       Optimal                   FIFO                        LRU
Time     Page     Valid Ref  Replace-     Valid  Ref   Replace-     Valid Ref    Replace-
instant  ref      bit  info  ment         bit    info  ment         bit  info     ment
               0  1                    0  1      t1              0  1        t1
t1       0     1  0             -      1  0            -         1  0             -
               2  0                    2  0                      2  0
               0  1                    0  1      t1              0  1        t1
                                                 t2                          t2
t2       1     1  1             -      1  1            -         1  1             -
               2  0                    2  0                      2  0
               0  1                    0  1      t1              0  1        t1
t3       0     1  1             -      1  1      t2    -         1  1        t2   -
               2  0                    2  0                      2  0
               0  1          Replace   0  0            Replace   0  1        t3  Replace
t4       2     1  0          1 by 2    1  1      t2    0 by 2    1  0             1 by 2
               2  1                    2  1      t4              2  1        t4
               0  1                    0  1      t5    Replace   0  1        t5
t5       0     1  0             -      1  0            1 by 0    1  0             -
               2  1                    2  1      t4              2  1        t4
               0  0          Replace   0  1      t5    Replace   0  1        t5  Replace
t6       1     1  1          0 by 1    1  1      t6    2 by 1    1  1        t6   2 by 1
               2  1                    2  0                      2  0
               0  0                    0  0            Replace   0  0            Replace
t7       2     1  1             -      1  1      t6    0 by 2    1  1        t6   0 by 2
               2  1                    2  1      t7              2  1        t7
Figure 12.15  Comparison of page replacement     policies with   alloc = 2.
to t3 (inclusive), only two distinct pages are referenced: pages 0 and 1. They
can both be accommodated in memory at the same time because alloc = 2. t4
is the first time instant when a page fault leads to page replacement.
The left column shows the results for optimal page replacement. Page
reference information is not shown in the page table since information con-
cerning past references is not needed for optimal page replacement. When the
page fault occurs at time instant t4, page 1 is replaced because its next reference
is farther in the page reference string than that of page 0. At time t6 page 1
replaces page 0 because page 0's next reference is farther than that of page 2.
The middle column of Figure 12.15 shows the results for the FIFO replace-
ment policy. When the page fault occurs at time t4, the ref info field shows that
page 0 was loaded earlier than page 1, and so page 0 is replaced by page 2.
The last column of Figure 12.15 shows the results for the LRU replace-
ment policy. The ref info field of the page table indicates when a page was last
referenced. At time t4, page 1 is replaced by page 2 because the last reference
of page 1 is earlier than the last reference of page 0.



442  Part 3  Memory Management
                The total number of page faults occurring under the optimal, FIFO, and
             LRU policies are 4, 6, and 5, respectively. By definition, no other policy has
             fewer page faults than the optimal page replacement policy.
             ·
                When we analyze why the LRU policy performed better than the FIFO pol-
             icy in Example 12.6, we find that the FIFO policy removed page 0 at time t4 but
             LRU did not do so because it had been referenced later than page 1. This decision
             is consistent with the law of locality of reference, which indicates that because
             page 0 was referenced more recently than page 1, it has a higher probability of
             being referenced again than page 1. The LRU policy performed better because
             page 0 was indeed referenced earlier after time t4 than page 1 was. However, the
             LRU page replacement policy may not perform better than the FIFO policy if
             references in a page reference string do not follow the law of locality of reference.
             For example, for alloc = 3, the LRU and FIFO policies would perform identi-
             cally for the page reference string 0, 1, 2, 3, 0, 1, 2, 3, while the LRU policy would
             perform worse than the FIFO policy for the string 0, 1, 2, 0, 3, 1. However, such
             situations are not encountered frequently.
                To achieve the desirable page fault characteristic of Figure 12.6, a page
             replacement policy must possess the stack property (also called the inclusion
             property). It is defined by using the following notation:
                {pi }kn         Set of pages existing in memory at time instant tk+ if alloci = n
                                all through the operation of process proci (tk+ implies a time
                                after time instant tk but before tk+1).
                Definition 12.3 Stack Property        A page replacement policy possesses the
                stack property if
                                   {pi}nk  {pi}km     for all n, m such that n < m.
                Figure 12.16 illustrates {pi}nk for different values of n for a page replace-
             ment policy. We find that {pi}kn  {pi}nk+1 for n = 1, . . . , 4. Hence the algorithm
             possesses the stack property.
                To understand how the stack property ensures the desirable page fault char-
             acteristic of Figure 12.6, consider two runs of process proci, one with alloci = n
             all through the execution, and another with alloci = m, such that n < m. If a
                                   4               4  4    4             4
                                                   5  5    5             5
                                                      3    3             3
                                                           1             1
                                                                         2
                                   n=1      n=2       n=3  n=4           n=5
             Figure 12.16  {pi}kn for different n for a page replacement policy processing the stack property.



                                                                                Chapter 12             Virtual Memory        443
page replacement policy exhibits the stack property, then at identical points dur-
ing these operations of proci (i.e., at identical time instants) all pages that were in
memory when alloci = n would also be in memory when alloci = m. In addition,
memory also contains m - n other pages of the process. If any of these pages are
referenced in the next few page references of proci, page faults occur if alloci = n,
but  not  if alloci  =  m.    Thus   the page fault rate is higher if   alloci     =  n  than if
alloci = m. This satisfies the page fault characteristic of Figure 12.6. The page
fault rates will be identical if these m - n pages are not referenced in the next few
page references. However, in no case will the page fault rate increase when the
memory allocation for a process is increased. If a page replacement policy does
not exhibit the stack property, then {pi}mk may not contain some page(s) contained
in {pi}nk. References to these pages would result in page faults. Hence the page
fault rate can increase when the memory allocation for a process is increased.
     Example 12.7 illustrates that the FIFO page replacement policy does not
exhibit the stack property. One can prove that the LRU page replacement policy
exhibits the stack property (see Exercise 12.9).
                                                                                                                             ·
Problems in FIFO Page Replacement                                                                          Example     12.7
Consider the following page reference and reference time strings for a process:
     Page reference string           5, 4, 3, 2, 1, 4, 3, 5, 4, 3, 2, 1, 5, . . .          (12.6)
     Reference time string           t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, . . .
                                                                                           (12.7)
Figure 12.17 shows operation of the FIFO and LRU page replacement policies
for this page reference string. Page references that cause page faults and result
in page replacement are marked with a  mark. A column of boxes is associated
with each time instant. Each box is a page frame; the number contained in
it indicates which page occupies it after execution of the memory reference
marked under the column.
      For FIFO page replacement, we have {pi}412 = {2, 1, 4, 3}, while {pi}132 =
{1, 5, 2}. Thus, FIFO page replacement does not exhibit the stack property.
This      leads  to  a  page  fault  at  t13  when  alloci  =  4,  but  not  when  alloci           =  3.
Thus, a total of 10 page faults arise in 13 time instants when alloci = 4, while
9 page faults arise when alloci = 3. For LRU, we see that {pi}3  {pi}4 at all
time instants.
                                                                                                       ·
     Figure 12.18 illustrates the page fault characteristic of FIFO and LRU page
replacement for page reference string (12.6). For simplicity, the vertical axis
shows the total number of page faults rather than the page fault frequency.
Figure 12.18(a) illustrates an anomaly in behavior of FIFO page replacement--
the number of page faults increases when memory allocation for the process is
increased. This anomalous behavior was first reported by Belady and is therefore
known as Belady's anomaly.



444  Part 3  Memory Management
                              FIFO      alloci =  3                3   3   3   4    4      4   4    4     2       2  2
                                                            4      4   4   1   1    1      5   5    5     5       5  5
                                                     5      5      5   2   2   2    3      3   3    3     3       1  1
                                                     5      4*     3*  2*  1*  4*   3*     5*  4    3     2*   1*    5
                                        alloci =  4                    2   2   2    2      2   2    3     3       3  3
                                                                   3   3   3   3    3      3   4    4     4       4  5
                                                            4      4   4   4   4    4      5   5    5     5       1  1
                                                     5      5      5   5   1   1    1      1   1    1     2       2  2
                                                     5      4*     3*  2*  1*  4    3      5*  4*   3*    2*   1*    5*
                                     Time line       t1     t2     t3  t4  t5  t6   t7     t8  t9   t10   t11  t12   t13
                              LRU       alloci =  3                3   3   3   4    4      4   4    4     4       1  1
                                                            4      4   4   1   1    1      5   5    5     2       2  2
                                                     5      5      5   2   2   2    3      3   3    3     3       3  5
                                                     5      4*     3*  2*  1*  4*   3*     5*  4    3     2*   1*    5*
                                        alloci =  4                    2   2   2    2      5   5    5     5       1  1
                                                                   3   3   3   3    3      3   3    3     3       3  3
                                                            4      4   4   4   4    4      4   4    4     4       4  5
                                                     5      5      5   5   1   1    1      1   1    1     2       2  2
                                                     5      4*     3*  2*  1*  4    3      5*  4    3     2*   1*    5*
                                     Time line
                                                     t1     t2     t3  t4  t5  t6   t7     t8  t9   t10   t11  t12   t13
             Figure 12.17     Performance of      FIFO      and  LRU page      replacement.
                              14                                                    14
                              12                                                    12
             Number 10                                                     Number 10
                              8                                                         8
                     of page                                               of page
                              6                                                         6
                     faults                                                faults
                              4                                                         4
                              2                                                         2
                                  0  1  2         3      4      5                          0   1       2       3     4    5
                                        FIFO                alloc                                        LRU              alloc
             Figure  12.18    (a) Belady's anomaly in FIFO             page replacement;       (b)  page fault       characteristic  for
             LRU page replacement.
             The virtual memory manager cannot use FIFO page replacement because
             increasing the allocation to a process may increase the page fault frequency of the
             process. This feature would make it difficult to combat thrashing in the system.
             However, when LRU page replacement is used, the number of page faults is
             a nonincreasing function of alloc. Hence it is possible to combat thrashing by
             increasing the value of alloc for each process.
             12.4.1 Practical Page Replacement Policies
             Figure 12.19 shows a schematic diagram of a practical virtual memory manager.
             The virtual memory manager maintains a free frames list and tries to keep a
             few page frames in this list at all times. The virtual memory manager consists



                                                                           Chapter 12    Virtual Memory  445
                                              Virtual
                                              memory
                                              manager
              Page                   Free                      Page
              fault                  frames                    I/O
              handler                manager           manager
                       Page tables           Free frames list        Swap
                                                                     disk
Figure 12.19  Page replacement in practice.
of two daemon threads. The thread called free frames manager is activated by
the virtual memory manager when the number of free page frames drops below
a threshold defined by the virtual memory manager. The free frames manager
scans the pages present in memory to identify a few pages that can be freed, and
adds the page frames occupied by these pages to the free frames list. If the page
contained in a newly added page frame is dirty, it marks the page frame as dirty
in the free frames list. It also resets the valid bit of this page in the page table of
the process to which it belongs. The free frames manager puts itself to sleep when
the number of free page frames exceeds another threshold of the virtual memory
manager. The thread called page I/O manager performs page-out operations on
dirty page frames in the free frames list; it resets the dirty bit of a page frame
when its page-out operation is completed.
The page fault handler runs as an event handler of the kernel. It is activated
when a page fault occurs. It first checks whether the required page exists in any of
the page frames in the free frames list. If so, it simply reclaims the page by removing
its page frame from the free frames list, setting the valid bit of the page in the page
table of the process and copying the value of the dirty bit of the page frame into
the modified bit of the page. This operation makes the required page available
without having to perform a page-in operation. If the required page does not
exist in any page frame, it takes a clean page frame off the free frames list and
starts the page-in operation on it.
Effectively, the page replacement policy is implemented in the free frames
manager of the virtual memory manager; however, in the following we will dis-
cuss page replacement as if it were done directly by the virtual memory manager.
The LRU page replacement policy should be the automatic choice for imple-
mentation in a virtual memory manager because it exhibits the stack property.
However, LRU page replacement is not feasible because computers do not pro-
vide sufficient bits in the ref info field to store the time of last reference--most
computers provide a single reference bit for collecting information about refer-
ences to a page. Therefore page replacement policies have to be implemented



446  Part 3  Memory Management
                   using only the reference bit. This requirement has led to a class of policies called
                   not recently used (NRU) policies, where the reference bit is used to determine
                   whether a page has been recently referenced, and some page that has not been
                   recently referenced is replaced.
                   A simple NRU policy is as follows: The reference bit of a page is initialized
                   to 0 when the page is loaded, and it is set to 1 when the page is referenced. When
                   page replacement becomes necessary, if the virtual memory manager finds that
                   the reference bits of all pages have become 1, it resets the bits of all pages to 0
                   and arbitrarily selects one of the pages for replacement; otherwise, it replaces a
                   page whose reference bit is 0. Future page replacement would depend on which
                   of the pages were referenced after the reference bits were reset. Page replacement
                   algorithms called clock algorithms provide better discrimination between pages
                   by resetting reference bits of pages periodically, rather than only when all of them
                   become 1, so that it would be possible to know whether a page has been referenced
                   in the immediate past, say within the past 100 instructions, rather than since the
                   time when all reference bits were reset to 0.
                   Clock Algorithms    In clock algorithms, pages of all processes in memory are
                   entered in a circular list and pointers used by the algorithms move over the pages
                   repeatedly. The algorithms get their name from the fact that movement of the
                   pointers is analogous to movement of the hands of a clock over the clock dial.
                   The page pointed to by a pointer is examined, a suitable action is performed on
                   it, and the pointer is advanced to point to the next page. The clock algorithms
                   can also be applied at the level of a single process when the memory allocation
                   for a process is to be decreased. In this case, the virtual memory manager would
                   maintain a separate list of pages for each process and the clock algorithm would
                   scan only the list of the process whose memory allocation is to be decreased.
                   In the one-handed clock algorithm, a scan consists of two passes over all
                   pages. In the first pass, the virtual memory manager simply resets the reference
                   bit of the page pointed to by the pointer. In the second pass it finds all pages
                   whose reference bits are still off and adds them to the free list. In the two-handed
                   clock algorithm, two pointers are maintained. One pointer, which we will call the
                   resetting pointer (RP), is used for resetting the reference bits and the other pointer,
                   which we will call the examining pointer (EP), is used for checking the reference
                   bits. Both pointers are incremented simultaneously. The page frame to which the
                   checking pointer points is added to the free frames list if its reference bit is off.
                   Example 12.8 describes operation of the two-handed clock algorithm.
·
     Example 12.8  Two-Handed Clock Algorithm
                   Figure 12.20 illustrates operation of the two-handed clock algorithm when
                   used  by  the free  frames  manager  of  Figure  12.19.  The ref  mark  against     a
                   page implies that the reference bit of the page is set to 1; absence of this
                   mark implies that the reference bit is 0. When the free frames manager is
                   activated, it examines page 7, which is pointed to by the examining pointer
                   [see Figure 12.20(a)]. Its reference bit is 1, so both the resetting and examining
