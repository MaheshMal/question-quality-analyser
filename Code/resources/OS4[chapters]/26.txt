Introduction


                                                                   Chapte                r  1
Introduction
T he way you would define an operating system probably depends on what
     you expect from your computer system. Each user has his own personal
     thoughts on what the computer system is for. In technical language, we
would say that an individual user has an abstract view of the computer system, a
view that takes in only those features that the user considers important.
     The operating system, or OS, as we will often call it, is the intermediary
between     users  and  the  computer  system.  It  provides  the  services  and   fea-
tures present in abstract views of all its users through the computer system.
It also enables the services and features to evolve over time as users' needs
change.
     People who design operating systems have to deal with three issues: effi-
cient use of the computer system's resources, the convenience of users, and
prevention of interference with users' activities. Efficient use is more impor-
tant when a computer system is dedicated to specific applications, and user
convenience is more important in personal computers, while both are equally
important when a computer system is shared by several users. Hence, the designer
aims for the right combination of efficient use and user convenience for the
operating system's environment. Prevention of interference is mandatory in all
environments.
     We will now take a broad look at what makes an operating system work--
we will see how its functions of program management and resource management
help to ensure efficient use of resources and user convenience, and how the
functions of security and protection prevent interference with programs and
resources.
1.1  ABSTRACT VIEWS OF AN OPERATING SYSTEM                                         ·
A question such as "What is an OS?" is likely to evoke different answers, depend-
ing on the user's interest. For example,
· To a school or college student, the OS is the software that permits access to
     the Internet.
· To a programmer, the OS is the software that makes it possible to develop
     programs on a computer system.
                                                                                               5



6  Part 1  Overview
           ·         To a user of an application package, the OS is simply the software that makes
                     it possible to use the package.
           ·         To a technician in, say, a computerized chemical plant, the OS is the invisible
                     component of a computer system that controls the plant.
                     A user perceives an OS as simply a means of achieving an intended use of
           a computer system. For the student, the sole purpose of the computer system is
           to get onto the Internet; the OS helps in achieving this. Hence the student thinks
           of the operating system as the means for Internet browsing. The programmer,
           the user of a package, and the technician similarly identify the OS with their
           particular purposes in using the computer. Since their purposes are different,
           their perceptions of the OS are also different.
                     Figure 1.1 illustrates the four views of an OS we have just considered. They
           are abstract views, because each focuses on those characteristics considered essen-
           tial from the perspective of the individual viewer--it includes some elements of
           reality but ignores other elements. The student, the application user, and the tech-
           nician are end users of the OS; their views do not contain any features of the OS.
           The programmer's view is that of a software developer. It includes features of the
           OS for software development.
                     An OS designer has his own abstract view of the OS, which shows the struc-
           ture of an OS and the relationship between its component parts. Figure 1.2
                          Internet
                     (a)                              (b)
                          Stock quotes
                     (c)                              (d)
           Figure 1.1     Abstract views of an OS: a student's, a programmer's, an application user's and a
           technician's.



                                                            Chapter 1                 Introduction  7
                                        User
                                      User interface
                                      Nonkernel routines
                                        Kernel
                                      Computer hardware
Figure  1.2  A  designer's  abstract  view of an OS.
illustrates this view. Each part consists of a number of routines. The typical
functionalities of these parts are as follows:
·  User interface: The user interface accepts commands to execute programs
   and use resources and services provided by the operating system. It is either
   a command line interface, as in Unix or Linux, which displays a command
   prompt to the user and accepts a user command, or is a graphical user inter-
   face (GUI), as in the Windows operating system, which interprets mouse
   clicks on icons as user commands.
·  Nonkernel routines: These routines implement user commands concerning
   execution of programs and use of the computer's resources; they are invoked
   by the user interface.
·  Kernel: The kernel is the core of the OS. It controls operation of the computer
   and provides a set of functions and services to use the CPU, memory, and
   other resources of the computer. The functions and services of the kernel are
   invoked by the nonkernel routines and by user programs.
   Two features of an OS emerge from the designer's view of an OS shown in
Figure 1.2. The OS is actually a collection of routines that facilitate execution of
user programs and use of resources in a computer system. It contains a hierar-
chical arrangement of layers in which routines in a higher layer use the facilities
provided by routines in the layer below it. In fact, each layer takes an abstract
view of the layer below it, in which the next lower layer is a machine that can
understand certain commands. The fact that the lower layer is a set of routines
rather than a whole computer system makes no difference to the higher layer.
Each higher layer acts as a more capable machine than the layer below it. To the
user, the user interface appears like a machine that understands commands in the
command language of the OS.
   Throughout this book, we will use abstract views to present the design of OS
components. This has two key benefits:
·  Managing complexity: An abstract view of a system contains only selected
   features of the system. This property is useful in managing complexity during
   design or study of a system. For example, an abstract view of how an OS



8  Part 1  Overview
                     organizes execution of user programs (Figure 1.3 illustrates such a view later
                     in this chapter), focuses only on handling of programs; it simplifies a study
                     of this aspect of the OS by not showing how the OS handles other resources
                     like memory or I/O devices.
           ·         Presenting a generic scheme: An abstraction is used to present a generic
                     scheme that has many variants in practice. We see two examples of this use
                     in the designer's abstract view of Figure 1.2. The user interface is an abstrac-
                     tion, with a command line interface and a graphical user interface (GUI) as
                     two of its many variants. The kernel typically presents an abstraction of the
                     computer system to the nonkernel routines so that the diversity of hardware,
                     e.g., different models of CPUs and different ways of organizing and accessing
                     data in disks, is hidden from view of the nonkernel routines.
           1.2       GOALS OF AN OS                                                                    ·
           The fundamental goals of an operating system are:
           ·         Efficient use: Ensure efficient use of a computer's resources.
           ·         User convenience: Provide convenient methods of using a computer system.
           ·         Noninterference: Prevent interference in the activities of its users.
                     The goals of efficient use and user convenience sometimes conflict. For exam-
           ple, emphasis on quick service could mean that resources like memory have to
           remain allocated to a program even when the program is not in execution; how-
           ever, it would lead to inefficient use of resources. When such conflicts arise, the
           designer has to make a trade-off to obtain the combination of efficient use and
           user convenience that best suits the environment. This is the notion of effective
           utilization of the computer system. We find a large number of operating systems
           in use because each one of them provides a different flavor of effective utilization.
           At one extreme we have OSs that provide fast service required by command and
           control applications, at the other extreme we have OSs that make efficient use of
           computer resources to provide low-cost computing, while in the middle we have
           OSs that provide different combinations of the two.
                     Interference with a user's activities may take the form of illegal use or mod-
           ification of a user's programs or data, or denial of resources and services to a
           user. Such interference could be caused by both users and nonusers, and every
           OS must incorporate measures to prevent it.
                     In the following, we discuss important aspects of these fundamental goals.
           1.2.1 Efficient Use
           An operating system must ensure efficient use of the fundamental computer sys-
           tem resources of memory, CPU, and I/O devices such as disks and printers. Poor
           efficiency can result if a program does not use a resource allocated to it, e.g.,



                                                                            Chapter 1  Introduction  9
if memory or I/O devices allocated to a program remain idle. Such a situation
may have a snowballing effect: Since the resource is allocated to a program, it
is denied to other programs that need it. These programs cannot execute, hence
resources allocated to them also remain idle. In addition, the OS itself consumes
some CPU and memory resources during its own operation, and this consump-
tion of resources constitutes an overhead that also reduces the resources available
to user programs. To achieve good efficiency, the OS must minimize the waste of
resources by programs and also minimize its own overhead.
Efficient use of resources can be obtained by monitoring use of resources
and performing corrective actions when necessary. However, monitoring use of
resources increases the overhead, which lowers efficiency of use. In practice, oper-
ating systems that emphasize efficient use limit their overhead by either restricting
their focus to efficiency of a few important resources, like the CPU and the mem-
ory, or by not monitoring the use of resources at all, and instead handling user
programs and resources in a manner that guarantees high efficiency.
1.2.2 User Convenience
User convenience has many facets, as Table 1.1 indicates. In the early days of
computing, user convenience was synonymous with bare necessity--the mere
ability to execute a program written in a higher level language was considered
adequate. Experience with early operating systems led to demands for better
service, which in those days meant only fast response to a user request.
Other facets of user convenience evolved with the use of computers in new
fields. Early operating systems had command-line interfaces, which required a
user to type in a command and specify values of its parameters. Users needed
substantial training to learn use of the commands, which was acceptable because
most users were scientists or computer professionals. However, simpler inter-
faces were needed to facilitate use of computers by new classes of users. Hence
graphical user interfaces (GUIs) were evolved. These interfaces used icons on
a screen to represent programs and files and interpreted mouse clicks on the
icons and associated menus as commands concerning them. In many ways, this
move can be compared to the spread of car driving skills in the first half of
Table 1.1     Facets of User Convenience
Facet                     Examples
Fulfillment of necessity  Ability to execute programs, use the file system
Good Service              Speedy response to computational requests
User friendly interfaces  Easy-to-use commands, graphical user interface (GUI)
New programming model     Concurrent programming
Web-oriented features     Means to set up Web-enabled servers
Evolution                 Add new features, use new computer technologies



10  Part 1  Overview
            the twentieth century. Over a period of time, driving became less of a spe-
            cialty and more of a skill that could be acquired with limited training and
            experience.
                      Computer users attacked new problems as computing power increased. New
            models were proposed for developing cost-effective solutions to new classes of
            problems. Some of these models could be supported by the compiler technology
            and required little support from the OS; modular and object-oriented program
            design are two such models. Other models like the concurrent programming
            model required specific support features in the OS. Advent of the Internet moti-
            vated setting up of Web-enabled servers, which required networking support and
            an ability to scale up or scale down the performance of a server in response to
            the amount of load directed at it.
                      Users and their organizations invest considerable time and effort in setting
            up their applications through an operating system. This investment must be
            protected when new application areas and new computer technologies develop,
            so operating systems need to evolve to provide new features and support new
            application areas through new computer technologies.
            1.2.3 Noninterference
            A computer user can face different kinds of interference in his computational
            activities. Execution of his program can be disrupted by actions of other persons,
            or the OS services which he wishes to use can be disrupted in a similar manner.
            The OS prevents such interference by allocating resources for exclusive use of
            programs and OS services, and preventing illegal accesses to resources. Another
            form of interference concerns programs and data stored in user files.
                      A computer user may collaborate with some other users in the development
            or use of a computer application, so he may wish to share some of his files with
            them. Attempts by any other person to access his files are illegal and constitute
            interference. To prevent this form of interference, an OS has to know which files
            of a user can be accessed by which persons. It is achieved through the act of
            authorization, whereby a user specifies which collaborators can access what files.
            The OS uses this information to prevent illegal accesses to files.
            1.3       OPERATION OF AN OS                                                            ·
            The primary concerns of an OS during its operation are execution of programs,
            use of resources, and prevention of interference with programs and resources.
            Accordingly, its three principal functions are:
            ·         Program management: The OS initiates programs, arranges their execution
                      on the CPU, and terminates them when they complete their execution. Since
                      many programs exist in the system at any time, the OS performs a function
                      called scheduling to select a program for execution.



                                                                       Chapter 1     Introduction  11
·  Resource management: The OS allocates resources like memory and I/O
   devices when a program needs them. When the program terminates, it deal-
   locates these resources and allocates them to other programs that need
   them.
·  Security and protection: The OS implements noninterference in users' activ-
   ities through joint actions of the security and protection functions. As an
   example, consider how the OS prevents illegal accesses to a file. The secu-
   rity function prevents nonusers from utilizing the services and resources in
   the computer system, hence none of them can access the file. The protection
   function prevents users other than the file owner or users authorized by him,
   from accessing the file.
   Table 1.2 describes the tasks commonly performed by an operating system.
When a computer system is switched on, it automatically loads a program stored
on a reserved part of an I/O device, typically a disk, and starts executing the
program. This program follows a software technique known as bootstrapping to
load the software called the boot procedure in memory--the program initially
loaded in memory loads some other programs in memory, which load other
programs, and so on until the complete boot procedure is loaded. The boot
procedure makes a list of all hardware resources in the system, and hands over
control of the computer system to the OS.
   A system administrator specifies which persons are registered as users of the
system. The OS permits only these persons to log in to use its resources and
services. A user authorizes his collaborators to access some programs and data.
The OS notes this information and uses it to implement protection. The OS also
performs a set of functions to implement its notion of effective utilization. These
functions include scheduling of programs and keeping track of resource status
and resource usage information.
Table 1.2  Common Tasks Performed by Operating Systems
Task                                  When performed
Construct a list of resources         During booting
Maintain information for security     While registering new users
Verify identity of a user             At login time
Initiate execution of programs        At user commands
Maintain authorization information    When a user specifies which collaborators
                                      can acces what programs or data
Perform resource allocation           When requested by users or programs
Maintain current status of resources  During resource allocation/deallocation
Maintain current status of programs   Continually during OS operation
and perform scheduling



12  Part 1  Overview
                      The following sections are a brief overview of OS responsibilities in managing
            programs and resources and in implementing security and protection.
            1.3.1 Program Management
            Modern CPUs have the capability to execute program instructions at a very high
            rate, so it is possible for an OS to interleave execution of several programs on a
            CPU and yet provide good user service. The key function in achieving interleaved
            execution of programs is scheduling, which decides which program should be
            given the CPU at any time. Figure 1.3 shows an abstract view of scheduling. The
            scheduler, which is an OS routine that performs scheduling, maintains a list of
            programs waiting to execute on the CPU, and selects one program for execution.
            In operating systems that provide fair service to all programs, the scheduler also
            specifies how long the program can be allowed to use the CPU. The OS takes
            away the CPU from a program after it has executed for the specified period of
            time, and gives it to another program. This action is called preemption. A program
            that loses the CPU because of preemption is put back into the list of programs
            waiting to execute on the CPU.
                      The scheduling policy employed by an OS can influence both efficient use of
            the CPU and user service. If a program is preempted after it has executed for only
            a short period of time, the overhead of scheduling actions would be high because
            of frequent preemption. However, each program would suffer only a short delay
            before it gets an opportunity to use the CPU, which would result in good user
            service. If preemption is performed after a program has executed for a longer
            period of time, scheduling overhead would be lesser but programs would suffer
            longer delays, so user service would be poorer.
            1.3.2 Resource Management
            Resource allocations and deallocations can be performed by using a resource
            table. Each entry in the table contains the name and address of a resource unit
            and its present status, indicating whether it is free or allocated to some program.
            Table 1.3 is such a table for management of I/O devices. It is constructed by the
            boot procedure by sensing the presence of I/O devices in the system, and updated
            by the operating system to reflect the allocations and deallocations made by it.
            Since any part of a disk can be accessed directly, it is possible to treat different parts
                                                 Preempted program
                      New      ...                  Scheduler                 CPU  Completed
                      program  Programs waiting                                    program
                               for the CPU                          Selected
                                                                    program
            Figure 1.3  A schematic of scheduling.



                                                                          Chapter      1  Introduction  13
Table 1.3              Resource Table for I/O Devices
    Resource name      Class              Address      Allocation status
    printer1           Printer            101          Allocated to P1
    printer2           Printer            102          Free
    printer3           Printer            103          Free
    disk1              Disk               201          Allocated to P1
    disk2              Disk               202          Allocated to P2
    cdw1               CD writer          301          Free
of a disk as independent devices. Thus the devices disk1 and disk2 in Table 1.3
could be two parts of the same disk.
Two resource allocation strategies are popular. In the resource partitioning
approach, the OS decides a priori what resources should be allocated to each
user program, for example, it may decide that a program should be allocated
1 MB of memory, 1000 disk blocks, and a monitor. It divides the resources in the
system into many resource partitions, or simply partitions; each partition includes
1 MB of memory, 1000 disk blocks, and a monitor. It allocates one resource
partition to each user program when its execution is to be initiated. To facilitate
resource allocation, the resource table contains entries for resource partitions
rather than for individual resources as in Table 1.3. Resource partitioning is
simple to implement, hence it incurs less overhead; however, it lacks flexibility.
Resources are wasted if a resource partition contains more resources than what a
program needs. Also, the OS cannot execute a program if its requirements exceed
the resources available in a resource partition. This is true even if free resources
exist in another partition.
In  the    pool-based  approach       to  resource  management,  the  OS  allocates
resources from a common pool of resources. It consults the resource table when
a program makes a request for a resource, and allocates the resource if it is free.
It incurs the overhead of allocating and deallocating resources when requested.
However, it avoids both problems faced by the resource partitioning approach--
an allocated resource is not wasted, and a resource requirement can be met if a
free resource exists.
Virtual Resources      A virtual resource is a fictitious resource--it is an illusion
supported by an OS through use of a real resource. An OS may use the same real
resource to support several virtual resources. This way, it can give the impression
of having a larger number of resources than it actually does. Each use of a virtual
resource results in the use of an appropriate real resource. In that sense, a virtual
resource is an abstract view of a resource taken by a program.
Use of virtual resources started with the use of virtual devices. To prevent
mutual interference between programs, it was a good idea to allocate a device
exclusively for use by one program. However, a computer system did not possess
many real devices, so virtual devices were used. An OS would create a virtual
device when a user needed an I/O device; e.g., the disks called disk1 and disk2 in



14  Part 1  Overview
            Table 1.3 could be two virtual disks based on the real disk, which are allocated
            to programs P1 and P2, respectively. Virtual devices are used in contemporary
            operating systems as well. A print server is a common example of a virtual device.
            When a program wishes to print a file, the print server simply copies the file into the
            print queue. The program requesting the print goes on with its operation as if the
            printing had been performed. The print server continuously examines the print
            queue and prints the files it finds in the queue. Most operating systems provide
            a virtual resource called virtual memory, which is an illusion of a memory that is
            larger in size than the real memory of a computer. Its use enables a programmer
            to execute a program whose size may exceed the size of real memory.
                      Some operating systems create virtual machines (VMs) so that each machine
            can be allocated to a user. The advantage of this approach is twofold. Allocation
            of a virtual machine to each user eliminates mutual interference between users. It
            also allows each user to select an OS of his choice to operate his virtual machine.
            In effect, this arrangement permits users to use different operating systems on
            the same computer system simultaneously (see Section 4.5).
            1.3.3 Security and Protection
            As mentioned in Section 1.2.3, an OS must ensure that no person can illegally
            use programs and resources in the system, or interfere with them in any manner.
            The security function counters threats of illegal use or interference that are posed
            by persons or programs outside the control of an operating system, whereas
            the protection function counters similar threats posed by its users. Figure 1.4
            illustrates how security and protection threats arise in an OS.
                      In a classical stand-alone environment, a computer system functions in com-
            plete isolation. In such a system, the security and protection issues can be handled
            easily. Recall that an OS maintains information that helps in implementing the
            security and protection functions (see Table 1.2). The identity of a person wish-
            ing to use a computer system is verified through a password when the person
            logs in. This action, which is called authentication, ensures that no person other
                                                                      Computer system
                                  Security  Resources
                        Intruder  threats
                                                                                       Protection
                                                                                       threats
                                  Internet
                                            Programs
                                            Authentication                             Users
            Figure 1.4  Overview of security and protection threats.



                                                   Chapter 1                           Introduction  15
than a registered user can use a computer system. Consequently, security threats
do not arise in the system if the authentication procedure is foolproof. In this
environment, the forms of interference mentioned earlier in Section 1.2.3 are all
protection threats. The OS thwarts disruption of program executions and OS
services with the help of hardware features such as memory protection. It thwarts
interference with files by allowing a user to access a file only if he owns it or has
been authorized by the file's owner to access it.
     When a computer system is connected to the Internet, and a user downloads
a program from the Internet, there is a danger that the downloaded program
may interfere with other programs or resources in the system. This is a security
threat because the interference is caused by some person outside the system,
called an intruder, who either wrote the downloaded program, or modified it,
so that it would interfere with other programs. Such security threats are posed
either through a Trojan horse, which is a program that has a known legitimate
function and a well-disguised malicious function, or a virus, which is a piece
of code with a malicious function that attaches itself to other programs in the
system and spreads to other systems when such programs are copied. Another
class of security threats is posed by programs called worms, which replicate by
themselves through holes in security setups of operating systems. Worms can
replicate at unimaginably high rates and cause widespread havoc. The Code Red
worm of 2001 spread to a quarter of a million computer systems in 9 hours.
     Operating systems address security threats through a variety of means--by
using sophisticated authentication techniques, by plugging security holes when
they are discovered, by ensuring that programs cannot be modified while they are
copied over the Internet, and by using Internet firewalls to filter out unwanted
Internet traffic through a computer system. Users are expected to contribute to
security by using passwords that are impossible to guess and by exercising caution
while downloading programs from the Internet.
1.4  PREVIEW OF THE BOOK                                                                             ·
A computer system, the services it provides to its users and their programs, and its
interfaces with other systems all make up the computing environment. Operating
systems are designed to provide effective utilization of a computer system in its
computing environment, which is the appropriate combination of efficient use
of resources and good user service in the computing environment, and to ensure
noninterference in the activities of its users. Parts 1­4 of this book primarily dis-
cuss operating systems for conventional computing environments characterized
by use of a single computer system having a single CPU; only Chapter 10 discusses
operating systems for the multiprocessor computing environment. Operating sys-
tems for the distributed computing environment are discussed in the chapters of
Part 5.
     All through this book, we will use abstract views to present the design and
implementation of operating systems because, as discussed in Section 1.1, abstract
views help in managing complexity and presenting generic concepts or ideas.



16  Part 1  Overview
            1.4.1 Introduction to Operating Systems
            Part 1 of the book consists of Chapters 1­4, of which the present chapter is
            Chapter 1. We begin the study of operating systems in Chapter 2 with a discussion
            of how an operating system interacts with the computer and with user programs.
            Events and Interrupts      An OS interleaves execution of several user programs on
            the CPU. While a user program is in execution, some situations concerning its
            own activity, or concerning activities in other programs, may require attention
            of the OS. Hence, occurrence of an event, which is any situation that requires
            attention of the OS, causes control of the CPU to be passed to the operating
            system. The operating system uses the CPU to execute instructions that analyze
            the event and perform appropriate actions. When an event has been attended to,
            the OS schedules a user program for execution on the CPU. Hence operation of
            the OS is said to be event driven. For example, if an I/O operation ends, the OS
            informs the program that had requested the I/O operation and starts another I/O
            operation on the device, if one is pending; if a program requests a resource, the
            OS allocates the resource if it is available. In either case, it performs scheduling to
            select the program to be executed next. Figure 1.5 is an abstract view, also called
            a logical view, of the functioning of an operating system.
                      The end of an I/O operation or the making of a resource request by a program
            actually causes an interrupt in the computer system. The CPU is designed to
            recognize an interrupt and divert itself to the OS. This physical view, which is the
            foundation for a study of operating systems, is developed in Chapter 2.
            Effective Utilization of a Computer System              Computing environments evolved in
            response to advances in computer architecture and new requirements of computer
            users. Each computing environment had a different notion of effective utilization,
            so its OS used a different set of techniques to realize it. A modern comput-
            ing environment contains features of several classical computing environments,
            such as noninteractive, time-sharing, and distributed computing environments,
            so techniques employed in these environments are used in modern OSs as well.
            Chapter 3 discusses these techniques to form the background for a detailed study
            of operating systems.
                                                         Operating
                                                         system
                                               Event                Event
                                               Computer             User
                                               system               programs
                                               Computing environment
            Figure 1.5  An  operating  system  in its computing environment.



                                                                      Chapter 1       Introduction  17
Portability  and     Extensibility   of  Operating  Systems  Early operating systems
were developed for specific computer systems, so they were tightly integrated
with architectures of specific computer systems. Modern operating systems
such as Unix and Windows pose two new requirements--the operating sys-
tem has to be portable, that is, it should be possible to implement it on many
computer architectures, and it should be extensible so that it can meet new
requirements arising from changes in the nature of its computing environment.
Chapter 4 discusses the operating system design techniques for portability and
extensibility.
1.4.2 Managing User Computations
Chapters 5­10, which constitute Part 2 of the book, discuss various facets of the
program management function. Chapter 5 lays the foundation of this study by
discussing how the operating system handles execution of programs.
Processes and Threads         A process is an execution of a program. An OS uses
a process as a unit of computational work--it allocates resources to a process
and schedules it for servicing by the CPU. It performs process switching when it
decides to preempt a process and schedule another one for servicing by the CPU
(see Figure 1.3). Process switching involves saving information concerning the
preempted process and accessing information concerning the newly scheduled
process; it consumes some CPU time and constitutes overhead of the operat-
ing system. The notion of a thread is introduced to reduce the OS overhead.
Switching between threads requires much less information to be stored and
accessed compared with switching between processes. However, processes and
threads are similar in other respects, so we use the term process as a generic term
for both a process and a thread, except while discussing the implementation of
threads.
Process Synchronization       Processes that have a common goal must coordinate
their activities so that they can perform their actions in a desired order. This
requirement is called process synchronization. Figure 1.6 illustrates two kinds of
process synchronization. Figure 1.6(a) shows processes named credit and debit
that access the balance in a bank account. Their results may be incorrect if both
processes update the balance at the same time, so they must perform their updates
strictly one after another. Figure 1.6(b) shows a process named generate that
             Credit           Debit
                                         Generate            Analyze
                     Balance                        Sample
             (a)                         (b)
Figure  1.6  Two kinds of process synchronization.



18  Part 1  Overview
            produces some data and puts it into a variable named sample, and the process
            named analyze that performs analysis on the data contained in variable sam-
            ple. Here, process analyze should not perform analysis until process generate has
            deposited the next lot of data in sample, and process generate should not produce
            the next lot of data until process analyze has analyzed the previous data. Program-
            ming languages and operating systems provide several facilities that processes may
            use for performing synchronization. Chapter 6 describes these facilities, their use
            by processess and their implementation in an OS.
            Message Passing  Processes may also interact through message passing. When
            a process sends some information in a message to another process, the operating
            system stores the message in its own data structures until the destination process
            makes a request to receive a message. Unlike the situation in Figure 1.6(b), syn-
            chronization of sender and destination processes is performed by the operating
            system--it makes the destination process wait if no message has been sent to it
            by the time it makes a request to receive a message. Details of message passing
            are described in Chapter 9.
            Scheduling  The nature of a computing environment decides whether effective
            utilization of a computer system implies efficient use of its resources, high user
            convenience, or a suitable combination of both. An OS realizes effective utiliza-
            tion through a scheduling policy that shares the CPU among several processes.
            This way, many processes make progress at the same time, which contributes to
            quick service for all users, and hence to high user convenience. The manner in
            which the CPU is shared among processes governs the use of resources allocated
            to processes, so it governs efficient use of the computer system. In Chapter 7, we
            discuss the classical scheduling policies, which aimed either at efficient use of a
            computer system, or at high user convenience, and scheduling policies used in
            modern operating systems, which aim at suitable combinations of efficient use
            and user convenience.
            Deadlocks   User processes share a computer system's resources. If a resource
            requested by some process Pi is currently allocated to process Pj, Pi has to wait
            until Pj releases the resource. Such waits sometimes cause a deadlock, which
            is a situation in which processes wait for other processes' actions indefinitely.
            Figure 1.7 illustrates such a situation. The arrow drawn from process Pi to Pj
            indicates that process Pi is waiting because it requested a resource that is cur-
            rently allocated to process Pj. Processes Pj and Pk similarly wait for resources
            that are currently allocated to processes Pk and Pi, respectively. Hence the three
            processes are in a deadlock. A deadlock adversely affects performance of a sys-
            tem because processes involved in the deadlock cannot make any progress and
            resources allocated to them are wasted. We discuss deadlock handling techniques
            used in operating systems in Chapter 8.
            Multiprocessor  Operating    Systems     A  multiprocessor  computer  system         can
            provide high performance because its CPUs can service several processes simulta-
            neously. It can also speed up operation of a computer application if its processes
            are scheduled simultaneously on several CPUs. To realize these advantages, the



                                                                                  Chapter 1  Introduction  19
                                        Pk
                Pk requires a resource                   Pj requires a  resource
                allocated to Pi                          allocated      to Pk
                Pi                                       Pj
                                 Pi requires a resource
                                        allocated to Pj
Figure 1.7  A  deadlock involving three processes.
operating system has to use special scheduling and synchronization techniques
to ensure that processes can operate efficiently and harmoniously on the CPUs.
We discuss these techniques in Chapter 10.
1.4.3 Management of Memory
Memory management involves efficient allocation, release and reuse of memory
to meet requests of processes. In the classical model of memory allocation, a single
contiguous area of memory is allocated to a process. This model does not support
reuse of a memory area that is not large enough to accommodate a new process,
so the kernel has to use the technique of compaction to combine several free areas
of memory into one large free area of memory; it incurs substantial overhead. The
noncontiguous memory allocation model allows many disjoint areas of memory
to be allocated to a process, which enables direct reuse of several small areas of
memory. We describe memory reuse techniques and the model of noncontiguous
memory allocation in Chapter 11. The kernel uses special techniques to meet its
own memory requirements efficiently. These techniques are also discussed in this
chapter.
Virtual Memory  Modern operating systems provide virtual memory, which is a
storage capability that is larger than the actual memory of a computer system.
The OS achieves it by storing the code and data of a process on a disk, and
loading only some portions of the code and data in memory. This way, a process
can operate even if its size exceeds the size of memory.
The operating system employs the noncontiguous memory allocation model
to implement virtual memory. It maintains a table of memory allocation infor-
mation to indicate which portions of the code and data of a process are present in
memory, and what their memory addresses are. During operation of the process,
the CPU passes each instruction address or data address used by it to a spe-
cial hardware unit called the memory management unit (MMU), which consults
the memory allocation information for the process and computes the address in
memory where the instruction or data actually resides. If the required instruction
or data does not exist in memory, the MMU causes a "missing from memory"
interrupt. The operating system now loads the portion that contains the required
instruction or data in memory--for which it might have to remove some other



20  Part 1  Overview
                                                    Memory             Memory allocation
                                                    Operating          information of Pi
                                                    system             Operand address
                      "Missing                                         in instruction
                      from memory"                                     being executed
                      interrupt
                                 Memory
                        management                             Loading/removal                 Code and data
                                 unit                                  of portions of          of processes
                                                                       code and data
                                    Memory address
                                       of operand                      Memory areas allocated  to process Pi
            Figure 1.8  A schematic of virtual      memory operation.
                                                                       User process
                                                    File system
                                                    Input output control system
                                                               (IOCS)
                                                    Computer hardware
            Figure 1.9  An overview of file system and input output control system (IOCS).
            portion from memory--and resumes operation of the process. Figure 1.8 is a
            schematic diagram of virtual memory when a process Pi is in operation.
                      A "missing from memory" interrupt slows down progress of a process, so
            the operating system has to make two key decisions to ensure a low rate of these
            interrupts: how many and which portions of the code and data of a process should
            it keep in memory. The techniques used in making these decisions are described
            in Chapter 12.
            1.4.4 Management of Files and I/O Devices
            A file system has to meet several expectations of its users--provide fast access
            to a file, protect the file against access by unauthorized persons, and provide
            reliable operation in the presence of faults such as faulty I/O media or power
            outages--and also ensure efficient use of I/O devices. A file system uses a layered
            organization to separate the various issues involved in fulfilling these expecta-
            tions; Figure 1.9 shows an abstract view. The upper layer, which is the file system
            itself, permits a user to share his files with some other users, implements file
            protection and provides reliability. To implement an operation on a file, the file



                                                      Chapter 1                         Introduction  21
system invokes the lower layer, which contains the input output control system
(IOCS). This layer ensures fast access to files by a process, and efficient use of I/O
devices.
File System     The file system provides each user with a logical view in which the
user has a home directory at an appropriate place in the directory structure of
the file system. The user can create directories, or folders, as they are called in
the Windows operating system, in his home directory, and other directories or
folders in these directories, and so on. A user can authorize some collaborators
to access a file by informing the file system of the names of collaborators and the
name of the file. The file system uses this information to implement file protection.
To ensure reliability, the file system prevents damage to the data in a file, and to
its own data such as a directory, which is called the metadata, due to faults like
faulty I/O media or power outages. All these features of file systems are discussed
in Chapter 13.
Input Output Control System (IOCS)  The IOCS implements a file operation by
transferring data between a process and a file that is recorded on an I/O device.
It ensures efficient implementation of file operations through three means--by
reducing the time required to implement a data transfer between a process and an
I/O device, by reducing the number of times data has to be transferred between a
process and an I/O device, and by maximizing the number of I/O operations that
an I/O device can complete in a given period of time. Its techniques are discussed
in Chapter 14.
Security and Protection  Security and protection threats, and the arrangement
used to implement security and protection, were described earlier in Section 1.3.3.
The OS encrypts the password data through an encryption function known only
to itself. Encryption strengthens the security arrangement because an intruder
cannot obtain passwords of users except through an exhaustive search, which
would involve trying out every possible string as a password. Various security
and protection threats, the technique of encryption, and various methods used
to implement protection are described in Chapter 15.
1.4.5 Distributed Operating Systems
A distributed computer system consists of several computer systems, each with its
own memory, connected through networking hardware and software. Each com-
puter system in it is called a node. Use of a distributed computer system provides
three key advantages: speeding up of a computer application by scheduling its
processes in different nodes of the system simultaneously, high reliability through
redundancy of computer systems and their resources, and resource sharing across
node boundaries. To realize these advantages, a distributed OS must tackle the
following fundamental issues:
·  Networking causes delays in the transfer of data between nodes of a dis-
   tributed system. Such delays may lead to an inconsistent view of data located
   in different nodes, and make it difficult to know the chronological order in
   which events occurred in the system.



22      Part 1  Overview
                         ·    Control functions like scheduling, resource allocation, and deadlock detec-
                              tion have to be performed in several nodes to achieve computation speedup
                              and  provide  reliable  operation  when  computers       or  networking  compo-
                              nents fail.
                         ·    Messages exchanged by processes present in different nodes may travel over
                              public networks and pass through computer systems that are not controlled
                              by the distributed operating system. An intruder may exploit this feature
                              to tamper with messages, or create fake messages to fool the authentication
                              procedure and masquerade as a user of the system (see Figure 1.4).
                              The chapters of part 5 present various facets of a distributed operating
                         system. Chapter 16 discusses the model of a distributed computer system, net-
                         working hardware and software, and distributed computation paradigms, which
                         permit parts of a computation to be performed in different nodes. Chapter 17 dis-
                         cusses the theoretical issues that arise from networking delays, and the methods
                         of tackling them. Chapter 18 discusses how the OS performs its control func-
                         tions in a distributed manner. Chapter 19 describes the reliability techniques of
                         fault tolerance and recovery, which enable a distributed system to provide conti-
                         nuity of operation when failures occur. Chapter 20 describes the reliability and
                         performance improvement techniques employed in distributed file systems, while
                         Chapter 21 discusses the security issues in distributed systems and the techniques
                         employed to address them.
1.5     SUMMARY                                                                                                  ·
A computer user's requirements are determined by          ·  User convenience: Provide convenient methods
a computer's role in fulfilling his need. For some           of using a computer system.
users, computing is merely a means to fulfilling a        ·  Noninterference: Prevent interference in the
need like Internet browsing or sending of e-mails,           activities of its users.
whereas for some others it directly satisfies their
needs like running programs to perform data pro-             An operating system meets these requirements
cessing or scientific computations. An operating          by performing three primary functions during its
system has to meet the needs of all its users, so it      operation -- management      of  programs,   manage-
has diverse functionalities.                              ment of resources, and security and protection. An
     A  modern  computer      has  an  abundance      of  OS is a complex software system that may con-
resources like memory and disk space, and it also         tain millions of lines of code, so we use abstraction
has a powerful CPU. To ensure that computer               to master the complexity of studying its design.
users benefit from this abundance, the operating          Abstraction helps us to focus on a specific aspect
system services many programs simultaneously by           of a system, whether a hardware system like a com-
distributing its resources among them and inter-          puter, a software system like an operating system,
leaving their execution on the CPU. The OS has to         or a real-life system like the urban transportation
satisfy three requirements to ensure effectiveness        network, and ignore details that are not relevant
of computing:                                             to this aspect. We will use abstraction throughout
· Efficient use: Ensure efficient use of a com-           the book to study different aspects of design and
     puter's resources.                                   operation of operating systems.



                                                                                Chapter 1  Introduction                 23
The plan of the book is as follows: We begin                and use of files by programs and ensures secu-
by discussing how an operating system interacts             rity and protection. This is followed by the study
with a computer system to control its operation.            of distributed operating systems, which control
We then study how the operating system man-                 operation of several computer systems that are
ages execution of programs, allocation of memory,           networked.
TEST  YOUR CONCEPTS                                                                                                     ·
1.1   Classify each of the following statements as true          and      (ii)  efficient  use      of     a  computer
      or false:                                                  system:
      a. The boot procedure is used to initiate a user           a. Virtual memory
      program.                                                   b. File protection
      b. The technique of preemption is employed to              c. Noncontiguous memory allocation
      share the CPU among user programs.                    1.3  Classify the following into security lapses and
      c. Resources may be wasted if an OS employs                protection lapses:
      pool-based resource allocation.                            a. Scribbling your password on a piece of paper
      d. Assignment of virtual resources to processes            b. Authorizing everybody to perform read and
      prevents mutual interference between them.                     write operations on your file
      e. Threats posed by an authenticated user are              c. Leaving your monitor unattended in the mid-
      security threats.                                              dle of a session
1.2   Indicate whether each of the following techni-             d. Downloading a program that is known to
      ques/arrangements provides (i) user convenience                contain a virus
EXERCISES                                                                                                               ·
1.1   A computer can operate under two operating                 its memory at any time and consequently the
      systems, OS1 and OS2. A program P always exe-              CPU    is  often  idle    because  of  lack  of    work.
      cutes successfully under OS1. When executed                Swapping is a technique of removing an inactive
      under OS2, it is sometimes aborted with the                program from memory and loading a program
      error "insufficient resources to continue execu-           that requires use of the CPU in its place so that
      tion," but executes successfully at other times.           the CPU can service it. Does swapping improve
      What is the reason for this behavior of pro-               (a) user service and (b) efficiency of use? What
      gram P? Can it be cured? If so, explain how,               is its effect on OS overhead?
      and describe its consequences. (Hint: Think of        1.4  Comment on validity of the following state-
      resource management policies.)                             ment: "Partitioned resource allocation provides
1.2   A time-sharing operating system uses the fol-              more user convenience but may provide poor
      lowing scheduling policy: A program is given               efficiency."
      a limited amount of CPU time, called the time         1.5  A program is in a dormant state if it is not
      slice, each time it is selected for execution. It is       engaged in any activity (e.g., it may be waiting for
      preempted at the end of the time slice, and it             an action by a user). What resources does a dor-
      is considered for execution only after all other           mant program consume? How can this resource
      programs that wish to use the CPU have been                consumption be reduced?
      given an opportunity to use the CPU. Comment          1.6  An     OS      creates  virtual  devices     when  it  is
      on (a) user service and (b) efficiency of use, in a        short of real devices. Does creation of virtual
      time-sharing system.                                       devices improve (a) user service, (b) efficiency
1.3   If a computer has a very fast CPU but a small              of use?
      memory, few computer programs can fit into



24              Part 1      Overview
     1.7  Can     deadlocks     arise    in  the  following  situa-    1.8  A user wishes to let his collaborators access some
          tions?                                                            of his files, but expects the OS to prevent his col-
          a. A system performs partitioned allocation of                    laborators from accessing his other files, and also
           resources to programs.                                           prevent noncollaborators from accessing any of
          b. A    set   of  programs     communicate       through          his files. Explain how it is achieved jointly by the
           message passing during their execution.                          user and the OS.
BIBLIOGRAPHY                                                                                                                      ·
The view of an OS as the software that manages a com-                  4.   Garfinkel, S., G. Spafford, and A. Schwartz
puter system is usually propounded in most operating                        (2003): Practical UNIX and Internet Security,
systems texts. Tanenbaum (2001), Nutt (2004), Silber-                       3rd ed., O'Reilly, Sebastopol, Calif.
schatz et al. (2005), and Stallings (2005) are some of the             5.   Kilburn, T., D. J. Howarth, R. B. Payne, and
recent texts on operating systems.                                          F. H. Sumner (1961): "The Manchester
     Berzins et al. (1986) discusses how the complex-                       University Atlas Operating System, Part I:
ity of designing a software system can be reduced by                        Internal Organization," Computer Journal, 4 (3),
constructing a set of abstractions that hide the inter-                     222 ­ 225.
nal working of a subsystem. Most books on software                     6.   Ludwig, M. A. (1998): The Giant Black Book of
engineering discuss the role of abstraction in software                     Computer Viruses, 2nd ed., American Eagle,
design. The paper by Parnas and Siewiorek (1975) on                         Show Low.
the concept of transparency in software design is con-                 7.   Ludwig, M. A. (2002): The Little Black Book of
sidered a classic of software engineering. The book by                      Email Viruses, American Eagle, Show Low.
Booch (1994) discusses abstractions in object oriented                 8.   Nutt, G. (2004): Operating Systems--A Modern
software development.                                                       Perspective, 3rd ed., Addison-Wesley, Reading,
     The concept of virtual devices was first used in the                   Mass.
spooling system of the Atlas computer system developed                 9.   Parnas, D. L., and D. P. Siewiorek (1975): "Use of
at Manchester University. It is described in Kilburn et al.                 the concept of transparency in the design of
(1961).                                                                     hierarchically structured systems,"
     Ludwig (1998) and Ludwig (2002) describe differ-                       Communications of the ACM, 18 (7), 401­408.
ent kinds of viruses, while Berghel (2001) describes the               10.  Pfleeger, C. P., and S. Pfleeger (2003): Security in
Code Red worm that caused havoc in 2001. Pfleeger                           Computing, Prentice Hall, Englewood Cliffs, N.J.
and  Pfleeger     (2003)    is  a  text  on  computer      security.   11.  Russinovich, M. E., and D. A. Solomon (2005):
Garfinkel  et     al.  (2003)   discusses    security  in    Solaris,       Microsoft Windows Internals, 4th ed., Microsoft
Mac OS, Linux, and FreeBSD operating systems. Russi-                        Press, Redmond, Wash.
novich and Solomon (2005) discusses security features                  12.  Silberschatz, A., P. B. Galvin, and G. Gagne
in Windows.                                                                 (2005): Operating System Principles, 7th ed.,
1.   Berghel, H. (2001): "The Code Red worm,"                               John Wiley, New York.
     Communications of the ACM, 44 (12), 15­19.                        13.  Stallings, W. (2005): Operating Systems--
2.   Berzins, V., M. Gray, and D. Naumann (1986):                           Internals and Design Principles, 5th ed., Pearson
     "Abstraction-based software development,"                              Education, New York.
     Communications of the ACM, 29 (5), 403­415.                       14.  Tanenbaum, A. S. (2001): Modern Operating
3.   Booch, G. (1994): Object-Oriented Analysis and                         Systems, 2nd ed., Prentice Hall, Englewood
     Design, Benjamin-Cummings, Santa Clara.                                Cliffs, N.J.
