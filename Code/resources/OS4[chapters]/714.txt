Theoretical Issues in Distributed Systems


                                                         Chapte                              r  17
Theoretical Issues in
Distributed Systems
T ime and state are two key notions used in an operating system--the OS
      needs to know the chronological order in which events such as resource
      requests occur, and it needs to know the states of resources and processes
for performing resource allocation and scheduling. In a conventional computer
system, presence of a single memory and a single CPU simplifies handling of time
and state. Only one event can occur at any time, so the OS knows the chronological
order of events implicitly, and it knows states of all processes and resources in the
system.
A distributed system consists of several computer systems, each with a clock,
memory, and one or more CPUs, that communicate through messages, which
incur unpredictable communication delays. Consequently, the distributed OS can-
not know the chronological order in which events occur, or the states of resources
and processes in all nodes of the system at the same instant of time. Therefore, the
key theoretical issues in distributed systems are to evolve practical alternatives to
the traditional notions of time and state, develop algorithms to implement these
alternatives, and show correctness of these algorithms.
We present the notion of event precedence which can be used to discover
the chronological order in which some events occur in a distributed system. We
then discuss two alternatives to the traditional notion of time, using the notions of
logical clocks and vector clocks. We also present the notion of a consistent recording
of state that can be used as an alternative to global state of a distributed system
in several applications. These alternative notions of time and state are employed
in the design of distributed control algorithms and recovery algorithms used in
a distributed OS.
17.1     NOTIONS OF TIME AND STATE                                                        ·
Time is the fourth dimension; it indicates when an event occurred. The state of an
entity is the condition or mode of its being. The state of an entity depends on its
features; e.g., the state of a memory cell is the value contained in it. If an entity is
                                                                                                693



694  Part 5  Distributed Operating Systems
             composed of other entities, its state contains the states of its component entities.
             The global state of a system comprises the states of all entities in the system at a
             specific instant of time. An OS uses the notions of time and state for performing
             scheduling of resources and the CPU: It uses time to know when a request event
             occurred, or to find the chronological order in which request events occurred, and
             it uses the state of a resource to decide whether it can be allocated. A distributed
             OS also uses these notions in recovery to ensure that processes of a distributed
             computation would be in mutually consistent states after recovery from the crash
             of a node that contained some of the processes.
             It is easy to handle time and state in a uniprocessor OS. The system has a
             clock and a single CPU, so the OS can find the times at which processes made
             their resource requests and use this information to determine their chronological
             order. However, a typical conventional operating system uses the notion of time
             only implicitly. When an event occurs, it adds information about the event to a
             queue, so the queue shows the chronological order of events. The OS also knows
             states of processes, and the states of all physical and logical resources.
             In a distributed system, each node is a computer system with its own clock
             and a local memory, and nodes are connected by communication links which
             have unpredictable communication delays. Consequently, a node cannot precisely
             determine the time at which an event occurred in another node; its perception
             of the state of a remote process or resource may also be stale. Thus, a dis-
             tributed OS cannot use the notions of time and state in the same manner as a
             uniprocessor OS.
             In this chapter, we discuss some theoretical concepts in distributed systems
             and use them to develop practical alternatives to the notions of time and state as
             used in a uniprocessor system. These alternative notions of time and state are used
             in Chapter 18 in the design of distributed control algorithms, and in Chapter 19
             in the design of recovery schemes.
             17.2  STATES AND EVENTS IN A DISTRIBUTED SYSTEM                                             ·
             17.2.1 Local and Global States
             Each entity in a system has its own state. The state of a memory cell is the value
             contained in it. The state of a CPU is the contents of its PSW and general-purpose
             registers. The state of a process is its state tag; state of the memory allocated to it;
             the CPU state if it is currently scheduled on the CPU, or contents of PCB fields if
             it is not scheduled on the CPU; and the state of its interprocess communication,
             which consists of information concerning the messages received and sent by it.
             The state of an entity is called a local state. The global state of a system at time
             instant t is the collection of local states of all entities in it at time t.
             We denote the local state of a process Pk at time t as skt , where the subscript
             is omitted if the identity of the process is implicit in the context. We denote the
             global state of a system at time t as St. If a system contains n processes P1, . . . , Pn,
             St  {s1t , s2t , . . . , snt }.



                                                        Chapter    17     Theoretical Issues in Distributed  Systems  695
                                             Event  ei
        Old state        s                                             s  New state
        of Pk                                                             of Pk
Figure  17.1 Change  of  state  in  process  Pk on  occurrence of  event (Pk , s, s , send, c, m).
17.2.2 Events
An event could be the sending or receiving of a message over a channel, which
is an interprocess communication path, or some other happening that does not
involve a message. The state of a process changes when an event occurs in it. We
represent an event as follows:
        (process id, old state, new state, event description, channel, message)
where channel and message are written as "­" if the event does not involve sending
or receiving of a message. An event ei  (Pk, s, s , send, c, m) can occur only when
process Pk is in state s. The event is the sending of a message m over a channel c.
When this event occurs, process Pk           enters the new state s       (see Figure 17.1).
Certain events can occur only when some conditions are met, e.g., a receive
event for message m on channel c can occur only if channel c contains message
m. Thus, only some events may be feasible in the current state of a process.
17.3    TIME, CLOCKS, AND EVENT PRECEDENCES                                                                           ·
Let a global clock be an abstract clock that can be accessed from different sites of a
distributed system with identical results. If processes in two nodes of a distributed
system perform the system call "give current time" at the same time instant, they
would obtain identical time values. If they perform these system calls  time
units apart, they would obtain time values that differ by exactly  time units.
A global clock cannot be implemented in practice because of communication
delays. Requests for current time made in two different nodes at the same time
instant would face different communication delays to reach the site where the
clock is maintained. Consequently, they would be given different time values.
Similarly, requests that are made  time units apart may get time values that do
not differ by exactly  time units.
Since a global clock cannot be implemented, we can explore an alternative
arrangement that uses a clock in each process. Such a clock is called a local
clock. The local clock of a process would be accessed whenever the process per-
forms a "give current time" system call. To implement a practical timekeeping
service using this idea, local clocks should be reasonably well synchronized.
Section 17.3.2 discusses how clock synchronization can be achieved, using the
notion of event precedence.



696  Part 5  Distributed Operating Systems
             17.3.1 Event Precedence
             The notation e1  e2 is used to indicate that event e1 precedes event e2 in time;
             i.e., event e1 occurred before event e2. Event ordering implies arranging a set of
             events in a sequence such that each event in the sequence precedes the next one.
             In essence, it implies determining the order in which events have occurred in a
             system. A total order with respect to the precedes relation "" is said to exist if
             all events that can occur in a system can be ordered. A partial order implies that
             some events can be ordered but not all events can be ordered--to be precise, at
             least two events exist that cannot be ordered.
                Table 17.1 summarizes the fundamental rules used to order events. These
             rules can be explained as follows: The OS can readily determine precedence
             between events occurring within the same process. Events like execution of a
             "send P3, <message mi>" event in a process P2 and a receive event in P3 that
             receives message mi have a causal relationship, i.e., a cause-and-effect relation-
             ship. Consequently, the send event in process P2, which is the cause, precedes the
             receive event in process P3, which is its effect. The precedes relation is transitive
             in nature, hence e1  e3 if e1  e2 and e2  e3. This property can be used to
             determine precedences between some events that neither have a causal relation-
             ship nor occur within the same process. For example, an event ei preceding the
             send event for message mi in P2 precedes an event ej that follows the receive event
             for message mi in P3, because ei precedes the send event, the send event precedes
             the receive event, and the receive event precedes event ej.
                Using the rules of Table 17.1, precedence between any two events ei and ej
             can be classified as follows:
             ·  ei precedes ej : If events ek and el exist such that ek  el , ei  ek or ei          ek,
                and el  ej or el  ej .
             ·  ei follows ej : If events eg and eh exist such that eg  eh, ej  eg or ej            eg,
                and eh  ei or eh  ei.
             ·  ei is concurrent with ej : If ei neither precedes nor follows ej .
                A timing diagram is a plot of the activities of different processes against time--
             processes are marked along the vertical axis in the plot, and time is marked along
             Table 17.1  Rules for          Ordering of Events in a Distributed System
             Category                       Description of rule
             Events within a process        The OS performs event handling, so it knows the order
                                            in which events occur within a process.
             Events in different            In a causal relationship, i.e., a cause-and-effect
             processes                      relationship, an event that corresponds to the cause
                                            precedes an event in another process that corresponds
                                            to the effect.
             Transitive precedence          The precedes relation is transitive; i.e., e1  e2 and
                                            e2  e3 implies e1  e3.



                                                        Chapter 17  Theoretical Issues in Distributed Systems        697
the horizontal axis. We use the notation ekn for event en in process Pk. Exam-
ple 17.1 demonstrates use of a timing diagram in determining event precedences
by using transitiveness of the precedes relation. It also illustrates why a total order
over events does not exist in a distributed system.
                                                                                                                     ·
   Event Precedence                                                                             Example        17.1
   Figure 17.2 shows activities in processes P1 and P2. Event e23 is a "send" event
   while e12 is a "receive" event for message m1. Hence e23  e12. The transitive
   nature of "" leads to the precedence relations e22  e12 and e21  e12.
   Transitiveness also yields e22  e13 and e21  e13. Event e11 is concurrent
   with events e21 and e22. It is also concurrent with events e23 and e24!
                                                                                             ·
17.3.2 Logical Clocks
An OS needs a practical method of event ordering for purposes related to schedul-
ing and resource allocation. The method should be efficient, so it should perform
event ordering directly, instead of working through causal relationships and tran-
sitivity. It should also provide a total order over events so that the OS can provide
FCFS service to resource requests. Such an order can be obtained by
·  Incorporating event precedences into the event order.
·  Arbitrarily ordering events that are concurrent, e.g., the events e11 and e21 in
   Figure 17.2.
   Timestamping of events provides a direct method of event ordering. Each
process has a local clock that is accessible only to itself. The timestamp of an
event is its occurrence time according to the local clock of the process. Let ts(ei)
represent the timestamp of event ei. Event ordering is performed in accordance
with the timestamps of events, i.e., ei, ej        :  ei  ej if ts(ei) < ts(ej ) and ej  ei
if ts(ei) > ts(ej). However, local clocks in different processes may show different
times because of clock drift, which would affect reliability of timestamp-based
event ordering. For example, if event ei occurred before event ej, ts(ei) should
be < ts(ej); however, if the clock at the process where event ei occurred is run-
ning faster than the clock at the process where ej occurred, ts(ei) may be >
ts(ej). To avoid such situations, it is necessary to synchronize the clocks of all
processes.
                 P1                          e11        e12  e13
                                                        m1
                 P2    e21  e22                    e23       e24
Figure 17.2  Event precedence via timing diagram.



698  Part 5  Distributed Operating Systems
                       Synchronization of local clocks is achieved by using the causal relationship
                   found in interprocess message exchange. Consider a message m sent by pro-
                   cess Pk to process Pl . Let timestamps of the send and receive events be tk and
                   tl , respectively. The cause-and-effect relationship between the send and receive
                   events implies that tk must be smaller than tl . If it is not, the situation can be cor-
                   rected by increasing the time in the local clock of the receiver process to some
                   value greater than tk before timestamping the receive event. Algorithm 17.1 is the
                   complete clock synchronization algorithm.
                   Algorithm 17.1 Clock Synchronization
                   1.  When a process Pk wishes to send a message m to process Pl : Pk executes
                       a command "send Pl , (ts(send(m)), m)," where ts(send(m)) is a timestamp
                       obtained just prior to sending message m.
                   2.  When process Pl receives a message: Process Pl performs the actions
                           if local clock(Pl ) < ts(send(m)) then
                           local clock(Pl ) := ts(send(m)) + ;
                           timestamp the receive event.
                       where local clock(Pl ) is the value in the local clock of process Pl and  is the
                       average communication delay in the network.
                       The clock synchronization achieved by Algorithm 17.1 is called loose syn-
                   chronization because clocks of the two processes are mutually consistent at
                   a message exchange, but can drift apart at other times (see Exercise 17.1).
                   The quality of clock synchronization depends on the frequency of interprocess
                   communication--a higher frequency of communication provides tighter synchro-
                   nization. Synchronization can be improved by using special synchronization mes-
                   sages that are exchanged at short intervals simply to keep the clocks synchronized.
                       Note that clocks synchronized in this manner do not show "real" time. For
                   example, if the clock at a sender process is fast, the clock at the receiver process
                   would also be advanced. Once we accept that the local clocks do not show "real"
                   time, there is no need to keep incrementing them all the time. A process may
                   increment its local clock by 1 only when an event occurs in it, and synchronize
                   the local clock, if necessary, when it receives a message. Such clocks are called
                   logical clocks. We denote the logical clock of process Pk by LCk. Logical clocks
                   are implemented according to the following rules:
                       R1  A process Pk increments LCk by 1 whenever an event occurs in it.
                       R2  When process Pk receives a message m containing ts(send(m)), Pk
                           sets its clock by the rule LCk = max (LCk, ts(send(m))+1).
                   The next example illustrates synchronization of logical clocks by these rules.
·
     Example 17.2  Synchronization of Logical Clocks
                   Figure 17.3 contains the timing diagram for a system consisting of three pro-
                   cesses. The pair of numbers appearing in parentheses below an event indicate
                   values in the logical clock of the process before and after the event. The logical



                                                           Chapter 17          Theoretical  Issues  in  Distributed  Systems  699
                              e11                               e12       e13
                     P1  (9, 10)                           (10, 27) (27, 28)
                              m1            e22            m3             m4
                     P2               (11, 12)
                                   e21                               e23       e24
                                   (3, 11)  m2                       (12, 13) (13, 29)
                     P3                          e31       e32
                                            (24, 25) (25, 26)
    Figure 17.3  Synchronization of logical clocks.
    clock in P1 contains 9 when P1 decides to send message m1 to P2. It is incre-
    mented by rule R1 and the send event is timestamped, so m1 contains the
    timestamp 10. When P2 receives the message, its clock reads 3. It first incre-
    ments its clock to 4, using rule R1, and then synchronizes it, using rule R2.
    The clock now reads 11.
       When P2 decides to send message m2, its logical clock is incremented
    to 12. m2 thus contains the timestamp 12. When m2 reaches P3, P3 applies
    rules R1 and R2. Rule R2 has no effect since P3's logical clock value is much
    larger than the timestamp in the message. When P3 sends m3 to P1, P1's clock
    is synchronized to P3's clock. Similarly P2's clock gets synchronized to P1's
    clock when P1 sends m4 to P2.
                                                                                                        ·
    Timestamps obtained by using logical clocks have the property that ts(ei)
< ts(ej) if ei  ej. However, the converse is not guaranteed for events occur-
ring in different processes; i.e., ei may not precede ej even if ts(ei) < ts(ej). Such
a situation may arise if ei and ej occur in processes X and Y , respectively, of
the system, and there has been no direct synchronization of the clocks of X
and Y either due to lack of message traffic between them or because the clock
at  process   Y  is  running  faster    than     that  at       process   X    (because     more        events
occurred in process Y than in process X ). We see this situation in Figure 17.3,
where  e32    occurs     "earlier  than"    event     e23  but       has  a    larger   timestamp       than
that of e23.
Obtaining Unique Timestamps             Events in different processes would obtain iden-
tical timestamps if the logical clocks in their processes happen to have identical
time values when they occurred. Consequently, these timestamps cannot be used
to obtain a total order over events. This problem can be overcome by using a pair
pts(ei) as the timestamp of an event ei, where
                         pts(ei)  (local time, process id)



700  Part 5  Distributed Operating Systems
             This  way,     events      cannot    have  identical      timestamps.       Event  ordering       is  now
             performed by defining event precedence as follows:
                     ei   precedes ej        iff  (i) pts(ei).local    time <  pts(ej ).local   time,     or
                                                  (ii) pts(ei).local   time = pts(ej).local time          and
                                                      pts(ei).process id < pts(ej ).process id                 (17.1)
             where pts(ei).local time and pts(ei).process id are the local time and process id in
             pts(ei), respectively. Note that this notion of event precedence would provide an
             identical ordering of events ei and ej as that obtained through logical clocks, if
             processes had different local times when events ei and ej occurred in them.
             17.3.3 Vector Clocks
             A vector clock is a vector containing n elements, where n is the number of processes
             in the distributed system. We denote the vector clock of process Pk by VCk, and
             its lth element by VCk[l]. Elements of the vector clock VCk have the following
             significance:
                 VC k [k ]                  The logical clock of process Pk
                 VCk[l], l = k              The highest value in the logical clock of process Pl which is
                                            known to process Pk--that is, the highest value of VCl [l]
                                            known to it
                   The timestamp of an event ei occurring in a process Pk is the value of VCk
             when ei occurred. Thus, the timestamp is a vector; we call it the vector timestamp.
             We denote the vector timestamp of event ei by vts(ei), and the lth element of
             vts(ei) by vts(ei)[l]. When process Pk sends a message m to process Pl , it includes
             vts(send(m)) in the message. Vector clocks are implemented according to the
             following rules:
                 R3  A process Pk increments VCk[k] by 1 whenever an event occurs in it.
                 R4  When process Pk receives a message m containing vts(send(m)), Pk
                     sets its clock as follows:
                                  For all l: VCk[l] = max (VCk[l], vts(send(m))[l]).
             From these rules, VCk[k]  VCl [k] for all l. If ei, ej are two consecutive events
             in  process    Pk ,  vts(ej )[k]     =   vts(ei )[k]   +  1  by  rule  R3.  If   ei, ej  were  send   and
             receive events for a message in processes Pg and Pk, respectively, process Pk
             would increment VCk[k] by rule R3 when ej occurs, and then update VCk by
             rule R4 before timestamping ej. Consequently, vts(ei)[l]  vts(ej)[l], for all l and
             vts(ei)[k] < vts(ej )[k]. We represent this condition as vts(ei) < vts(ej ).
                   The precedence between events ei and ej is obtained as follows:
             ·   ei precedes      ej :  For  all  l:  vts(ei )[l ]     vts(ej )[l], but  for  some    k:  vts(ei )[k]  =
                 vts(ej )[k].



                                                         Chapter 17          Theoretical Issues in Distributed Systems        701
·  ei follows ej : For all l: vts(ei)[l]  vts(ej )[l], but for some k: vts(ei)[k]                       =
   vts(ej )[k].
·  ei, ej are concurrent: For some k, l: vts(ei)[k] < vts(ej )[k] and vts(ei)[l]                        >
   vts(ej )[l].
Timestamping through vector clocks has two important properties: Every event
has a unique timestamp as a result of rules R3 and R4, and vts(ei) < vts(ej) if
and only if ei  ej. The next example illustrates these properties.
                                                                                                                              ·
   Synchronization of Vector Clocks                                                                          Example    17.3
   Figure    17.4  shows    synchronization          of  vector         clocks     for  the     system  of
   Figure 17.3. The vector timestamp after the occurrence of an event is shown
   below it. When message m1 is received, VC2[2] is incremented by 1 and
   VC2[1] is updated to 10. Analogously, when message m2 is received by pro-
   cess P3, VC3[3] is incremented by 1 and VC3[1] and VC3[2] are updated.
   Events e32 and e23 are concurrent events because vts(e32)[2] < vts(e23)[2] and
   vts(e32)[3] > vts(e23)[3].
                                                                                                        ·
   The property that vts(ei) < vts(ej ) if and only if ei  ej implies that vector
clocks do not provide a total order over events. Total order can be obtained by
using a pair pvts(ei)  (local time, process id) as the timestamp of an event ei and
the following event ordering relation:
   ei  precedes ej     iff  (i) pvts(ei).local       time <        pvts(ej).local time,      or
                            (ii) ei, ej are concurrent events and
                                      pvts(ei).process id < pvts(ej).process id                  (17.2)
where pvts(ei).local time and pvts(ei).process                id   are  the  local      vector   time   and
process id in pvts(ei), respectively.
                            e11                               e12       e13
                   P1       (10,0,0)                     (11,4,26) (12,4,26)
                            m1             e22           m3             m4
                   P2                 (10,4,0)
                                      e21                          e23        e24
                                 (10,3,0) m2                       (10,5,0)  (12,6,26)
                   P3                           e31      e32
                                           (10,4,25) (10,4,26)
Figure 17.4  Synchronization of vector clocks.



702  Part 5  Distributed Operating Systems
             17.4  RECORDING THE STATE OF A DISTRIBUTED SYSTEM                                             ·
             As discussed in Section 17.2.1, the global state of a distributed system at a time
             instant t is the collection of local states of all entities in the system at time t.
             However, it is not possible to get all nodes to record their states at the same time
             instant because local clocks are not perfectly synchronized. Any other collection
             of local states may be inconsistent. Consider the distributed system shown in
             Figure 17.5. A banking application has a process P1 in node N1 and a process P2
             in node N2, which perform the following actions:
             1. Process P1 debits $100 to account A.
             2. Process P1 sends a message to process P2 to credit $100 to account B.
             3. Process P2 credits $100 to account B.
             The recorded states of nodes N1 and N2 would be inconsistent if the balance
             in account A is recorded before Step 1 and that in account B is recorded
             after Step 3. A distributed OS cannot use such a state to perform its control
             functions.
             In this section we present an algorithm for obtaining a consistent collec-
             tion of local states. Such a collection of states is not a substitute for the global
             state; however, it has properties that facilitate some of the control functions in a
             distributed OS.
             Consistent State Recording              A state recording is a collection of local states of
             entities in a system obtained through some algorithm. A consistent state recording
             is one in which process states of every pair of processes in the system are consistent
             according to Definition 17.1.
             Definition 17.1 Mutually Consistent Local States       Local states of processes
             Pk and Pl are mutually consistent if
             1.    Every message recorded as "received from Pl " in Pk's state is  recorded          as
                   "sent to Pk" in Pl 's state, and
             2.    Every message recorded as "received from Pk" in Pl 's state is  recorded          as
                   "sent to Pl " in Pk's state.
             In the state recording mentioned at the start of this section, the state of P2
             indicates that it has received the message from P1 concerning credit of $100 in
             account B, but the state of P1 does not indicate that it has sent such a message.
                                                A              B
                                            N1  900            300  N2
             Figure 17.5  A funds transfer system.



                                                     Chapter 17        Theoretical Issues in Distributed Systems  703
Hence the state recording is inconsistent. A state recording that shows any of the
following situations would have been consistent:
1. Accounts A and B contain $900 and $300, respectively.
2. Accounts A and B contain $800 and $400, respectively.
3. Accounts A and B contain $800 and $300, respectively.
In case 1, none of the processes had received a message before its state was
recorded, so the process states are consistent. In case 2, the message recorded as
received from P1 in P2's state is recorded as sent in P1's state. In case 3, again
none of the process states records receipt of a message. The message from P1 to
P2 is in transit. It will be delivered to process P2 sometime in future, and process
P2 will add $100 to account B when it receives the message. This is why mutual
consistency of process states requires that every message recorded as received
should be recorded as sent, but not vice versa.
17.4.1 Properties of a Consistent State Recording
Figure 17.6 shows a model of a distributed computation. The computation
consists of four processes P1­P4 that communicate among themselves through
messages. An edge (Pi, Pj ) represents a channel Chij , i.e., an interprocess commu-
nication path that is used by process Pi to send messages to process Pj. Note that
a channel is unidirectional--a process either sends or receives messages along a
channel, but not both. Channels Ch23 and Ch32 together indicate that processes
P2 and P3 send messages to one another.
Figure 17.7 shows the timing diagram of the computation. Table 17.2 shows
states of processes P1­P4 recorded at time instants tP1 , tP2 , tP3 , and tP4 , respec-
tively. These time instants are marked with the symbol                 in the figure. The state
of process P1 shows that it has received message m21, but not sent out any mes-
sages, while the state of process P2 shows that it has sent out messages m21 and
m23 before tP2 but not received any messages. These states are mutually consistent
according to Definition 17.1. However, the states of P3 and P4 are not mutually
consistent because the state of process P3 records message m43 as received but
process P4's state does not record it as sent. Hence the state recording of Table 17.2
is not a consistent state recording.
                             P1                                  P4
                                               Ch42
                             Ch21                                Ch43
                                               Ch23
                             P2                                  P3
                                               Ch32
Figure 17.6  A  distributed  computation  for  state recording.



704  Part 5  Distributed Operating Systems
                                                 e11       e12  tP1       e13
                              P1
                                                 m21                 tP2
                              P2                      e23                      e24     e25
                                            e21  e22            m23
                                                      e32 tP3                       m32
                              P3                 e31
                                                                     e33  e34
                                            tP4       m43                 m42
                              P4                 e41                 e42
             Figure 17.7  A  timing diagram for the distributed computation of Figure       17.6.
             Table 17.2       Local States of Processes
             Process          Description of recorded state
             P1               No messages have been sent. Message m21 has been received.
             P2               Messages m21 and m23 have been sent. No messages have been
                              received.
             P3               No messages have been sent. Message m43 has been received.
             P4               No messages have been sent. No messages have been received.
             Cut of a System  The notion of a cut of a system helps in determining the con-
             sistency of a state recording. Let tPi be the point in a timing diagram at which
             the state of a process Pi is recorded.
             Definition 17.2 Cut of a System          A curve that connects the points in a tim-
             ing diagram at which states of processes are recorded, in increasing order by
             process number.
                 The cut of the distributed computation shown in Figure 17.7 represents the
             recorded state shown in Table 17.2. The term "a cut is taken" means that a
             collection of local states is recorded. An event that had occurred in a process
             before the state of the process was recorded is said to occur "to the left of the
             cut" in the timing diagram. Such an event belongs in the past of the cut. An event
             that would occur in a process after the state of the process was recorded is said
             to occur "to the right of the cut" in the timing diagram. Such an event belongs
             to the future of the cut. A cut represents a consistent state recording of a system
             if the states of each pair of processes satisfy Definition 17.1.
             State of a Channel             The state of a channel Chij is the set of messages con-
             tained in Chij, i.e., the messages sent by process Pi that are not yet received



                                                 Chapter 17    Theoretical Issues in Distributed Systems  705
by  process  Pj .  We   use  the   following   notation  to    determine  the  state  of  a
channel Chij :
      Recorded_sentij   The set of messages recorded as sent over channel Chij
                        in the state of Pi
      Recorded_recd ij  The set of messages recorded as received over channel
                        Chij in the state of Pj
    Recorded_sentij     =    Recorded_recd ij  implies   that  all  messages   sent   by  Pi
have  been   received   by   Pj .  Hence  the  channel   is  empty.  Recorded_sentij      -
Recorded_recdij = , where "-" represents the set difference operator, implies
that some messages sent by Pi have not been received by Pj. These messages are
still contained in channel Chij . Recorded_recdij - Recorded_sentij = , implies
that process Pj has recorded as received at least one message that is not recorded
as sent by process Pi. This situation indicates inconsistency of the recorded
local states of Pi and Pj according to Definition 17.1.
    A cut in the timing diagram may intersect with a message mk sent by process
Pi to process Pj over channel Chij . The manner of the cut indicates whether the
recorded states of Pi and Pj are consistent with respect to the sending and receipt
of the message. It also indicates the state of the channel. Three possibilities are:
·   No intersection with a message: The message send and receive events are either
    both located to the left of the cut or both located to the right of the cut. In
    either case, the message did not exist in channel Chij when the cut was taken.
·   Forward intersection with a message: The message send event is located to
    the left of the cut and the message receive event is located to the right of
    the cut. Hence, the message existed in channel Chij when the cut was taken.
    The cut in the timing diagram of Figure 17.7 has a forward intersection with
    message m23.
·   Backward intersection with a message: The message send event is located to
    the right of the cut and the message receive event is located to the left of the
    cut. Hence, the message had been received but had not been sent when the cut
    was taken. Such a message indicates an inconsistency in the recorded state.
    The cut in the timing diagram of Figure 17.7 has a backward intersection
    with message m43.
    From these observations, we can formulate a consistency condition for a cut
as follows:
    CC       A cut C represents a consistent state recording of a distributed
             system if the future of the cut is closed under the precedes relation
             on events, i.e., closed under "".
    Condition CC can be explained as follows: A set of items I is said to be closed
under a relation R, if using the relation on any item in I yields an item that is also
in I . Let I be the set of events in the future of a cut. Applying the relation ""
to an event ei  I gives us an event ej such that ei  ej , i.e., ei precedes ej . If I is
closed under "", this event also belongs to I . That is, it does not belong to the
past of the cut. This condition is equivalent to the restriction that a cut should



706  Part 5  Distributed Operating Systems
                                                      C1       e12        C2          e13            C3
                                   P1
                                   P2                 e23
                                                 e22
                                   P3                        e32
                                                                     e33  e34
                                   P4                 e41
                   Figure 17.8  Consistency  of  cuts--cuts  C1, C2  are  consistent  while  C3  is  inconsistent.
                   not have a backward intersection with a message. A forward intersection does
                   not violate condition CC since its send event is in the past and its receive event is
                   in the future.
·
     Example 17.4  Consistency of a Cut
                   In Figure 17.8, cuts C1 and C2 are consistent cuts because there is no event
                   ej belonging to the past of the cut that follows an event ei in the future of the
                   cut. Cut C3 is inconsistent because event e13 follows event e34 because of the
                   cause-and-effect relationship between a send and a receive; however, e34 is in
                   the future of C3 while e13 is in its past.
                   ·
                   17.4.2 An Algorithm for Consistent State Recording
                   This section describes the state recording algorithm by Chandy and Lamport
                   (1985). The algorithm makes the following assumptions:
                      1. Channels are unidirectional.
                      2. Channels have unbounded capacities to hold messages.
                      3. Channels are FIFO.
                   The assumption of FIFO channels implies that messages received by a destination
                   process must be the first few messages sent by a sender process, and messages
                   contained in a channel must be the last few messages sent by a process.
                      To initiate a state recording, a process records its own state and sends
                   a state recording request called a marker on every outgoing channel. When
                   a process receives a marker, it records the state of the channel over which
                   it received the marker. If the marker is the first marker it received from any
                   process, it also records its own state and sends a marker on every outgoing



                                         Chapter 17       Theoretical Issues in Distributed Systems        707
channel. We use the following notation to discuss how the state of a channel is
determined:
    Receivedij       The set of messages received by process Pj on channel
                     Chij before it received the marker on channel Chij .
    Recorded_recdij  The set of messages recorded as received over channel
                     Chij in the state of process Pj .
Algorithm 17.2 Chandy­Lamport Algorithm
1.  When a process Pi initiates the state recording: Pi records its own state and
    sends a marker on each outgoing channel connected to it.
2.  When process Pj receives a marker over an incoming channel Chij : Process Pj
    performs the following actions:
    a. If Pj had not received any marker earlier, then
        i.    Record its own state.
        ii.   Record the state of channel Chij as empty.
        iii.  Send a marker on each outgoing channel connected to it.
    b.  Otherwise, record the state of   channel  Chij    as  the  set  of  messages
        Receivedij - Recorded_recdij .
    Rules of Algorithm 17.2 are executed atomically, i.e., as indivisible operations.
Recording of the channel state by the algorithm can be explained as follows:
Let a process Pi send messages mi1 , mi2 , . . . min on channel Chij before recording
its own state and sending a marker on Chij. Let process Pj have two incoming
channels Chij and Chkj . If the marker on channel Chij is the first marker Pj
received, it would record its own state, which would show Recorded_recdij and
Recorded_recdkj as the messages received by it. Pj would also record the state of
Chij as empty. Because channels are FIFO, process Pj would have received the
marker after receiving messages mi1, mi2, . . . , min on Chij , so it is correct to record
the state of channel Chij as empty.
    Let Pj receive two more messages mk1 and mk2 on Chkj before it received
the marker. Hence Receivedkj = Recorded_recdkj  { mk1, mk2 } and the state of
channel Chkj would be recorded as the set of messages Receivedkj - Recorded-
_recdkj i.e., { mk1, mk2 }. It is correct because process Pk would have sent messages
mk1 , mk2 before it recorded its own state and sent the marker on channel Chkj ,
so if these messages were not received by Pi by the time it recorded its own state,
they must have been in the channel.
    Example 17.5 illustrates operation of the Chandy­Lamport algorithm.
                                                                                                           ·
Operation of the Chandy-Lamport Algorithm                                                   Example  17.5
Figure 17.9(a) shows a distributed system at time 0. Process P1 has sent message
m1 to P3. The message currently exists in Ch13. At time 1, process P3 sends
message m2 to process P2. At time 2, P1 decides to record the state of the
system, so it records its own state and sends markers on its outgoing channels.



708  Part 5  Distributed Operating Systems
                    P2        P3                       P2   m2    P3                 P2  m2 m3    P3
                                            P3                                                        
                              m1                                  m1
                                                                                                
                          P1                                P1                           P1
                    (a)                                (b)                     (c)
             Figure 17.9  Example of the Chandy­Lamport algorithm: system at times 0, 2+, and 5+.
             Table 17.3       Recorded States of Processes and Channels in
             Figure 17.9
                Entity                      Description of recorded state
                P1                          Message m1 has been sent. No messages have been
                                            received.
                P2                          No messages have been sent or received.
                P3                          Messages m2 and m3 have been sent. Message m1 has     been
                                            received.
                Ch12                        Empty
                Ch13                        Empty
                Ch23                        Contains the messages m2 and m3
             Figure 17.9(b) shows the situation at time 2+. Message m1 is still in channel
             Ch13 and m2 is in Ch32. The bullets indicate markers. The symbol                   indicates
             that the state of a process has been recorded.
                    Process P2 receives the marker on Ch12 at time 3, records its own state and
             records the state of Ch12 as empty. Process P3 sends message m3 to process
             P2 at time 4 and receives the marker on Ch13 at time 5. It now records its
             own state, records the state of Ch13 as empty, and sends a marker on Ch32.
             Figure 17.9(c) shows the situation at time 5+. States of all processes have been
             recorded. States of channels Ch12 and Ch13 have also been recorded; however,
             the state of Ch32 is yet to be recorded.
                    When the marker on Ch32 reaches process P2, P2 will record the state
             of Ch32 according to step 2(b) of Algorithm 17.2. It is recorded as messages
             {m2, m3} because these messages are in Received32 but not in Recorded_recd32.
             Table 17.3 shows the state recording of the system.
             ·
             Properties of the Recorded State               Let tb and te be the time instants when the state
             recording of system S begins and ends. Let RS be the recorded state of the system.
             One would expect that system S would have been in the state RS at some time
             instant ti such that tb < ti < te. However, this may not be so! That is, the recorded



                                                                   Chapter 17    Theoretical Issues in Distributed Systems        709
state RS may not match any global state of the system. Example 17.6 illustrates
this fact.
                                                                                                                                  ·
Recorded State versus Global State                                                                              Example     17.6
Figure 17.7 shows the timing diagram of the distributed system of Figure 17.6.
Let  P4       initiate  state  recording             at  time      instant  t1.  The       timing  diagram  of
Figure 17.10 shows how the markers are sent and received by processes during
state recording. The markers are shown as dotted arrows.
     Table 17.4 shows channel and process states recorded by the Chandy­
Lamport algorithm. Only message m21 is recorded as sent by P2 and received
by P1. No other messages are recorded as sent or received. However, because
the timing diagram of Figure 17.7 is drawn to scale, it is clear that the system
never existed in a state in which message m21 had been sent and received but no
other messages had been sent--the message-send and message-receive events
e23, e32, and e41 had occurred before event e12, the message-receive event for
message m21. Thus any global state that recorded message m21 as received
would have also recorded message m43 as sent and received, and message m23
as sent.
                                                                                                            ·
    Even though the system may not have existed in the recorded state at any
point in time, the recorded state is useful for applications that require only mutual
              P1                                e11           e12       e13
                                                m21
              P2                                         e23                     e24  e25
                                     e22
                                                                   m23                m32
              P3                                         e32
                                                                   e33      e34
                                                     m43                m42
              P4                  4             e41                e42
                               t  1
Figure 17.10  State recording of     the system of Figures 17.6 and 17.7.
Table 17.4    A Recorded State that Does Not Match Any Global State
Entity                  Description of recorded state
P1                      No messages have been sent. Message m21 has been received.
P2                      Message m21 has been sent. No messages have been received.
P3                      No messages have been sent or received.
P4                      No messages have been sent or received.
 States of all channels are recorded as empty.



710          Part 5   Distributed Operating Systems
                           consistency of local states. Consider the problem of finding the total funds in a
                           banking system. When $100 is transferred from account A to account B, it is
                           irrelevant whether the recorded state shows this amount to be in account A or
                           account B or in the channel connecting the two, so long as it shows exactly
                           one of these three possibilities. The state recorded by Algorithm 17.2 meets this
                           requirement.
                           Chandy and Lamport (1985) shows that Algorithm 17.2 can be used to detect
                           a class of properties called stable properties. A stable property is one that, if it
                           holds in the global state of a system at time instant ti, it would hold in the
                           global state of the system at all time instants tj > ti. Algorithm 17.2 is executed
                           periodically to obtain a state recording and the recorded state is analyzed to
                           detect presence of the stable property. This scheme may fail to capture the stable
                           property in the first state recording that completes at a time instant > ti. However,
                           this failure is not disastrous because the property would continue to hold and
                           some later execution of the scheme would capture it. A useful stable property is
                           existence of a cycle, knot, or resource knot in a WFG or an RRAG, which can
                           be used for deadlock detection (see Chapter 8). Another useful stable property is
                           the distributed termination condition, which is defined as a situation in which all
                           processes participating in a distributed computation are passive and no messages
                           between the processes are in transit (see Section 18.6).
17.5     SUMMARY                                                                                                       ·
An operating system uses the notions of time and               relationship between events--that is, cause-and-
state for controlling operation of user processes              effect relationship--to find which of the events
and for organizing its own functioning. However,               occurred earlier. For example, in interprocess mes-
each node in a distributed system has its own clock            sage communication, the sending of a message is a
and memory, so these notions cannot be employed                cause and its receipt is the effect. Hence the receive
as simply as in a conventional operating system.               event of a message is known to occur after its send
In this chapter, we developed alternative notions              event. Using transitivity, it follows that an event
of time and state for use in a distributed system.             that preceded a send event of a message must have
     An  OS     uses  the  notion  of  time  to      know      occurred before an event that followed its receipt.
the  order  in  which  events  occurred,     so      that  it  However, for some pairs of events, it is not possible
can service events in time-dependent orders such               to know which of the events occurred earlier. Such
as FCFS and LIFO. The notion of precedence                     events are called concurrent events.
of events, which indicates which event occurred                It is laborious to deduce the precedence of
before which other event, is transitive, that is, if           events by using transitivity. Hence an OS asso-
event ei occurred before ej and event ej occurred              ciates a timestamp, i.e., occurrence time, with each
before ek, then ei must have occurred before ek.               event and compares the timestamps of two events
The OS can determine precedence of events as fol-              to know which of them occurred earlier. To facil-
lows: If two events occurred in the same node,                 itate timestamping, the OS maintains a clock in
the OS knows which of them occurred earlier. For               each process, which is called the local clock of the
events occurring in different nodes, the OS uses               process, and keeps the local clocks of processes well
transitivity of events and the notion of a causal              synchronized. It performs clock synchronization



                                                          Chapter 17  Theoretical Issues in Distributed Systems            711
by using the causal relationship governing inter-                    of its nodes obtained at exactly the same instant of
process messages as follows: Each message con-                       time. It is not possible to record the global state
tains the timestamp of its send event. The local                     by asking each node to record its local state at a
clock in the process receiving the message must                      specific time instant, because clocks in the nodes
show a time larger than the timestamp in the mes-                    are not perfectly synchronized. An arbitrary collec-
sage. If it is not so, the local clock in the receiving              tion of local states of nodes may be inconsistent.
process is incremented to a time that is larger than                 For example, if nodes record their states sponta-
the timestamp in the message. Since local clocks                     neously, the local state of node Ni may be recorded
do not show the real time, they are called logical                   before it sent a message m to node Nj and the local
clocks. Timestamps using logical clocks have the                     state of Nj may be recorded after it received mes-
property that if ti, tj are the timestamps of events                 sage m. This problem was overcome by Chandy and
ei, ej ,  respectively,   ti   <  tj  if  event ei  precedes   ej .  Lamport (1985) by using special messages called
An alternative system of clocks called vector clocks                 markers to instruct individual nodes to record their
has the additional property that ti < tj implies that                local states. They showed that if interprocess com-
event ei occurred before ej. For concurrent events,                  munication is FIFO, the local states of processes
it is immaterial how we order them. Hence a pair                     recorded by their algorithm were mutually consis-
(process id, timestamp) is used to obtain a total                    tent. The collection of these local states can be used
order on events.                                                     to detect stable properties, which are properties that
The state of a node is called its local state. The                   do not change with time, such as presence of cycles
global state of a system is a collection of local states             in wait-for graphs.
TEST      YOUR CONCEPTS                                                                                                       ·
17.1      Classify each of the following statements as true           a.  If process Pi sends messages to process Pj ,
          or false:                                                       but process Pj does not send messages to pro-
          a.  Events ei and ej are concurrent events only                 cess Pi, states of processes Pi, Pj are mutually
              if ts(ei) = ts(ej ), where ts(ei), ts(ej ) are the          consistent local states only if
              timestamps of ei, ej using logical clocks.                  i. All messages sent by process Pi to process
          b.  Even if ts(ei) > ts(ej ), event ei could have               Pj have been received by process Pj .
              occurred earlier than event ej .                            ii. Some        messages  sent  by     process  Pi  to
          c.  Even if vts(ei) > vts(ej ), event ei could have             process         Pj  have  not   been   received     by
              occurred earlier than event ej .                            process Pj .
          d.  A message from process Pi to process Pj that                iii. All messages received by process Pj from
              intersects with a cut of a system is a mes-                 process Pi have been sent by process Pi.
              sage that has been sent by Pi but not received              iv. None of (i)­(iii).
              by  Pj  in  the  states  of  processes  Pi  and  Pj     b.  If event ei in process Pi is in the past of a
              represented by the cut.                                     cut Ck,
          e. In a state recorded by the Chandy­Lamport                    i. All events in the system that precede event
              algorithm, the state of channel Chij is likely              ei are in the past of the cut Ck.
              to be nonempty only if process Pj receives a                ii. Some of the events that precede event ei
              marker on some other channel before receiv-                 may be in the past of the cut Ck.
              ing the marker on channel Chij .                            iii. All events that occur after event ei are in
17.2      Select the appropriate alternative in each of the               the future of the cut Ck.
          following questions:                                            iv. None of (i)­(iii).



712         Part 5  Distributed Operating Systems
EXERCISES                                                                                                                       ·
17.1  In Example 17.2, P3's time is much larger than                    using causal relationships. Give an example of
      that of P1 or P2. List all conditions under which                 a    system  showing      such  events.      Comment    on
      this can happen.                                                  the advantages and drawbacks of using rela-
17.2  The following events occur in a system consisting                 tion (17.1).
      of three processes:                                        17.5   Instead of using relation (17.2) to obtain a total
      process P1            process P2      process P3                  order using vector timestamps, it is proposed to
                                                                        use the following relation:
      event e1;             event e3;       event e5;                        ei precedes ej  iff
      ­­                    ­­              ­­                          (i) pvts(ei).local time < pvts(ej ).local time, or
      Send                  Receive         Send
      message               message         message                     (ii) pvts(ei).local time = pvts(ej ).local time and
      to P2;                from P3;        to P2;                               pvts(ei).process id < pvts(ej ).process id
      event e2;             Receive         event e6;                   Comment on the correctness of this proposal.
                            message                              17.6   ti and tj are timestamps of events ei and ej .
                            from P1;                                    a. Give an example of a system in which ti < tj
                            ­­              Receive                          when logical clocks are used but ti < tj when
                                            message                          vector clocks are used.
                                            from P2;                    b. If ti < tj when vector clocks are used, show
                            event e4;       ­­                               that ti < tj when logical clocks are used.
                            Send            event e7;                   c. If ti < tj when logical clocks are used, show
                            message                                          that ti > tj when vector clocks are used.
                            to P3;                               17.7   Vector   timestamps         of  concurrent      events  ei
      a. Draw a timing diagram for the system.                          and  ej  are   such    that     vts(ei )[k]  <  vts(ej )[k].
      b. Show event precedences in this system.                         Show     that  events     ei  and    el  are    concurrent
      c. List the concurrent events.                                    if vts(el )[g] = vts(ej )[g] for all g          =  k  and
17.3  Synch(Pi, Pj , tk) = true if the logical clocks of Pi             vts(el )[k] > vts(ej )[k].
      and Pj are reasonably consistent at time instant           17.8   Explain, with the help of an example, why the
      tk; i.e., if the difference between their values is               Chandy­Lamport algorithm requires channels
      <, for some small value . If RP(i, k) is the set                  to be FIFO.
      of processes from whom Pi has received a mes-              17.9   A transitless state of a system is a state in which
      sage before tk and SP(i, k) is the set of processes               no messages are in transit. (See Table 17.4 for an
      to which Pi has sent a message before tk, deter-                  example.) Give an example of a system in which
      mine whether Synch(Pi, Pj , tk) would be true in                  all  states   recorded    by    the  Chandy­Lamport
      the following situations:                                         algorithm are necessarily transitless.
      a. RP(i, k)        RP( j, k) =                             17.10  A system consists of processes Pi, Pj and chan-
      b. There      exists  a   Pg          SP(i, k)  such that         nels Chij and Chji. Each process sends a message
          Pj   SP(g, k)                                                 to the other process every  seconds. Every mes-
      c.  Pj   SP(i, k)                                                 sage requires  seconds to reach Pj . Prove that
      d.  Pj   RP(i, k) but Pj  RP(i, k - 1)                            if   <    , the state recording initiated by Pi
      e.  Pj   SP(i, k) and Pi  SP(j, k)                                using the Chandy­Lamport algorithm cannot
      f.  Pj   RP(i, k) but Pj            RP(i, k - 1)      and         be transitless.
          Pi has not received any message from any               17.11  Give an example of a system in which the state
          process after the time it sent a message to Pj .              recorded by the Chandy­Lamport algorithm is
17.4  Relation    (17.1)    imposes      a  total  order  even          one of the states in which the system existed
      if  events    can     be  only   partially   ordered   by         sometime during the execution of the algorithm.



                                                    Chapter  17      Theoretical Issues in Distributed Systems           713
17.12  What will be the state recording in Example 17.6,     17.14   The assumption concerning FIFO channels can
       if the state recording request in channel Ch42 is             be removed from Algorithm 17.2 as follows: A
       delayed and delivered to process P2 immediately               flag field is added to each message. This field
       after event e23 occurs?                                       contains the values before token or after token
17.13  The  Chandy­Lamport        algorithm  works  cor-             depending on whether the message is sent before
       rectly if more than one node in a distributed                 or after sending a token on the same channel.
       system spontaneously initiates a state record-                If a process receives a message with the flag
       ing. Describe working of the algorithm if pro-                value after token before it receives a token on the
       cesses P2 and P4 of Figure 17.6 initiate state                same channel, it performs the same actions as it
       recording (a) before sending any messages, (b)                would have performed on receiving a token, and
       after one message has been sent on each of                    ignores the token when it is received later. For-
       Ch21, Ch32  and  Ch43      and  no  other  messages           mulate rules for recording the state of a channel
       are sent.                                                     using this scheme.
BIBLIOGRAPHY                                                                                                              ·
Lamport (1978) discusses ordering of events in a dis-            5.  Lai, T. H., and T. H. Yang (1987) : "On
tributed system and defines a partial order on events.               distributed snapshots," Information Processing
Mattern (1989), Garg (2002), and Attiya and Welch                    Letters, 25, 153­158.
(2004) discuss vector clocks and consistency of cuts.            6.  Lamport L. (1978): "Time, clocks, and the
Consistency of cuts is also discussed in Chandy and                  ordering of events in a distributed system,"
Lamport (1985) and Knapp (1987).                                     Communications of the ACM, 21, 7 (July 1978),
    Chandy and Lamport (1985) developed the dis-                     558­565.
tributed snapshot problem described in Section 17.2,             7.  Li, H. F., T. Radhakrishnan, and K. Venkatesh
which requires FIFO channels. Li, Radhakrishnan, and                 (1987) : "Global state detection in non-FIFO
Venkatesh (1987), Lai and Yang (1987), and Mattern                   networks," Proceedings of the 7th International
(1989) describe algorithms that do not require chan-                 Conference on Distributed Computing Systems,
nels to be FIFO. Lynch (1996) and Tel (2000) discuss                 364­370.
algorithms for global snapshots.                                 8.  Lynch, N. (1996): Distributed Algorithms,
1.  Attiya, H., and J. Welch (2004): Distributed                     Morgan Kaufmann.
    Computing: Fundamentals, Simulations and                     9.  Mattern, F. (1989) : "Virtual time and global
    Advanced Topics, John Wiley, New York.                           states of distributed systems," M. Cosnard et al.
2.  Chandy K. M., and L. Lamport (1985):                             (eds.), Parallel and Distributed Algorithms,
    "Distributed snapshots: Determining global                       Elsevier Science, North Holland.
    states of distributed systems," ACM Transactions         10.     Spezialetti, M., and P. Kearns (1986) : "Efficient
    on Computer Systems, 3, 1 (Feb. 1985), 63­75.                    distributed snapshots," Proceedings of the 6th
3.  Garg, V. K. (2002): Elements of Distributed                      International Conference on Distributed
    Computing, Wiley-IEEE, New York.                                 Computing Systems, 382­388.
4.  Knapp, E. (1987): "Distributed deadlock                  11.     Tel, G. (2000): Introduction to Distributed
    Detection," Computing Surveys, 19, 4 (Dec. 1987),                Algorithms, 2nd ed. Cambridge University
    303­328.                                                         Press, Cambridge.
